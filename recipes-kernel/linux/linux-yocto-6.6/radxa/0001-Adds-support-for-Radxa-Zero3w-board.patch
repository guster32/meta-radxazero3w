From 4fc7c492f56559537f03929c375d1e19a939bdb9 Mon Sep 17 00:00:00 2001
From: Gustavo Branco <guster32@gmail.com>
Date: Sat, 25 Jan 2025 19:11:43 -0800
Subject: [PATCH] Adds support for Radxa Zero3w board

---
 .../devicetree/bindings/arm/rockchip.yaml     |    5 +
 arch/arm64/boot/dts/rockchip/Makefile         |    1 +
 .../rk3566-radxa-zero-3w-aic8800ds2.dts       |  142 +
 .../boot/dts/rockchip/rk3566-radxa-zero3.dtsi |  860 ++++
 arch/arm64/boot/dts/rockchip/rk3566.dtsi      |   52 +-
 .../rockchip/rk3568-dram-default-timing.dtsi  |  400 ++
 .../boot/dts/rockchip/rk3568-pinctrl.dtsi     |  103 +-
 arch/arm64/boot/dts/rockchip/rk3568.dtsi      | 3861 ++++++++++++++++-
 .../boot/dts/rockchip/rockchip-pinconf.dtsi   |   71 +
 drivers/pinctrl/Makefile                      |    1 +
 drivers/pinctrl/pinctrl-rockchip.c            | 1803 ++++++--
 drivers/pinctrl/pinctrl-rockchip.h            |   31 +-
 include/dt-bindings/clock/rk3568-cru.h        |   10 +-
 include/dt-bindings/clock/rockchip-ddr.h      |   63 +
 include/dt-bindings/display/drm_mipi_dsi.h    |   53 +
 include/dt-bindings/display/rockchip-tve.h    |   15 +
 include/dt-bindings/display/rockchip_vop.h    |   21 +
 include/dt-bindings/input/rk-input.h          |  814 ++++
 include/dt-bindings/input/rk-ir.h             |   33 +
 include/dt-bindings/memory/rk3568-dram.h      |  111 +
 include/dt-bindings/memory/rockchip-dram.h    |  102 +
 include/dt-bindings/sensor-dev.h              |   18 +
 include/dt-bindings/soc/rockchip,boot-mode.h  |   12 +-
 .../dt-bindings/soc/rockchip-system-status.h  |   58 +
 include/dt-bindings/suspend/rockchip-rk3568.h |   57 +
 include/linux/rockchip/cpu.h                  |  261 ++
 include/linux/rockchip/grf.h                  |  700 +++
 include/linux/rockchip/nvmem.h                |   26 +
 include/linux/rockchip/psci.h                 |   76 +
 include/linux/rockchip/rockchip_sip.h         |  487 +++
 30 files changed, 9628 insertions(+), 619 deletions(-)
 create mode 100644 arch/arm64/boot/dts/rockchip/rk3566-radxa-zero-3w-aic8800ds2.dts
 create mode 100644 arch/arm64/boot/dts/rockchip/rk3566-radxa-zero3.dtsi
 create mode 100644 arch/arm64/boot/dts/rockchip/rk3568-dram-default-timing.dtsi
 create mode 100644 include/dt-bindings/clock/rockchip-ddr.h
 create mode 100644 include/dt-bindings/display/drm_mipi_dsi.h
 create mode 100644 include/dt-bindings/display/rockchip-tve.h
 create mode 100644 include/dt-bindings/display/rockchip_vop.h
 create mode 100644 include/dt-bindings/input/rk-input.h
 create mode 100644 include/dt-bindings/input/rk-ir.h
 create mode 100644 include/dt-bindings/memory/rk3568-dram.h
 create mode 100644 include/dt-bindings/memory/rockchip-dram.h
 create mode 100644 include/dt-bindings/sensor-dev.h
 create mode 100644 include/dt-bindings/soc/rockchip-system-status.h
 create mode 100644 include/dt-bindings/suspend/rockchip-rk3568.h
 create mode 100644 include/linux/rockchip/cpu.h
 create mode 100644 include/linux/rockchip/grf.h
 create mode 100644 include/linux/rockchip/nvmem.h
 create mode 100644 include/linux/rockchip/psci.h
 create mode 100644 include/linux/rockchip/rockchip_sip.h

diff --git a/Documentation/devicetree/bindings/arm/rockchip.yaml b/Documentation/devicetree/bindings/arm/rockchip.yaml
index ca5389862887..fd68d2f77a97 100644
--- a/Documentation/devicetree/bindings/arm/rockchip.yaml
+++ b/Documentation/devicetree/bindings/arm/rockchip.yaml
@@ -551,6 +551,11 @@ properties:
           - const: rockchip,rk3568-odroid-m1
           - const: rockchip,rk3568
 
+      - description: Radxa Zero3w
+        items:
+          - const: rockchip,rk3566-radxa-zero3w
+          - const: rockchip,rk3566
+
       - description: Hugsun X99 TV Box
         items:
           - const: hugsun,x99
diff --git a/arch/arm64/boot/dts/rockchip/Makefile b/arch/arm64/boot/dts/rockchip/Makefile
index e7728007fd1b..739a21d550b5 100644
--- a/arch/arm64/boot/dts/rockchip/Makefile
+++ b/arch/arm64/boot/dts/rockchip/Makefile
@@ -95,6 +95,7 @@ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-nanopi-r5c.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-nanopi-r5s.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-odroid-m1.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-radxa-e25.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3566-radxa-zero-3w-aic8800ds2.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-roc-pc.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-rock-3a.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588-edgeble-neu6a-io.dtb
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-radxa-zero-3w-aic8800ds2.dts b/arch/arm64/boot/dts/rockchip/rk3566-radxa-zero-3w-aic8800ds2.dts
new file mode 100644
index 000000000000..ea6693cb9a3f
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3566-radxa-zero-3w-aic8800ds2.dts
@@ -0,0 +1,142 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
+ * Copyright (c) 2023 Radxa Limited.
+ *
+ */
+
+/dts-v1/;
+
+#include "rk3566-radxa-zero3.dtsi"
+
+/ {
+	model = "Radxa ZERO 3";
+	compatible = "radxa,zero3w-aic8800ds2", "radxa,zero3", "rockchip,rk3566";
+
+	wireless_wlan: wireless-wlan {
+		compatible = "wlan-platdata";
+		rockchip,grf = <&grf>;
+		WIFI,poweren_gpio = <&gpio0 RK_PC0 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	wireless_bluetooth: wireless-bluetooth {
+		compatible = "bluetooth-platdata";
+		uart_rts_gpios = <&gpio2 RK_PB5 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default", "rts_gpio";
+		pinctrl-0 = <&uart1m0_rtsn>;
+		pinctrl-1 = <&uart1_gpios>;
+		BT,reset_gpio    = <&gpio0 RK_PC1 GPIO_ACTIVE_HIGH>;
+		BT,wake_gpio     = <&gpio0 RK_PB4 GPIO_ACTIVE_HIGH>;
+		BT,wake_host_irq = <&gpio0 RK_PB3 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_enable_h>;
+		reset-gpios = <&gpio0 RK_PC0 GPIO_ACTIVE_LOW>;
+	};
+
+	board_antenna: board-antenna {
+		status = "okay";
+		compatible = "regulator-fixed";
+		enable-active-low;
+		gpio = <&gpio3 RK_PD3 GPIO_ACTIVE_LOW>;
+		regulator-always-on;
+		regulator-boot-on;
+		pinctrl-0 = <&ant_1>;
+		pinctrl-names = "default";
+		regulator-name = "board_antenna";
+	};
+};
+
+&uart1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1m0_xfer &uart1m0_ctsn>;
+};
+
+&sdmmc1 {
+	supports-sdio;
+	bus-width = <4>;
+	disable-wp;
+	cap-sd-highspeed;
+	cap-sdio-irq;
+	keep-power-in-suspend;
+	non-removable;
+	rockchip,default-sample-phase = <180>;
+	mmc-pwrseq = <&sdio_pwrseq>;
+	non-removable;
+	no-sd;
+	no-mmc;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc1_bus4 &sdmmc1_cmd &sdmmc1_clk>;
+	sd-uhs-sdr104;
+	status = "okay";
+};
+
+&pinctrl {
+	wifi {
+		wifi_enable_h: wifi-enable-h {
+			rockchip,pins = <0 RK_PC0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+	};
+
+	wireless-bluetooth {
+		uart1_gpios: uart1-gpios {
+			rockchip,pins = <2 RK_PB5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	sdmmc1 {
+		/omit-if-no-ref/
+		sdmmc1_bus4: sdmmc1-bus4 {
+			rockchip,pins =
+				/* sdmmc1_d0 */
+				<2 RK_PA3 1 &pcfg_pull_up_drv_level_12>,
+				/* sdmmc1_d1 */
+				<2 RK_PA4 1 &pcfg_pull_up_drv_level_12>,
+				/* sdmmc1_d2 */
+				<2 RK_PA5 1 &pcfg_pull_up_drv_level_12>,
+				/* sdmmc1_d3 */
+				<2 RK_PA6 1 &pcfg_pull_up_drv_level_12>;
+		};
+
+		/omit-if-no-ref/
+		sdmmc1_clk: sdmmc1-clk {
+			rockchip,pins =
+				/* sdmmc1_clk */
+				<2 RK_PB0 1 &pcfg_pull_up_drv_level_12>;
+		};
+
+		/omit-if-no-ref/
+		sdmmc1_cmd: sdmmc1-cmd {
+			rockchip,pins =
+				/* sdmmc1_cmd */
+				<2 RK_PA7 1 &pcfg_pull_up_drv_level_12>;
+		};
+
+		/omit-if-no-ref/
+		sdmmc1_det: sdmmc1-det {
+			rockchip,pins =
+				/* sdmmc1_det */
+				<2 RK_PB2 1 &pcfg_pull_up>;
+		};
+
+		/omit-if-no-ref/
+		sdmmc1_pwren: sdmmc1-pwren {
+			rockchip,pins =
+				/* sdmmc1_pwren */
+				<2 RK_PB1 1 &pcfg_pull_none>;
+		};
+	};
+
+	antenna {
+		ant_1: ant-1 {
+			rockchip,pins = <3 RK_PD3 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-radxa-zero3.dtsi b/arch/arm64/boot/dts/rockchip/rk3566-radxa-zero3.dtsi
new file mode 100644
index 000000000000..0245f92ca3d6
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3566-radxa-zero3.dtsi
@@ -0,0 +1,860 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
+ * Copyright (c) 2023 Radxa Limited.
+ *
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/display/rockchip_vop.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/input/rk-input.h>
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include <dt-bindings/sensor-dev.h>
+#include <dt-bindings/leds/common.h>
+#include "rk3566.dtsi"
+
+/ {
+	model = "Radxa ZERO 3";
+	compatible = "radxa,zero3", "rockchip,rk3566";
+
+	fiq_debugger: fiq-debugger {
+		compatible = "rockchip,fiq-debugger";
+		rockchip,serial-id = <2>;
+		rockchip,wake-irq = <0>;
+		/* If enable uart uses irq instead of fiq */
+		rockchip,irq-mode-enable = <1>;
+		rockchip,baudrate = <1500000>;  /* Only 115200 and 1500000 */
+		interrupts = <GIC_SPI 252 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart2m0_xfer>;
+		status = "okay";
+	};
+
+	debug: debug@fd904000 {
+		compatible = "rockchip,debug";
+		reg = <0x0 0xfd904000 0x0 0x1000>,
+			<0x0 0xfd905000 0x0 0x1000>,
+			<0x0 0xfd906000 0x0 0x1000>,
+			<0x0 0xfd907000 0x0 0x1000>;
+	};
+
+	cspmu: cspmu@fd90c000 {
+		compatible = "rockchip,cspmu";
+		reg = <0x0 0xfd90c000 0x0 0x1000>,
+			<0x0 0xfd90d000 0x0 0x1000>,
+			<0x0 0xfd90e000 0x0 0x1000>,
+			<0x0 0xfd90f000 0x0 0x1000>;
+	};
+
+	vcc_sys: vcc-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+	};
+
+	vcc3v3_sys: vcc3v3-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vcc_sys>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc_sys>;
+	};
+
+	gpio_leds: gpio-leds {
+		compatible = "gpio-leds";
+		status = "okay";
+
+		board-led {
+			gpios = <&gpio0 RK_PA0 GPIO_ACTIVE_HIGH>;
+			pinctrl-0 = <&board_led>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	hdmi_sound: hdmi-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <128>;
+		simple-audio-card,name = "rockchip-hdmi0";
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s0_8ch>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&hdmi>;
+		};
+	};
+};
+
+&cpu0 {
+	cpu-supply = <&vdd_cpu>;
+};
+
+&dfi {
+	status = "okay";
+};
+
+&dmc {
+	center-supply = <&vdd_logic>;
+	status = "okay";
+};
+
+&gpu {
+	mali-supply = <&vdd_gpu>;
+	status = "okay";
+};
+
+&pmu_io_domains {
+	status = "okay";
+	pmuio2-supply = <&vcc_3v3>;
+	vccio1-supply = <&vccio_acodec>;
+	vccio2-supply = <&vcc_1v8>;
+	vccio3-supply = <&vccio_sd>;
+	vccio4-supply = <&vcc_1v8>;
+	vccio5-supply = <&vcc_3v3>;
+	vccio6-supply = <&vcc_3v3>;
+	vccio7-supply = <&vcc_3v3>;
+};
+
+&i2c0 {
+	status = "okay";
+
+ 	vdd_cpu: rk860x@40 {
+		status = "okay";
+		compatible = "silergy,syr827";
+		reg = <0x40>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "fan53555-reg";
+		regulator-name = "vdd_cpu";
+		regulator-min-microvolt = <712500>;
+		regulator-max-microvolt = <1390000>;
+		regulator-init-microvolt = <1000000>;
+		regulator-ramp-delay = <2300>;
+		fcs,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	rk817: pmic@20 {
+		compatible = "rockchip,rk817";
+		reg = <0x20>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <3 IRQ_TYPE_LEVEL_LOW>;
+
+		pinctrl-names = "default", "pmic-sleep",
+				"pmic-power-off", "pmic-reset";
+		pinctrl-0 = <&pmic_int>;
+		pinctrl-1 = <&soc_slppin_slp>, <&rk817_slppin_slp>;
+		pinctrl-2 = <&soc_slppin_gpio>, <&rk817_slppin_pwrdn>;
+		pinctrl-3 = <&soc_slppin_gpio>, <&rk817_slppin_rst>;
+		rockchip,system-power-controller;
+		wakeup-source;
+		#clock-cells = <1>;
+		clock-output-names = "rk808-clkout1", "rk808-clkout2";
+		//fb-inner-reg-idxs = <2>;
+		/* 1: rst regs (default in codes), 0: rst the pmic */
+		pmic-reset-func = <0>;
+		/* not save the PMIC_POWER_EN register in uboot */
+		not-save-power-en = <1>;
+
+		vcc1-supply = <&vcc_sys>;
+		vcc2-supply = <&vcc_sys>;
+		vcc3-supply = <&vcc_sys>;
+		vcc4-supply = <&vcc_sys>;
+		vcc5-supply = <&vcc_sys>;
+		vcc6-supply = <&vcc_sys>;
+		vcc7-supply = <&vcc_sys>;
+		vcc8-supply = <&vcc_sys>;
+		vcc9-supply = <&dcdc_boost>;
+
+		pwrkey {
+			status = "okay";
+		};
+
+		pinctrl_rk8xx: pinctrl_rk8xx {
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			rk817_slppin_null: rk817_slppin_null {
+				pins = "gpio_slp";
+				function = "pin_fun0";
+			};
+
+			rk817_slppin_slp: rk817_slppin_slp {
+				pins = "gpio_slp";
+				function = "pin_fun1";
+			};
+
+			rk817_slppin_pwrdn: rk817_slppin_pwrdn {
+				pins = "gpio_slp";
+				function = "pin_fun2";
+			};
+
+			rk817_slppin_rst: rk817_slppin_rst {
+				pins = "gpio_slp";
+				function = "pin_fun3";
+			};
+		};
+
+		regulators {
+			vdd_logic: DCDC_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-init-microvolt = <900000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vdd_logic";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <900000>;
+				};
+			};
+
+			vdd_gpu: DCDC_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-init-microvolt = <900000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vdd_gpu";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_ddr: DCDC_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vcc_ddr";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vcc_3v3: DCDC_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vcc_3v3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vcca1v8_pmu: LDO_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcca1v8_pmu";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vdda_0v9: LDO_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdda_0v9";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdda0v9_pmu: LDO_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdda0v9_pmu";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <900000>;
+				};
+			};
+
+			vccio_acodec: LDO_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vccio_acodec";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vccio_sd: LDO_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vccio_sd";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc3v3_pmu: LDO_REG6 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc3v3_pmu";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3000000>;
+				};
+			};
+
+			vcc_1v8: LDO_REG7 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc_1v8";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc1v8_dvp: LDO_REG8 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc1v8_dvp";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc2v8_dvp: LDO_REG9 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				regulator-name = "vcc2v8_dvp";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			dcdc_boost: BOOST {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				regulator-name = "boost";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			otg_switch: OTG_SWITCH {
+				regulator-name = "otg_switch";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+		};
+
+		rk817_codec: codec {
+			#sound-dai-cells = <0>;
+			compatible = "rockchip,rk817-codec";
+			clocks = <&cru I2S1_MCLKOUT>;
+			clock-names = "mclk";
+			assigned-clocks = <&cru I2S1_MCLKOUT>, <&cru I2S1_MCLK_TX_IOE>;
+			assigned-clock-rates = <12288000>;
+			assigned-clock-parents = <&cru I2S1_MCLKOUT_TX>, <&cru I2S1_MCLKOUT_TX>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2s1m0_mclk>;
+			hp-volume = <20>;
+			spk-volume = <3>;
+			out-l2spk-r2hp;
+			//spk-ctl-gpios = <&gpio0 RK_PA6 GPIO_ACTIVE_HIGH>;
+			status = "disabled";
+		};
+	};
+};
+
+&iep {
+	status = "okay";
+};
+
+&iep_mmu {
+	status = "okay";
+};
+
+&jpegd {
+	status = "okay";
+};
+
+&jpegd_mmu {
+	status = "okay";
+};
+
+&mpp_srv {
+	status = "okay";
+};
+
+&rk_rga {
+	status = "okay";
+};
+
+&rkvdec {
+	status = "okay";
+};
+
+&rkvdec_mmu {
+	status = "okay";
+};
+
+&rkvenc {
+	venc-supply = <&vdd_logic>;
+	status = "okay";
+};
+
+&rkvenc_mmu {
+	status = "okay";
+};
+
+&rknpu {
+	rknpu-supply = <&vdd_gpu>;
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vcc_1v8>;
+};
+
+&sdhci {
+	bus-width = <8>;
+	supports-emmc;
+	non-removable;
+	max-frequency = <200000000>;
+	status = "okay";
+};
+
+&gmac1 {
+	phy-mode = "rgmii";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio3 RK_PC0 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	/* Reset time is 20ms, 100ms for rtl8211f */
+	snps,reset-delays-us = <0 20000 100000>;
+
+	assigned-clocks = <&cru SCLK_GMAC1_RX_TX>, <&cru SCLK_GMAC1>;
+	assigned-clock-parents = <&cru SCLK_GMAC1_RGMII_SPEED>;
+	assigned-clock-rates = <0>, <125000000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac1m1_miim
+		     &gmac1m1_tx_bus2
+		     &gmac1m1_rx_bus2
+		     &gmac1m1_rgmii_clk
+		     &gmac1m1_rgmii_bus>;
+
+	tx_delay = <0x47>;
+	rx_delay = <0x27>;
+
+	phy-handle = <&rgmii_phy1>;
+	status = "disabled";
+};
+
+&mdio1 {
+	rgmii_phy1: phy@0 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x0>;
+		status = "disabled";
+	};
+};
+
+&sfc {
+	status = "okay";
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&usb2phy0 {
+	status = "okay";
+};
+
+&u2phy0_host {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	status = "okay";
+};
+
+&u2phy1_host {
+	status = "okay";
+};
+
+&u2phy1_otg {
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb2phy1 {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&combphy1_usq {
+	status = "okay";
+};
+
+&usbdrd_dwc3 {
+	status = "okay";
+};
+
+&usbdrd30 {
+	status = "okay";
+};
+
+&usbhost_dwc3 {
+	status = "okay";
+};
+
+&usbhost30 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	status = "okay";
+};
+
+&usbdrd_dwc3 {
+	status = "okay";
+};
+
+&vdpu {
+	status = "okay";
+};
+
+&vdpu_mmu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
+&vepu_mmu {
+	status = "okay";
+};
+
+&vop {
+	status = "okay";
+	assigned-clocks = <&cru DCLK_VOP0>, <&cru DCLK_VOP1>;
+	assigned-clock-parents = <&pmucru PLL_HPLL>, <&cru PLL_VPLL>;
+};
+
+&vop_mmu {
+	status = "okay";
+};
+
+&i2c3 {
+	status = "okay";
+	pinctrl-0 = <&i2c3m1_xfer>;
+
+	usbc0: fusb302@22 {
+		compatible = "fcs,fusb302";
+		reg = <0x22>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <RK_PC7 IRQ_TYPE_LEVEL_LOW>;
+		sel-gpios= <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usbc0_int>;
+	};
+ };
+
+&reserved_memory {
+	ramoops: ramoops@110000 {
+		compatible = "ramoops";
+		reg = <0x0 0x110000 0x0 0xf0000>;
+		record-size = <0x20000>;
+		console-size = <0x80000>;
+		ftrace-size = <0x00000>;
+		pmsg-size = <0x50000>;
+	};
+};
+
+&rng {
+	status = "okay";
+};
+
+&rockchip_suspend {
+	status = "okay";
+};
+
+&gpio0 {
+	gpio-line-names =
+		/* GPIO0_A0-A3 */
+		"", "", "", "",
+		/* GPIO0_A4-A7 */
+		"", "", "", "",
+
+		/* GPIO0_B0-B3 */
+		"", "", "", "",
+		/* GPIO0_B4-B7 */
+		"", "", "", "",
+
+		/* GPIO0_C0-C3 */
+		"", "", "", "",
+		/* GPIO0_C4-C7 */
+		"", "", "", "",
+
+		/* GPIO0_D0-D3 */
+		"PIN_10", "PIN_8", "", "",
+		/* GPIO0_D4-D7 */
+		"", "", "", "";
+};
+
+&gpio1 {
+	gpio-line-names =
+		/* GPIO1_A0-A3 */
+		"PIN_3", "PIN_5", "", "",
+		/* GPIO1_A4-A7 */
+		"PIN_37", "", "", "",
+
+		/* GPIO1_B0-B3 */
+		"", "", "", "",
+		/* GPIO1_B4-B7 */
+		"", "", "", "",
+
+		/* GPIO1_C0-C3 */
+		"", "", "", "",
+		/* GPIO1_C4-C7 */
+		"", "", "", "",
+
+		/* GPIO1_D0-D3 */
+		"", "", "", "",
+		/* GPIO1_D4-D7 */
+		"", "", "", "";
+};
+
+&gpio2 {
+	gpio-line-names =
+		/* GPIO2_A0-A3 */
+		"", "", "", "",
+		/* GPIO2_A4-A7 */
+		"", "", "", "",
+
+		/* GPIO2_B0-B3 */
+		"", "", "", "",
+		/* GPIO2_B4-B7 */
+		"", "", "", "",
+
+		/* GPIO2_C0-C3 */
+		"", "", "", "",
+		/* GPIO2_C4-C7 */
+		"", "", "", "",
+
+		/* GPIO2_D0-D3 */
+		"", "", "", "",
+		/* GPIO2_D4-D7 */
+		"", "", "", "";
+};
+
+&gpio3 {
+	gpio-line-names =
+		/* GPIO3_A0-A3 */
+		"", "PIN_11", "PIN_13", "PIN_12",
+		/* GPIO3_A4-A7 */
+		"PIN_35", "PIN_40", "PIN_38", "PIN_36",
+
+		/* GPIO3_B0-B3 */
+		"PIN_15", "PIN_16", "PIN_18", "PIN_29",
+		/* GPIO3_B4-B7 */
+		"PIN_31", "", "", "",
+
+		/* GPIO3_C0-C3 */
+		"", "PIN_22", "PIN_32", "PIN_33",
+		/* GPIO3_C4-C7 */
+		"PIN_7", "", "", "",
+
+		/* GPIO3_D0-D3 */
+		"", "", "", "",
+		/* GPIO3_D4-D7 */
+		"", "", "", "";
+};
+
+&gpio4 {
+	gpio-line-names =
+		/* GPIO4_A0-A3 */
+		"", "", "", "",
+		/* GPIO4_A4-A7 */
+		"", "", "", "",
+
+		/* GPIO4_B0-B3 */
+		"", "", "PIN_27", "PIN_28",
+		/* GPIO4_B4-B7 */
+		"", "", "", "",
+
+		/* GPIO4_C0-C3 */
+		"", "", "PIN_23", "PIN_19",
+		/* GPIO4_C4-C7 */
+		"", "PIN_21", "PIN_24", "",
+
+		/* GPIO4_D0-D3 */
+		"", "PIN_26", "", "",
+		/* GPIO4_D4-D7 */
+		"", "", "", "";
+};
+
+&i2s0_8ch {
+	status = "okay";
+};
+
+&display_subsystem {
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+	preset_max_hdisplay = <1920>;
+	preset_max_vdisplay = <1080>;
+};
+
+&hdmi_in_vp0 {
+	status = "okay";
+};
+
+&hdmi_in_vp1 {
+	status = "disabled";
+};
+
+&hdmi_sound {
+	status = "okay";
+};
+
+&route_hdmi {
+	status = "okay";
+	connect = <&vp0_out_hdmi>;
+};
+
+&sdmmc0 {
+	max-frequency = <150000000>;
+	supports-sd;
+	no-sdio;
+	no-mmc;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	num-slots = <1>;
+	sd-uhs-sdr104;
+	vmmc-supply = <&vcc3v3_sys>;
+	vqmmc-supply = <&vccio_sd>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc0_bus4 &sdmmc0_clk &sdmmc0_cmd &sdmmc0_det>;
+	status = "okay";
+};
+
+&rockchip_suspend {
+	status = "okay";
+	rockchip,sleep-debug-en = <1>;
+	rockchip,sleep-mode-config = <
+		(0
+		| RKPM_SLP_CENTER_OFF
+		| RKPM_SLP_HW_PLLS_OFF
+		| RKPM_SLP_PMUALIVE_32K
+		| RKPM_SLP_32K_PVTM
+		)
+	>;
+	rockchip,wakeup-config = <
+		(0
+		| RKPM_GPIO_WKUP_EN
+		| RKPM_USB_WKUP_EN
+		)
+	>;
+};
+
+&pinctrl {
+	pmic {
+		pmic_int: pmic_int {
+			rockchip,pins =
+				<0 RK_PA3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		soc_slppin_gpio: soc_slppin_gpio {
+			rockchip,pins =
+				<0 RK_PA2 RK_FUNC_GPIO &pcfg_output_low_pull_down>;
+		};
+
+		soc_slppin_slp: soc_slppin_slp {
+			rockchip,pins =
+				<0 RK_PA2 RK_FUNC_GPIO  &pcfg_pull_up>;
+		};
+
+		soc_slppin_rst: soc_slppin_rst {
+			rockchip,pins =
+				<0 RK_PA2 RK_FUNC_GPIO  &pcfg_pull_none>;
+		};
+	};
+
+	leds {
+		board_led: board-led {
+			rockchip,pins = <0 RK_PA0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	usb-typec {
+		usbc0_int: usbc0-int {
+			rockchip,pins = <3 RK_PC7 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3566.dtsi b/arch/arm64/boot/dts/rockchip/rk3566.dtsi
index 6c4b17d27bdc..eeb394589a98 100644
--- a/arch/arm64/boot/dts/rockchip/rk3566.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3566.dtsi
@@ -1,17 +1,32 @@
 // SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2020 Rockchip Electronics Co., Ltd.
+ */
 
-#include "rk356x.dtsi"
+#include "rk3568.dtsi"
 
 / {
-	compatible = "rockchip,rk3566";
+	aliases {
+		/delete-property/ ethernet0;
+	};
+};
+
+&cpu0_opp_table {
+	/delete-node/ opp-1992000000;
+};
+
+&lpddr4_params {
+	/* freq info, freq_0 is final frequency, unit: MHz */
+	freq_0 = <1056>;
 };
 
-&pipegrf {
-	compatible = "rockchip,rk3566-pipe-grf", "syscon";
+&lpddr4x_params {
+	/* freq info, freq_0 is final frequency, unit: MHz */
+	freq_0 = <1056>;
 };
 
 &power {
-	power-domain@RK3568_PD_PIPE {
+	pd_pipe@RK3568_PD_PIPE {
 		reg = <RK3568_PD_PIPE>;
 		clocks = <&cru PCLK_PIPE>;
 		pm_qos = <&qos_pcie2x1>,
@@ -19,17 +34,32 @@ power-domain@RK3568_PD_PIPE {
 			 <&qos_sata2>,
 			 <&qos_usb3_0>,
 			 <&qos_usb3_1>;
-		#power-domain-cells = <0>;
 	};
 };
 
-&usb_host0_xhci {
-	phys = <&usb2phy0_otg>;
+&rkisp {
+	rockchip,iq-feature = /bits/ 64 <0x1BFBF7FE67FF>;
+};
+
+&usbdrd_dwc3 {
+	phys = <&u2phy0_otg>;
 	phy-names = "usb2-phy";
 	extcon = <&usb2phy0>;
 	maximum-speed = "high-speed";
+	snps,dis_u2_susphy_quirk;
+	snps,usb2-lpm-disable;
 };
 
-&vop {
-	compatible = "rockchip,rk3566-vop";
-};
+/delete-node/ &combphy0_us;
+/delete-node/ &gmac0_clkin;
+/delete-node/ &gmac0_xpcsclk;
+/delete-node/ &gmac0;
+/delete-node/ &gmac_uio0;
+/delete-node/ &pcie30_phy_grf;
+/delete-node/ &pcie30phy;
+/delete-node/ &pcie3x1;
+/delete-node/ &pcie3x2;
+/delete-node/ &qos_pcie3x1;
+/delete-node/ &qos_pcie3x2;
+/delete-node/ &qos_sata0;
+/delete-node/ &sata0;
diff --git a/arch/arm64/boot/dts/rockchip/rk3568-dram-default-timing.dtsi b/arch/arm64/boot/dts/rockchip/rk3568-dram-default-timing.dtsi
new file mode 100644
index 000000000000..99247fb7921a
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3568-dram-default-timing.dtsi
@@ -0,0 +1,400 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2020 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#include <dt-bindings/clock/rockchip-ddr.h>
+#include <dt-bindings/memory/rk3568-dram.h>
+
+/ {
+	ddr3_params: ddr3-params {
+		/* version information */
+		version = <0x100>;
+		expanded_version = <IGNORE_THIS>;
+		reserved = <IGNORE_THIS>;
+		/* freq info, freq_0 is final frequency, unit: MHz */
+		freq_0 = <1056>;
+		freq_1 = <324>;
+		freq_2 = <528>;
+		freq_3 = <780>;
+		freq_4 = <IGNORE_THIS>;
+		freq_5 = <IGNORE_THIS>;
+		/* power save setting */
+		pd_idle = <13>;
+		sr_idle = <93>;
+		sr_mc_gate_idle = <0>;
+		srpd_lite_idle = <0>;
+		standby_idle = <0>;
+		pd_dis_freq = <1066>;
+		sr_dis_freq = <800>;
+		dram_dll_dis_freq = <300>;
+		phy_dll_dis_freq = <IGNORE_THIS>;
+		/* drv when odt on */
+		phy_dq_drv_odten = <33>;
+		phy_ca_drv_odten = <33>;
+		phy_clk_drv_odten = <33>;
+		dram_dq_drv_odten = <34>;
+		/* drv when odt off */
+		phy_dq_drv_odtoff = <33>;
+		phy_ca_drv_odtoff = <33>;
+		phy_clk_drv_odtoff = <33>;
+		dram_dq_drv_odtoff = <34>;
+		/* odt info */
+		dram_odt = <120>;
+		phy_odt = <167>;
+		phy_odt_puup_en = <1>;
+		phy_odt_pudn_en = <1>;
+		/* odt enable freq */
+		dram_dq_odt_en_freq = <333>;
+		phy_odt_en_freq = <333>;
+		/* slew rate when odt enable */
+		phy_dq_sr_odten = <0xf>;
+		phy_ca_sr_odten = <0x3>;
+		phy_clk_sr_odten = <0x0>;
+		/* slew rate when odt disable */
+		phy_dq_sr_odtoff = <0xf>;
+		phy_ca_sr_odtoff = <0x3>;
+		phy_clk_sr_odtoff = <0x0>;
+		/* ssmod setting*/
+		ssmod_downspread = <0>;
+		ssmod_div = <0>;
+		ssmod_spread = <0>;
+		/* 2T mode */
+		mode_2t = <IGNORE_THIS>;
+		/* speed bin */
+		speed_bin = <DDR3_DEFAULT>;
+		/* dram extended temperature support */
+		dram_ext_temp = <0>;
+		/* byte map */
+		byte_map = <((0x3 << 6) | (0x2 << 4) | (0x1 << 2) | (0x0 << 0))>;
+		/* dq map */
+		dq_map_cs0_dq_l = <0>;
+		dq_map_cs0_dq_h = <0>;
+		dq_map_cs1_dq_l = <0>;
+		dq_map_cs1_dq_h = <0>;
+	};
+
+	ddr4_params: ddr4-params {
+		/* version information */
+		version = <0x100>;
+		expanded_version = <IGNORE_THIS>;
+		reserved = <IGNORE_THIS>;
+		/* freq info, freq_0 is final frequency, unit: MHz */
+		freq_0 = <1056>;
+		freq_1 = <324>;
+		freq_2 = <528>;
+		freq_3 = <780>;
+		freq_4 = <IGNORE_THIS>;
+		freq_5 = <IGNORE_THIS>;
+		/* power save setting */
+		pd_idle = <13>;
+		sr_idle = <93>;
+		sr_mc_gate_idle = <0>;
+		srpd_lite_idle = <0>;
+		standby_idle = <0>;
+		pd_dis_freq = <1066>;
+		sr_dis_freq = <800>;
+		dram_dll_dis_freq = <625>;
+		phy_dll_dis_freq = <IGNORE_THIS>;
+		/* drv when odt on */
+		phy_dq_drv_odten = <37>;
+		phy_ca_drv_odten = <37>;
+		phy_clk_drv_odten = <37>;
+		dram_dq_drv_odten = <34>;
+		/* drv when odt off */
+		phy_dq_drv_odtoff = <37>;
+		phy_ca_drv_odtoff = <37>;
+		phy_clk_drv_odtoff = <37>;
+		dram_dq_drv_odtoff = <34>;
+		/* odt info */
+		dram_odt = <120>;
+		phy_odt = <139>;
+		phy_odt_puup_en = <1>;
+		phy_odt_pudn_en = <1>;
+		/* odt enable freq */
+		dram_dq_odt_en_freq = <500>;
+		phy_odt_en_freq = <500>;
+		/* slew rate when odt enable */
+		phy_dq_sr_odten = <0xe>;
+		phy_ca_sr_odten = <0x1>;
+		phy_clk_sr_odten = <0x1>;
+		/* slew rate when odt disable */
+		phy_dq_sr_odtoff = <0xe>;
+		phy_ca_sr_odtoff = <0x1>;
+		phy_clk_sr_odtoff = <0x1>;
+		/* ssmod setting*/
+		ssmod_downspread = <0>;
+		ssmod_div = <0>;
+		ssmod_spread = <0>;
+		/* 2T mode */
+		mode_2t = <IGNORE_THIS>;
+		/* speed bin */
+		speed_bin = <DDR4_DEFAULT>;
+		/* dram extended temperature support */
+		dram_ext_temp = <0>;
+		/* byte map */
+		byte_map = <((0x3 << 6) | (0x2 << 4) | (0x1 << 2) | (0x0 << 0))>;
+		/* dq map */
+		dq_map_cs0_dq_l = <(((0 << 0 | 2 << 2 | 0 << 4 | 2 << 6) << 0) | \
+				    ((3 << 0 | 1 << 2 | 3 << 4 | 1 << 6) << 8) | \
+				    ((3 << 0 | 1 << 2 | 3 << 4 | 1 << 6) << 16) | \
+				    ((2 << 0 | 0 << 2 | 2 << 4 | 0 << 6) << 24))>;
+		dq_map_cs0_dq_h = <(((3 << 0 | 1 << 2 | 3 << 4 | 1 << 6) << 0) | \
+				    ((0 << 0 | 2 << 2 | 0 << 4 | 2 << 6) << 8) | \
+				    ((0 << 0 | 2 << 2 | 0 << 4 | 2 << 6) << 16) | \
+				    ((3 << 0 | 1 << 2 | 1 << 4 | 3 << 6) << 24))>;
+		dq_map_cs1_dq_l = <(((0 << 0 | 2 << 2 | 0 << 4 | 2 << 6) << 0) | \
+				    ((3 << 0 | 1 << 2 | 3 << 4 | 1 << 6) << 8) | \
+				    ((3 << 0 | 1 << 2 | 3 << 4 | 1 << 6) << 16) | \
+				    ((2 << 0 | 0 << 2 | 2 << 4 | 0 << 6) << 24))>;
+		dq_map_cs1_dq_h = <(((3 << 0 | 1 << 2 | 3 << 4 | 1 << 6) << 0) | \
+				    ((0 << 0 | 2 << 2 | 0 << 4 | 2 << 6) << 8) | \
+				    ((0 << 0 | 2 << 2 | 0 << 4 | 2 << 6) << 16) | \
+				    ((3 << 0 | 1 << 2 | 1 << 4 | 3 << 6) << 24))>;
+	};
+
+	lpddr3_params: lpddr3-params {
+		/* version information */
+		version = <0x100>;
+		expanded_version = <IGNORE_THIS>;
+		reserved = <IGNORE_THIS>;
+		/* freq info, freq_0 is final frequency, unit: MHz */
+		freq_0 = <1056>;
+		freq_1 = <324>;
+		freq_2 = <528>;
+		freq_3 = <780>;
+		freq_4 = <IGNORE_THIS>;
+		freq_5 = <IGNORE_THIS>;
+		/* power save setting */
+		pd_idle = <13>;
+		sr_idle = <93>;
+		sr_mc_gate_idle = <0>;
+		srpd_lite_idle = <0>;
+		standby_idle = <0>;
+		pd_dis_freq = <1066>;
+		sr_dis_freq = <800>;
+		dram_dll_dis_freq = <IGNORE_THIS>;
+		phy_dll_dis_freq = <IGNORE_THIS>;
+		/* drv when odt on */
+		phy_dq_drv_odten = <37>;
+		phy_ca_drv_odten = <37>;
+		phy_clk_drv_odten = <39>;
+		dram_dq_drv_odten = <34>;
+		/* drv when odt off */
+		phy_dq_drv_odtoff = <37>;
+		phy_ca_drv_odtoff = <37>;
+		phy_clk_drv_odtoff = <39>;
+		dram_dq_drv_odtoff = <34>;
+		/* odt info */
+		dram_odt = <120>;
+		phy_odt = <148>;
+		phy_odt_puup_en = <1>;
+		phy_odt_pudn_en = <1>;
+		/* odt enable freq */
+		dram_dq_odt_en_freq = <333>;
+		phy_odt_en_freq = <333>;
+		/* slew rate when odt enable */
+		phy_dq_sr_odten = <0xf>;
+		phy_ca_sr_odten = <0x1>;
+		phy_clk_sr_odten = <0xf>;
+		/* slew rate when odt disable */
+		phy_dq_sr_odtoff = <0xf>;
+		phy_ca_sr_odtoff = <0x1>;
+		phy_clk_sr_odtoff = <0xf>;
+		/* ssmod setting*/
+		ssmod_downspread = <0>;
+		ssmod_div = <0>;
+		ssmod_spread = <0>;
+		/* 2T mode */
+		mode_2t = <IGNORE_THIS>;
+		/* speed bin */
+		speed_bin = <IGNORE_THIS>;
+		/* dram extended temperature support */
+		dram_ext_temp = <0>;
+		/* byte map */
+		byte_map = <((0x2 << 6) | (0x0 << 4) | (0x3 << 2) | (0x1 << 0))>;
+		/* dq map */
+		dq_map_cs0_dq_l = <0>;
+		dq_map_cs0_dq_h = <0>;
+		dq_map_cs1_dq_l = <0>;
+		dq_map_cs1_dq_h = <0>;
+	};
+
+	lpddr4_params: lpddr4-params {
+		/* version information */
+		version = <0x100>;
+		expanded_version = <IGNORE_THIS>;
+		reserved = <IGNORE_THIS>;
+		/* freq info, freq_0 is final frequency, unit: MHz */
+		freq_0 = <1560>;
+		freq_1 = <324>;
+		freq_2 = <528>;
+		freq_3 = <780>;
+		freq_4 = <IGNORE_THIS>;
+		freq_5 = <IGNORE_THIS>;
+		/* power save setting */
+		pd_idle = <13>;
+		sr_idle = <93>;
+		sr_mc_gate_idle = <0>;
+		srpd_lite_idle = <0>;
+		standby_idle = <0>;
+		pd_dis_freq = <1066>;
+		sr_dis_freq = <800>;
+		dram_dll_dis_freq = <IGNORE_THIS>;
+		phy_dll_dis_freq = <IGNORE_THIS>;
+		/* drv when odt on */
+		phy_dq_drv_odten = <30>;
+		phy_ca_drv_odten = <38>;
+		phy_clk_drv_odten = <38>;
+		dram_dq_drv_odten = <40>;
+		/* drv when odt off */
+		phy_dq_drv_odtoff = <30>;
+		phy_ca_drv_odtoff = <38>;
+		phy_clk_drv_odtoff = <38>;
+		dram_dq_drv_odtoff = <40>;
+		/* odt info */
+		dram_odt = <80>;
+		phy_odt = <60>;
+		phy_odt_puup_en = <IGNORE_THIS>;
+		phy_odt_pudn_en = <IGNORE_THIS>;
+		/* odt enable freq */
+		dram_dq_odt_en_freq = <800>;
+		phy_odt_en_freq = <800>;
+		/* slew rate when odt enable */
+		phy_dq_sr_odten = <0x0>;
+		phy_ca_sr_odten = <0xf>;
+		phy_clk_sr_odten = <0xf>;
+		/* slew rate when odt disable */
+		phy_dq_sr_odtoff = <0x0>;
+		phy_ca_sr_odtoff = <0xf>;
+		phy_clk_sr_odtoff = <0xf>;
+		/* ssmod setting*/
+		ssmod_downspread = <0>;
+		ssmod_div = <0>;
+		ssmod_spread = <0>;
+		/* 2T mode */
+		mode_2t = <IGNORE_THIS>;
+		/* speed bin */
+		speed_bin = <IGNORE_THIS>;
+		/* dram extended temperature support */
+		dram_ext_temp = <0>;
+		/* byte map */
+		byte_map = <((0x3 << 6) | (0x2 << 4) | (0x1 << 2) | (0x0 << 0))>;
+		/* dq map */
+		dq_map_cs0_dq_l = <0>;
+		dq_map_cs0_dq_h = <0>;
+		dq_map_cs1_dq_l = <0>;
+		dq_map_cs1_dq_h = <0>;
+		/* lp4 odt info */
+		lp4_ca_odt = <120>;
+		lp4_drv_pu_cal_odten = <LP4_VDDQ_3>;
+		lp4_drv_pu_cal_odtoff = <LP4_VDDQ_3>;
+		phy_lp4_drv_pulldown_en_odten = <0>;
+		phy_lp4_drv_pulldown_en_odtoff = <0>;
+		/* lp4 odt enable freq */
+		lp4_ca_odt_en_freq = <800>;
+		/* lp4 cs drv info and ca odt info */
+		phy_lp4_cs_drv_odten = <0>;
+		phy_lp4_cs_drv_odtoff = <0>;
+		lp4_odte_ck_en = <1>;
+		lp4_odte_cs_en = <1>;
+		lp4_odtd_ca_en = <0>;
+		/* lp4 vref info when odt enable */
+		phy_lp4_dq_vref_odten = <166>;
+		lp4_dq_vref_odten = <300>;
+		lp4_ca_vref_odten = <380>;
+		/* lp4 vref info when odt disable */
+		phy_lp4_dq_vref_odtoff = <420>;
+		lp4_dq_vref_odtoff = <420>;
+		lp4_ca_vref_odtoff = <420>;
+	};
+
+	lpddr4x_params: lpddr4x-params {
+		/* version information */
+		version = <0x100>;
+		expanded_version = <IGNORE_THIS>;
+		reserved = <IGNORE_THIS>;
+		/* freq info, freq_0 is final frequency, unit: MHz */
+		freq_0 = <1560>;
+		freq_1 = <324>;
+		freq_2 = <528>;
+		freq_3 = <780>;
+		freq_4 = <IGNORE_THIS>;
+		freq_5 = <IGNORE_THIS>;
+		/* power save setting */
+		pd_idle = <13>;
+		sr_idle = <93>;
+		sr_mc_gate_idle = <0>;
+		srpd_lite_idle = <0>;
+		standby_idle = <0>;
+		pd_dis_freq = <1066>;
+		sr_dis_freq = <800>;
+		dram_dll_dis_freq = <IGNORE_THIS>;
+		phy_dll_dis_freq = <IGNORE_THIS>;
+		/* drv when odt on */
+		phy_dq_drv_odten = <29>;
+		phy_ca_drv_odten = <36>;
+		phy_clk_drv_odten = <36>;
+		dram_dq_drv_odten = <40>;
+		/* drv when odt off */
+		phy_dq_drv_odtoff = <29>;
+		phy_ca_drv_odtoff = <36>;
+		phy_clk_drv_odtoff = <36>;
+		dram_dq_drv_odtoff = <40>;
+		/* odt info */
+		dram_odt = <80>;
+		phy_odt = <60>;
+		phy_odt_puup_en = <IGNORE_THIS>;
+		phy_odt_pudn_en = <IGNORE_THIS>;
+		/* odt enable freq */
+		dram_dq_odt_en_freq = <800>;
+		phy_odt_en_freq = <800>;
+		/* slew rate when odt enable */
+		phy_dq_sr_odten = <0x0>;
+		phy_ca_sr_odten = <0x0>;
+		phy_clk_sr_odten = <0x0>;
+		/* slew rate when odt disable */
+		phy_dq_sr_odtoff = <0x0>;
+		phy_ca_sr_odtoff = <0x0>;
+		phy_clk_sr_odtoff = <0x0>;
+		/* ssmod setting*/
+		ssmod_downspread = <0>;
+		ssmod_div = <0>;
+		ssmod_spread = <0>;
+		/* 2T mode */
+		mode_2t = <IGNORE_THIS>;
+		/* speed bin */
+		speed_bin = <IGNORE_THIS>;
+		/* dram extended temperature support */
+		dram_ext_temp = <0>;
+		/* byte map */
+		byte_map = <((0x3 << 6) | (0x2 << 4) | (0x1 << 2) | (0x0 << 0))>;
+		/* dq map */
+		dq_map_cs0_dq_l = <0>;
+		dq_map_cs0_dq_h = <0>;
+		dq_map_cs1_dq_l = <0>;
+		dq_map_cs1_dq_h = <0>;
+		/* lp4 odt info */
+		lp4_ca_odt = <120>;
+		lp4_drv_pu_cal_odten = <LP4X_VDDQ_0_6>;
+		lp4_drv_pu_cal_odtoff = <LP4X_VDDQ_0_6>;
+		phy_lp4_drv_pulldown_en_odten = <0>;
+		phy_lp4_drv_pulldown_en_odtoff = <0>;
+		/* odt enable freq */
+		lp4_ca_odt_en_freq = <800>;
+		/* lp4 cs drv info and ca odt info */
+		phy_lp4_cs_drv_odten = <0>;
+		phy_lp4_cs_drv_odtoff = <0>;
+		lp4_odte_ck_en = <0>;
+		lp4_odte_cs_en = <0>;
+		lp4_odtd_ca_en = <0>;
+		/* lp4 vref info when odt enable */
+		phy_lp4_dq_vref_odten = <166>;
+		lp4_dq_vref_odten = <228>;
+		lp4_ca_vref_odten = <343>;
+		/* lp4 vref info when odt disable */
+		phy_lp4_dq_vref_odtoff = <420>;
+		lp4_dq_vref_odtoff = <420>;
+		lp4_ca_vref_odtoff = <343>;
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3568-pinctrl.dtsi b/arch/arm64/boot/dts/rockchip/rk3568-pinctrl.dtsi
index 0a979bfb63d9..30d8cedfbdc7 100644
--- a/arch/arm64/boot/dts/rockchip/rk3568-pinctrl.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3568-pinctrl.dtsi
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: (GPL-2.0+ OR MIT)
 /*
- * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ * Copyright (c) 2020 Rockchip Electronics Co., Ltd.
  */
 
 #include <dt-bindings/pinctrl/rockchip.h>
@@ -3109,106 +3109,11 @@ gmac1m1_rgmii_clk_level2: gmac1m1-rgmii-clk-level2 {
 		};
 	};
 
-	tsadc {
-		/omit-if-no-ref/
-		tsadc_pin: tsadc-pin {
-			rockchip,pins =
-				/* tsadc_pin */
-				<0 RK_PA1 0 &pcfg_pull_none>;
-		};
-	};
-
-	lcdc {
-		/omit-if-no-ref/
-		lcdc_clock: lcdc-clock {
-			rockchip,pins =
-				/* lcdc_clk */
-				<3 RK_PA0 1 &pcfg_pull_none>,
-				/* lcdc_den */
-				<3 RK_PC3 1 &pcfg_pull_none>,
-				/* lcdc_hsync */
-				<3 RK_PC1 1 &pcfg_pull_none>,
-				/* lcdc_vsync */
-				<3 RK_PC2 1 &pcfg_pull_none>;
-		};
-
-		/omit-if-no-ref/
-		lcdc_data16: lcdc-data16 {
-			rockchip,pins =
-				/* lcdc_d3 */
-				<2 RK_PD3 1 &pcfg_pull_none>,
-				/* lcdc_d4 */
-				<2 RK_PD4 1 &pcfg_pull_none>,
-				/* lcdc_d5 */
-				<2 RK_PD5 1 &pcfg_pull_none>,
-				/* lcdc_d6 */
-				<2 RK_PD6 1 &pcfg_pull_none>,
-				/* lcdc_d7 */
-				<2 RK_PD7 1 &pcfg_pull_none>,
-				/* lcdc_d10 */
-				<3 RK_PA3 1 &pcfg_pull_none>,
-				/* lcdc_d11 */
-				<3 RK_PA4 1 &pcfg_pull_none>,
-				/* lcdc_d12 */
-				<3 RK_PA5 1 &pcfg_pull_none>,
-				/* lcdc_d13 */
-				<3 RK_PA6 1 &pcfg_pull_none>,
-				/* lcdc_d14 */
-				<3 RK_PA7 1 &pcfg_pull_none>,
-				/* lcdc_d15 */
-				<3 RK_PB0 1 &pcfg_pull_none>,
-				/* lcdc_d19 */
-				<3 RK_PB4 1 &pcfg_pull_none>,
-				/* lcdc_d20 */
-				<3 RK_PB5 1 &pcfg_pull_none>,
-				/* lcdc_d21 */
-				<3 RK_PB6 1 &pcfg_pull_none>,
-				/* lcdc_d22 */
-				<3 RK_PB7 1 &pcfg_pull_none>,
-				/* lcdc_d23 */
-				<3 RK_PC0 1 &pcfg_pull_none>;
-		};
-
+	gpio-func {
 		/omit-if-no-ref/
-		lcdc_data18: lcdc-data18 {
+		tsadc_gpio_func: tsadc-gpio-func {
 			rockchip,pins =
-				/* lcdc_d2 */
-				<2 RK_PD2 1 &pcfg_pull_none>,
-				/* lcdc_d3 */
-				<2 RK_PD3 1 &pcfg_pull_none>,
-				/* lcdc_d4 */
-				<2 RK_PD4 1 &pcfg_pull_none>,
-				/* lcdc_d5 */
-				<2 RK_PD5 1 &pcfg_pull_none>,
-				/* lcdc_d6 */
-				<2 RK_PD6 1 &pcfg_pull_none>,
-				/* lcdc_d7 */
-				<2 RK_PD7 1 &pcfg_pull_none>,
-				/* lcdc_d10 */
-				<3 RK_PA3 1 &pcfg_pull_none>,
-				/* lcdc_d11 */
-				<3 RK_PA4 1 &pcfg_pull_none>,
-				/* lcdc_d12 */
-				<3 RK_PA5 1 &pcfg_pull_none>,
-				/* lcdc_d13 */
-				<3 RK_PA6 1 &pcfg_pull_none>,
-				/* lcdc_d14 */
-				<3 RK_PA7 1 &pcfg_pull_none>,
-				/* lcdc_d15 */
-				<3 RK_PB0 1 &pcfg_pull_none>,
-				/* lcdc_d18 */
-				<3 RK_PB3 1 &pcfg_pull_none>,
-				/* lcdc_d19 */
-				<3 RK_PB4 1 &pcfg_pull_none>,
-				/* lcdc_d20 */
-				<3 RK_PB5 1 &pcfg_pull_none>,
-				/* lcdc_d21 */
-				<3 RK_PB6 1 &pcfg_pull_none>,
-				/* lcdc_d22 */
-				<3 RK_PB7 1 &pcfg_pull_none>,
-				/* lcdc_d23 */
-				<3 RK_PC0 1 &pcfg_pull_none>;
+				<0 RK_PA1 RK_FUNC_GPIO &pcfg_pull_none>;
 		};
 	};
-
 };
diff --git a/arch/arm64/boot/dts/rockchip/rk3568.dtsi b/arch/arm64/boot/dts/rockchip/rk3568.dtsi
index f1be76a54ceb..d52358f29e84 100644
--- a/arch/arm64/boot/dts/rockchip/rk3568.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3568.dtsi
@@ -1,267 +1,3730 @@
 // SPDX-License-Identifier: (GPL-2.0+ OR MIT)
 /*
- * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ * Copyright (c) 2020 Rockchip Electronics Co., Ltd.
  */
 
-#include "rk356x.dtsi"
+#include <dt-bindings/clock/rk3568-cru.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/soc/rockchip,boot-mode.h>
+#include <dt-bindings/phy/phy.h>
+#include <dt-bindings/power/rk3568-power.h>
+#include <dt-bindings/soc/rockchip-system-status.h>
+#include <dt-bindings/suspend/rockchip-rk3568.h>
+#include <dt-bindings/thermal/thermal.h>
+#include "rk3568-dram-default-timing.dtsi"
 
 / {
 	compatible = "rockchip,rk3568";
 
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		csi2dphy0 = &csi2_dphy0;
+		csi2dphy1 = &csi2_dphy1;
+		csi2dphy2 = &csi2_dphy2;
+		dsi0 = &dsi0;
+		dsi1 = &dsi1;
+		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
+		gpio0 = &gpio0;
+		gpio1 = &gpio1;
+		gpio2 = &gpio2;
+		gpio3 = &gpio3;
+		gpio4 = &gpio4;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+		i2c4 = &i2c4;
+		i2c5 = &i2c5;
+		mmc0 = &sdhci;
+		mmc1 = &sdmmc0;
+		mmc2 = &sdmmc1;
+		mmc3 = &sdmmc2;
+		pwm0 = &pwm0;
+		pwm1 = &pwm1;
+		pwm2 = &pwm2;
+		pwm3 = &pwm3;
+		pwm4 = &pwm4;
+		pwm5 = &pwm5;
+		pwm6 = &pwm6;
+		pwm7 = &pwm7;
+		pwm8 = &pwm8;
+		pwm9 = &pwm9;
+		pwm10 = &pwm10;
+		pwm11 = &pwm11;
+		pwm12 = &pwm12;
+		pwm13 = &pwm13;
+		pwm14 = &pwm14;
+		pwm15 = &pwm15;
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
+		serial3 = &uart3;
+		serial4 = &uart4;
+		serial5 = &uart5;
+		serial6 = &uart6;
+		serial7 = &uart7;
+		serial8 = &uart8;
+		serial9 = &uart9;
+		spi0 = &spi0;
+		spi1 = &spi1;
+		spi2 = &spi2;
+		spi3 = &spi3;
+	};
+
+	cpus {
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55";
+			reg = <0x0 0x0>;
+			enable-method = "psci";
+			clocks = <&scmi_clk 0>;
+			operating-points-v2 = <&cpu0_opp_table>;
+			cpu-idle-states = <&CPU_SLEEP>;
+			#cooling-cells = <2>;
+			dynamic-power-coefficient = <187>;
+		};
+
+		cpu1: cpu@100 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55";
+			reg = <0x0 0x100>;
+			enable-method = "psci";
+			clocks = <&scmi_clk 0>;
+			operating-points-v2 = <&cpu0_opp_table>;
+			cpu-idle-states = <&CPU_SLEEP>;
+		};
+
+		cpu2: cpu@200 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55";
+			reg = <0x0 0x200>;
+			enable-method = "psci";
+			clocks = <&scmi_clk 0>;
+			operating-points-v2 = <&cpu0_opp_table>;
+			cpu-idle-states = <&CPU_SLEEP>;
+		};
+
+		cpu3: cpu@300 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55";
+			reg = <0x0 0x300>;
+			enable-method = "psci";
+			clocks = <&scmi_clk 0>;
+			operating-points-v2 = <&cpu0_opp_table>;
+			cpu-idle-states = <&CPU_SLEEP>;
+		};
+
+		idle-states {
+			entry-method = "psci";
+			CPU_SLEEP: cpu-sleep {
+				compatible = "arm,idle-state";
+				local-timer-stop;
+				arm,psci-suspend-param = <0x0010000>;
+				entry-latency-us = <100>;
+				exit-latency-us = <120>;
+				min-residency-us = <1000>;
+			};
+		};
+	};
+
+	cpu0_opp_table: cpu0-opp-table {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		mbist-vmin = <825000 900000 950000>;
+		nvmem-cells = <&cpu_leakage>, <&core_pvtm>, <&mbist_vmin>, <&cpu_opp_info>;
+		nvmem-cell-names = "leakage", "pvtm", "mbist-vmin", "opp-info";
+		rockchip,max-volt = <1200000>;
+		rockchip,pvtm-voltage-sel = <
+			0        84000   0
+			84001    87000   1
+			87001    91000   2
+			91001    100000  3
+		>;
+		rockchip,pvtm-freq = <408000>;
+		rockchip,pvtm-volt = <900000>;
+		rockchip,pvtm-ch = <0 5>;
+		rockchip,pvtm-sample-time = <1000>;
+		rockchip,pvtm-number = <10>;
+		rockchip,pvtm-error = <1000>;
+		rockchip,pvtm-ref-temp = <40>;
+		rockchip,pvtm-temp-prop = <26 26>;
+		rockchip,thermal-zone = "soc-thermal";
+		rockchip,temp-hysteresis = <5000>;
+		rockchip,low-temp = <0>;
+		rockchip,low-temp-adjust-volt = <
+			/* MHz    MHz    uV */
+			   0      1992   75000
+		>;
+
+		opp-408000000 {
+			opp-hz = /bits/ 64 <408000000>;
+			opp-microvolt = <850000 850000 1150000>;
+			opp-microvolt-L3 = <900000 900000 1150000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-600000000 {
+			opp-hz = /bits/ 64 <600000000>;
+			opp-microvolt = <850000 850000 1150000>;
+			opp-microvolt-L3 = <900000 900000 1150000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-816000000 {
+			opp-hz = /bits/ 64 <816000000>;
+			opp-microvolt = <850000 850000 1150000>;
+			opp-microvolt-L3 = <900000 900000 1150000>;
+			clock-latency-ns = <40000>;
+			opp-suspend;
+		};
+		opp-1104000000 {
+			opp-hz = /bits/ 64 <1104000000>;
+			opp-microvolt = <900000 900000 1150000>;
+			opp-microvolt-L0 = <900000 900000 1150000>;
+			opp-microvolt-L1 = <850000 850000 1150000>;
+			opp-microvolt-L2 = <850000 850000 1150000>;
+			opp-microvolt-L3 = <900000 900000 1150000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-1416000000 {
+			opp-hz = /bits/ 64 <1416000000>;
+			opp-microvolt = <1025000 1025000 1150000>;
+			opp-microvolt-L0 = <1025000 1025000 1150000>;
+			opp-microvolt-L1 = <975000 975000 1150000>;
+			opp-microvolt-L2 = <950000 950000 1150000>;
+			opp-microvolt-L3 = <1000000 1000000 1150000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-1608000000 {
+			opp-hz = /bits/ 64 <1608000000>;
+			opp-microvolt = <1100000 1100000 1150000>;
+			opp-microvolt-L0 = <1100000 1100000 1150000>;
+			opp-microvolt-L1 = <1050000 1050000 1150000>;
+			opp-microvolt-L2 = <1025000 1025000 1150000>;
+			opp-microvolt-L3 = <1000000 1000000 1150000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-1800000000 {
+			opp-hz = /bits/ 64 <1800000000>;
+			opp-microvolt = <1150000 1150000 1150000>;
+			opp-microvolt-L0 = <1150000 1150000 1150000>;
+			opp-microvolt-L1 = <1100000 1100000 1150000>;
+			opp-microvolt-L2 = <1075000 1075000 1150000>;
+			opp-microvolt-L3 = <1050000 1050000 1150000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-1992000000 {
+			opp-hz = /bits/ 64 <1992000000>;
+			opp-microvolt = <1150000 1150000 1150000>;
+			opp-microvolt-L0 = <1150000 1150000 1150000>;
+			opp-microvolt-L1 = <1150000 1150000 1150000>;
+			opp-microvolt-L2 = <1125000 1125000 1150000>;
+			opp-microvolt-L3 = <1100000 1100000 1150000>;
+			clock-latency-ns = <40000>;
+		};
+	};
+
+	arm-pmu {
+		compatible = "arm,cortex-a55-pmu", "arm,armv8-pmuv3";
+		interrupts = <GIC_SPI 228 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 229 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 230 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 231 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0>, <&cpu1>, <&cpu2>, <&cpu3>;
+	};
+
+	cpuinfo {
+		compatible = "rockchip,cpuinfo";
+		nvmem-cells = <&otp_id>, <&otp_cpu_version>, <&cpu_code>, <&performance>;
+		nvmem-cell-names = "id", "cpu-version", "cpu-code", "performance";
+	};
+
+	display_subsystem: display-subsystem {
+		compatible = "rockchip,display-subsystem";
+		memory-region = <&drm_logo>, <&drm_cubic_lut>;
+		memory-region-names = "drm-logo", "drm-cubic-lut";
+		ports = <&vop_out>;
+		devfreq = <&dmc>;
+
+		route {
+			route_dsi0: route-dsi0 {
+				status = "disabled";
+				logo,uboot = "logo.bmp";
+				logo,kernel = "logo_kernel.bmp";
+				logo,mode = "center";
+				charge_logo,mode = "center";
+				connect = <&vp0_out_dsi0>;
+			};
+			route_dsi1: route-dsi1 {
+				status = "disabled";
+				logo,uboot = "logo.bmp";
+				logo,kernel = "logo_kernel.bmp";
+				logo,mode = "center";
+				charge_logo,mode = "center";
+				connect = <&vp0_out_dsi1>;
+			};
+			route_edp: route-edp {
+				status = "disabled";
+				logo,uboot = "logo.bmp";
+				logo,kernel = "logo_kernel.bmp";
+				logo,mode = "center";
+				charge_logo,mode = "center";
+				connect = <&vp0_out_edp>;
+			};
+			route_hdmi: route-hdmi {
+				status = "disabled";
+				logo,uboot = "logo.bmp";
+				logo,kernel = "logo_kernel.bmp";
+				logo,mode = "center";
+				charge_logo,mode = "center";
+				connect = <&vp1_out_hdmi>;
+			};
+			route_lvds: route-lvds {
+				status = "disabled";
+				logo,uboot = "logo.bmp";
+				logo,kernel = "logo_kernel.bmp";
+				logo,mode = "center";
+				charge_logo,mode = "center";
+				connect = <&vp1_out_lvds>;
+			};
+			route_rgb: route-rgb {
+				status = "disabled";
+				logo,uboot = "logo.bmp";
+				logo,kernel = "logo_kernel.bmp";
+				logo,mode = "center";
+				charge_logo,mode = "center";
+				connect = <&vp2_out_rgb>;
+			};
+		};
+	};
+
+	firmware {
+		scmi: scmi {
+			compatible = "arm,scmi-smc";
+			shmem = <&scmi_shmem>;
+			arm,smc-id = <0x82000010>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			scmi_clk: protocol@14 {
+				reg = <0x14>;
+				#clock-cells = <1>;
+
+				rockchip,clk-init = <1104000000>;
+			};
+		};
+
+		sdei: sdei {
+			compatible = "arm,sdei-1.0";
+			method = "smc";
+		};
+	};
+
+	mpp_srv: mpp-srv {
+		compatible = "rockchip,mpp-service";
+		rockchip,taskqueue-count = <6>;
+		rockchip,resetgroup-count = <6>;
+		status = "disabled";
+	};
+
+	psci {
+		compatible = "arm,psci-1.0";
+		method = "smc";
+	};
+
+	reserved_memory: reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		drm_logo: drm-logo@00000000 {
+			compatible = "rockchip,drm-logo";
+			reg = <0x0 0x0 0x0 0x0>;
+		};
+
+		drm_cubic_lut: drm-cubic-lut@00000000 {
+			compatible = "rockchip,drm-cubic-lut";
+			reg = <0x0 0x0 0x0 0x0>;
+		};
+	};
+
+	rockchip_suspend: rockchip-suspend {
+		compatible = "rockchip,pm-rk3568";
+		status = "disabled";
+		rockchip,sleep-debug-en = <1>;
+		rockchip,sleep-mode-config = <
+			(0
+			| RKPM_SLP_ARMOFF_LOGOFF
+			| RKPM_SLP_CENTER_OFF
+			| RKPM_SLP_HW_PLLS_OFF
+			| RKPM_SLP_PMUALIVE_32K
+			| RKPM_SLP_OSC_DIS
+			| RKPM_SLP_PMIC_LP
+			| RKPM_SLP_32K_PVTM
+			)
+		>;
+		rockchip,wakeup-config = <
+			(0
+			| RKPM_GPIO_WKUP_EN
+			)
+		>;
+	};
+
+	rockchip_system_monitor: rockchip-system-monitor {
+		compatible = "rockchip,system-monitor";
+
+		rockchip,thermal-zone = "soc-thermal";
+	};
+
+	thermal_zones: thermal-zones {
+		soc_thermal: soc-thermal {
+			polling-delay-passive = <20>; /* milliseconds */
+			polling-delay = <1000>; /* milliseconds */
+			sustainable-power = <905>; /* milliwatts */
+
+			thermal-sensors = <&tsadc 0>;
+			trips {
+				threshold: trip-point-0 {
+					temperature = <75000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+				target: trip-point-1 {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+				soc_crit: soc-crit {
+					/* millicelsius */
+					temperature = <115000>;
+					/* millicelsius */
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+			cooling-maps {
+				map0 {
+					trip = <&target>;
+					cooling-device = <&cpu0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+					contribution = <1024>;
+				};
+				map1 {
+					trip = <&target>;
+					cooling-device = <&gpu THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+					contribution = <1024>;
+				};
+			};
+		};
+
+		gpu_thermal: gpu-thermal {
+			polling-delay-passive = <20>; /* milliseconds */
+			polling-delay = <1000>; /* milliseconds */
+
+			thermal-sensors = <&tsadc 1>;
+		};
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>;
+		arm,no-tick-in-suspend;
+	};
+
+	gmac0_clkin: external-gmac0-clock {
+		compatible = "fixed-clock";
+		clock-frequency = <125000000>;
+		clock-output-names = "gmac0_clkin";
+		#clock-cells = <0>;
+	};
+
+	gmac1_clkin: external-gmac1-clock {
+		compatible = "fixed-clock";
+		clock-frequency = <125000000>;
+		clock-output-names = "gmac1_clkin";
+		#clock-cells = <0>;
+	};
+
+	gmac0_xpcsclk: xpcs-gmac0-clock {
+		compatible = "fixed-clock";
+		clock-frequency = <125000000>;
+		clock-output-names = "clk_gmac0_xpcs_mii";
+		#clock-cells = <0>;
+	};
+
+	gmac1_xpcsclk: xpcs-gmac1-clock {
+		compatible = "fixed-clock";
+		clock-frequency = <125000000>;
+		clock-output-names = "clk_gmac1_xpcs_mii";
+		#clock-cells = <0>;
+	};
+
+	i2s1_mclkin_rx: i2s1-mclkin-rx {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <12288000>;
+		clock-output-names = "i2s1_mclkin_rx";
+	};
+
+	i2s1_mclkin_tx: i2s1-mclkin-tx {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <12288000>;
+		clock-output-names = "i2s1_mclkin_tx";
+	};
+
+	i2s2_mclkin: i2s2-mclkin {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <12288000>;
+		clock-output-names = "i2s2_mclkin";
+	};
+
+	i2s3_mclkin: i2s3-mclkin {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <12288000>;
+		clock-output-names = "i2s3_mclkin";
+	};
+
+	mpll: mpll {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <800000000>;
+		clock-output-names = "mpll";
+	};
+
+	xin24m: xin24m {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <24000000>;
+		clock-output-names = "xin24m";
+	};
+
+	xin32k: xin32k {
+		compatible = "fixed-clock";
+		clock-frequency = <32768>;
+		clock-output-names = "xin32k";
+		#clock-cells = <0>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&clk32k_out0>;
+	};
+
+	scmi_shmem: scmi-shmem@10f000 {
+		compatible = "arm,scmi-shmem";
+		reg = <0x0 0x0010f000 0x0 0x100>;
+	};
+
 	sata0: sata@fc000000 {
-		compatible = "rockchip,rk3568-dwc-ahci", "snps,dwc-ahci";
+		compatible = "snps,dwc-ahci";
 		reg = <0 0xfc000000 0 0x1000>;
 		clocks = <&cru ACLK_SATA0>, <&cru CLK_SATA0_PMALIVE>,
 			 <&cru CLK_SATA0_RXOOB>;
 		clock-names = "sata", "pmalive", "rxoob";
 		interrupts = <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
-		phys = <&combphy0 PHY_TYPE_SATA>;
+		interrupt-names = "hostc";
+		phys = <&combphy0_us PHY_TYPE_SATA>;
+		phy-names = "sata-phy";
+		ports-implemented = <0x1>;
+		power-domains = <&power RK3568_PD_PIPE>;
+		status = "disabled";
+	};
+
+	sata1: sata@fc400000 {
+		compatible = "snps,dwc-ahci";
+		reg = <0 0xfc400000 0 0x1000>;
+		clocks = <&cru ACLK_SATA1>, <&cru CLK_SATA1_PMALIVE>,
+			 <&cru CLK_SATA1_RXOOB>;
+		clock-names = "sata", "pmalive", "rxoob";
+		interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "hostc";
+		phys = <&combphy1_usq PHY_TYPE_SATA>;
+		phy-names = "sata-phy";
+		ports-implemented = <0x1>;
+		power-domains = <&power RK3568_PD_PIPE>;
+		status = "disabled";
+	};
+
+	sata2: sata@fc800000 {
+		compatible = "snps,dwc-ahci";
+		reg = <0 0xfc800000 0 0x1000>;
+		clocks = <&cru ACLK_SATA2>, <&cru CLK_SATA2_PMALIVE>,
+			 <&cru CLK_SATA2_RXOOB>;
+		clock-names = "sata", "pmalive", "rxoob";
+		interrupts = <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "hostc";
+		phys = <&combphy2_psq PHY_TYPE_SATA>;
 		phy-names = "sata-phy";
 		ports-implemented = <0x1>;
 		power-domains = <&power RK3568_PD_PIPE>;
 		status = "disabled";
 	};
 
-	pipe_phy_grf0: syscon@fdc70000 {
-		compatible = "rockchip,rk3568-pipe-phy-grf", "syscon";
-		reg = <0x0 0xfdc70000 0x0 0x1000>;
+	usbdrd30: usbdrd {
+		compatible = "rockchip,rk3568-dwc3", "rockchip,rk3399-dwc3";
+		clocks = <&cru CLK_USB3OTG0_REF>, <&cru CLK_USB3OTG0_SUSPEND>,
+			 <&cru ACLK_USB3OTG0>, <&cru PCLK_PIPE>;
+		clock-names = "ref_clk", "suspend_clk",
+			      "bus_clk", "pipe_clk";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		status = "disabled";
+
+		usbdrd_dwc3: dwc3@fcc00000 {
+			compatible = "snps,dwc3";
+			reg = <0x0 0xfcc00000 0x0 0x400000>;
+			interrupts = <GIC_SPI 169 IRQ_TYPE_LEVEL_HIGH>;
+			dr_mode = "otg";
+			phys = <&u2phy0_otg>, <&combphy0_us PHY_TYPE_USB3>;
+			phy-names = "usb2-phy", "usb3-phy";
+			phy_type = "utmi_wide";
+			power-domains = <&power RK3568_PD_PIPE>;
+			resets = <&cru SRST_USB3OTG0>;
+			reset-names = "usb3-otg";
+			snps,dis_enblslpm_quirk;
+			snps,dis-u1-entry-quirk;
+			snps,dis-u2-entry-quirk;
+			snps,dis-u2-freeclk-exists-quirk;
+			snps,dis-del-phy-power-chg-quirk;
+			snps,dis-tx-ipgap-linecheck-quirk;
+			snps,dis_rxdet_inp3_quirk;
+			snps,xhci-trb-ent-quirk;
+			snps,parkmode-disable-hs-quirk;
+			snps,parkmode-disable-ss-quirk;
+			quirk-skip-phy-init;
+			status = "disabled";
+		};
+	};
+
+	usbhost30: usbhost {
+		compatible = "rockchip,rk3568-dwc3", "rockchip,rk3399-dwc3";
+		clocks = <&cru CLK_USB3OTG1_REF>, <&cru CLK_USB3OTG1_SUSPEND>,
+			 <&cru ACLK_USB3OTG1>, <&cru PCLK_PIPE>;
+		clock-names = "ref_clk", "suspend_clk",
+			      "bus_clk", "pipe_clk";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		status = "disabled";
+
+		usbhost_dwc3: dwc3@fd000000 {
+			compatible = "snps,dwc3";
+			reg = <0x0 0xfd000000 0x0 0x400000>;
+			interrupts = <GIC_SPI 170 IRQ_TYPE_LEVEL_HIGH>;
+			dr_mode = "host";
+			phys = <&u2phy0_host>, <&combphy1_usq PHY_TYPE_USB3>;
+			phy-names = "usb2-phy", "usb3-phy";
+			phy_type = "utmi_wide";
+			power-domains = <&power RK3568_PD_PIPE>;
+			resets = <&cru SRST_USB3OTG1>;
+			reset-names = "usb3-host";
+			snps,dis_enblslpm_quirk;
+			snps,dis-u2-freeclk-exists-quirk;
+			snps,dis-del-phy-power-chg-quirk;
+			snps,dis-tx-ipgap-linecheck-quirk;
+			snps,dis_rxdet_inp3_quirk;
+			snps,xhci-trb-ent-quirk;
+			snps,parkmode-disable-hs-quirk;
+			snps,parkmode-disable-ss-quirk;
+			status = "disabled";
+		};
+	};
+
+	gic: interrupt-controller@fd400000 {
+		compatible = "arm,gic-v3";
+		#interrupt-cells = <3>;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		interrupt-controller;
+
+		reg = <0x0 0xfd400000 0 0x10000>, /* GICD */
+		      <0x0 0xfd460000 0 0xc0000>; /* GICR */
+		interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH>;
+		its: interrupt-controller@fd440000 {
+			compatible = "arm,gic-v3-its";
+			msi-controller;
+			#msi-cells = <1>;
+			reg = <0x0 0xfd440000 0x0 0x20000>;
+		};
+	};
+
+	usb_host0_ehci: usb@fd800000 {
+		compatible = "generic-ehci";
+		reg = <0x0 0xfd800000 0x0 0x40000>;
+		interrupts = <GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_USB2HOST0>, <&cru HCLK_USB2HOST0_ARB>,
+			 <&cru PCLK_USB>, <&usb2phy1>;
+		clock-names = "usbhost", "arbiter", "pclk", "utmi";
+		phys = <&u2phy1_otg>;
+		phy-names = "usb2-phy";
+		status = "disabled";
+	};
+
+	usb_host0_ohci: usb@fd840000 {
+		compatible = "generic-ohci";
+		reg = <0x0 0xfd840000 0x0 0x40000>;
+		interrupts = <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_USB2HOST0>, <&cru HCLK_USB2HOST0_ARB>,
+			 <&cru PCLK_USB>, <&usb2phy1>;
+		clock-names = "usbhost", "arbiter", "pclk", "utmi";
+		phys = <&u2phy1_otg>;
+		phy-names = "usb2-phy";
+		status = "disabled";
+	};
+
+	usb_host1_ehci: usb@fd880000 {
+		compatible = "generic-ehci";
+		reg = <0x0 0xfd880000 0x0 0x40000>;
+		interrupts = <GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_USB2HOST1>, <&cru HCLK_USB2HOST1_ARB>,
+			 <&cru PCLK_USB>, <&usb2phy1>;
+		clock-names = "usbhost", "arbiter", "pclk", "utmi";
+		phys = <&u2phy1_host>;
+		phy-names = "usb2-phy";
+		status = "disabled";
+	};
+
+	usb_host1_ohci: usb@fd8c0000 {
+		compatible = "generic-ohci";
+		reg = <0x0 0xfd8c0000 0x0 0x40000>;
+		interrupts = <GIC_SPI 134 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_USB2HOST1>, <&cru HCLK_USB2HOST1_ARB>,
+			 <&cru PCLK_USB>, <&usb2phy1>;
+		clock-names = "usbhost", "arbiter", "pclk", "utmi";
+		phys = <&u2phy1_host>;
+		phy-names = "usb2-phy";
+		status = "disabled";
+	};
+
+	xpcs: syscon@fda00000 {
+		compatible = "rockchip,rk3568-xpcs", "syscon";
+		reg = <0x0 0xfda00000 0x0 0x200000>;
+		status = "disabled";
+	};
+
+	pmugrf: syscon@fdc20000 {
+		compatible = "rockchip,rk3568-pmugrf", "syscon", "simple-mfd";
+		reg = <0x0 0xfdc20000 0x0 0x10000>;
+
+		pmu_io_domains: io-domains {
+			compatible = "rockchip,rk3568-pmu-io-voltage-domain";
+			status = "disabled";
+		};
+
+		reboot_mode: reboot-mode {
+			compatible = "syscon-reboot-mode";
+			offset = <0x200>;
+			mode-bootloader = <BOOT_BL_DOWNLOAD>;
+			mode-charge = <BOOT_CHARGING>;
+			mode-fastboot = <BOOT_FASTBOOT>;
+			mode-loader = <BOOT_BL_DOWNLOAD>;
+			mode-normal = <BOOT_NORMAL>;
+			mode-recovery = <BOOT_RECOVERY>;
+			mode-ums = <BOOT_UMS>;
+			mode-panic = <BOOT_PANIC>;
+			mode-watchdog = <BOOT_WATCHDOG>;
+		};
+	};
+
+	pipegrf: syscon@fdc50000 {
+		compatible = "rockchip,rk3568-pipegrf", "syscon";
+		reg = <0x0 0xfdc50000 0x0 0x1000>;
+	};
+
+	grf: syscon@fdc60000 {
+		compatible = "rockchip,rk3568-grf", "syscon", "simple-mfd";
+		reg = <0x0 0xfdc60000 0x0 0x10000>;
+
+		io_domains: io-domains {
+			compatible = "rockchip,rk3568-io-voltage-domain";
+			status = "disabled";
+		};
+
+		lvds: lvds {
+			compatible = "rockchip,rk3568-lvds";
+			phys = <&video_phy0>;
+			phy-names = "phy";
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					lvds_in_vp1: endpoint@1 {
+						reg = <1>;
+						remote-endpoint = <&vp1_out_lvds>;
+						status = "disabled";
+					};
+
+					lvds_in_vp2: endpoint@2 {
+						reg = <2>;
+						remote-endpoint = <&vp2_out_lvds>;
+						status = "disabled";
+					};
+				};
+			};
+		};
+
+		rgb: rgb {
+			compatible = "rockchip,rk3568-rgb";
+			pinctrl-names = "default";
+			pinctrl-0 = <&lcdc_ctl>;
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					rgb_in_vp2: endpoint@2 {
+						reg = <2>;
+						remote-endpoint = <&vp2_out_rgb>;
+						status = "disabled";
+					};
+				};
+			};
+		};
+
+	};
+
+	pipe_phy_grf0: syscon@fdc70000 {
+		compatible = "rockchip,pipe-phy-grf", "syscon";
+		reg = <0x0 0xfdc70000 0x0 0x1000>;
+	};
+
+	pipe_phy_grf1: syscon@fdc80000 {
+		compatible = "rockchip,pipe-phy-grf", "syscon";
+		reg = <0x0 0xfdc80000 0x0 0x1000>;
+	};
+
+	pipe_phy_grf2: syscon@fdc90000 {
+		compatible = "rockchip,pipe-phy-grf", "syscon";
+		reg = <0x0 0xfdc90000 0x0 0x1000>;
+	};
+
+	usb2phy0_grf: syscon@fdca0000 {
+		compatible = "rockchip,rk3568-usb2phy-grf", "syscon";
+		reg = <0x0 0xfdca0000 0x0 0x8000>;
+	};
+
+	usb2phy1_grf: syscon@fdca8000 {
+		compatible = "rockchip,rk3568-usb2phy-grf", "syscon";
+		reg = <0x0 0xfdca8000 0x0 0x8000>;
+	};
+
+	edp_phy_grf: syscon@fdcb0000 {
+		compatible = "rockchip,rk3568-edp-phy-grf", "syscon", "simple-mfd";
+		reg = <0x0 0xfdcb0000 0x0 0x100>;
+		clocks = <&cru PCLK_EDPPHY_GRF>;
+
+		edp_phy: edp-phy {
+			compatible = "rockchip,rk3568-edp-phy";
+			clocks = <&pmucru XIN_OSC0_EDPPHY_G>;
+			clock-names = "refclk";
+			#phy-cells = <0>;
+			status = "disabled";
+		};
+	};
+
+	pcie30_phy_grf: syscon@fdcb8000 {
+		compatible = "rockchip,pcie30-phy-grf", "syscon";
+		reg = <0x0 0xfdcb8000 0x0 0x10000>;
+	};
+
+	sram: sram@fdcc0000 {
+		compatible = "mmio-sram";
+		reg = <0x0 0xfdcc0000 0x0 0xb000>;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x0 0xfdcc0000 0xb000>;
+
+		/* start address and size should be 4k algin */
+		rkvdec_sram: rkvdec-sram@0 {
+			reg = <0x0 0xb000>;
+		};
+	};
+
+	pmucru: clock-controller@fdd00000 {
+		compatible = "rockchip,rk3568-pmucru";
+		reg = <0x0 0xfdd00000 0x0 0x1000>;
+		rockchip,grf = <&grf>;
+		rockchip,pmugrf = <&pmugrf>;
+		#clock-cells = <1>;
+		#reset-cells = <1>;
+
+		assigned-clocks = <&pmucru SCLK_32K_IOE>;
+		assigned-clock-parents = <&pmucru CLK_RTC_32K>;
+	};
+
+	cru: clock-controller@fdd20000 {
+		compatible = "rockchip,rk3568-cru";
+		reg = <0x0 0xfdd20000 0x0 0x1000>;
+		rockchip,grf = <&grf>;
+		#clock-cells = <1>;
+		#reset-cells = <1>;
+
+		assigned-clocks =
+			<&pmucru CLK_RTC_32K>, <&cru ACLK_RKVDEC_PRE>,
+			<&cru CLK_RKVDEC_CORE>, <&pmucru PLL_PPLL>,
+			<&pmucru PCLK_PMU>, <&cru PLL_CPLL>,
+			<&cru CPLL_500M>, <&cru CPLL_333M>,
+			<&cru CPLL_250M>, <&cru CPLL_125M>,
+			<&cru CPLL_100M>, <&cru CPLL_62P5M>,
+			<&cru CPLL_50M>, <&cru CPLL_25M>,
+			<&cru PLL_GPLL>,
+			<&cru ACLK_BUS>, <&cru PCLK_BUS>,
+			<&cru ACLK_TOP_HIGH>, <&cru ACLK_TOP_LOW>,
+			<&cru HCLK_TOP>, <&cru PCLK_TOP>,
+			<&cru ACLK_PERIMID>, <&cru HCLK_PERIMID>,
+			<&cru PLL_NPLL>, <&cru ACLK_PIPE>,
+			<&cru PCLK_PIPE>, <&cru CLK_I2S0_8CH_TX_SRC>,
+			<&cru CLK_I2S0_8CH_RX_SRC>, <&cru CLK_I2S1_8CH_TX_SRC>,
+			<&cru CLK_I2S1_8CH_RX_SRC>, <&cru CLK_I2S2_2CH_SRC>,
+			<&cru CLK_I2S2_2CH_SRC>, <&cru CLK_I2S3_2CH_RX_SRC>,
+			<&cru CLK_I2S3_2CH_TX_SRC>, <&cru MCLK_SPDIF_8CH_SRC>,
+			<&cru ACLK_VOP>;
+		assigned-clock-rates =
+			<32768>, <300000000>,
+			<300000000>, <200000000>,
+			<100000000>, <1000000000>,
+			<500000000>, <333000000>,
+			<250000000>, <125000000>,
+			<100000000>, <62500000>,
+			<50000000>, <25000000>,
+			<1188000000>,
+			<150000000>, <100000000>,
+			<500000000>, <400000000>,
+			<150000000>, <100000000>,
+			<300000000>, <150000000>,
+			<1200000000>, <400000000>,
+			<100000000>, <1188000000>,
+			<1188000000>, <1188000000>,
+			<1188000000>, <1188000000>,
+			<1188000000>, <1188000000>,
+			<1188000000>, <1188000000>,
+			<500000000>;
+		assigned-clock-parents =
+			<&pmucru CLK_RTC32K_FRAC>, <&cru PLL_GPLL>,
+			<&cru PLL_GPLL>;
+	};
+
+	i2c0: i2c@fdd40000 {
+		compatible = "rockchip,rk3399-i2c";
+		reg = <0x0 0xfdd40000 0x0 0x1000>;
+		clocks = <&pmucru CLK_I2C0>, <&pmucru PCLK_I2C0>;
+		clock-names = "i2c", "pclk";
+		interrupts = <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0_xfer>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "disabled";
+	};
+
+	uart0: serial@fdd50000 {
+		compatible = "rockchip,rk3568-uart", "snps,dw-apb-uart";
+		reg = <0x0 0xfdd50000 0x0 0x100>;
+		interrupts = <GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&pmucru SCLK_UART0>, <&pmucru PCLK_UART0>;
+		clock-names = "baudclk", "apb_pclk";
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		dmas = <&dmac0 0>, <&dmac0 1>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart0_xfer>;
+		status = "disabled";
+	};
+
+	pwm0: pwm@fdd70000 {
+		compatible = "rockchip,rk3568-pwm", "rockchip,rk3328-pwm";
+		reg = <0x0 0xfdd70000 0x0 0x10>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm0m0_pins>;
+		clocks = <&pmucru CLK_PWM0>, <&pmucru PCLK_PWM0>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm1: pwm@fdd70010 {
+		compatible = "rockchip,rk3568-pwm", "rockchip,rk3328-pwm";
+		reg = <0x0 0xfdd70010 0x0 0x10>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm1m0_pins>;
+		clocks = <&pmucru CLK_PWM0>, <&pmucru PCLK_PWM0>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm2: pwm@fdd70020 {
+		compatible = "rockchip,rk3568-pwm", "rockchip,rk3328-pwm";
+		reg = <0x0 0xfdd70020 0x0 0x10>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm2m0_pins>;
+		clocks = <&pmucru CLK_PWM0>, <&pmucru PCLK_PWM0>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm3: pwm@fdd70030 {
+		compatible = "rockchip,rk3568-pwm", "rockchip,rk3328-pwm";
+		reg = <0x0 0xfdd70030 0x0 0x10>;
+		interrupts = <GIC_SPI 82 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm3_pins>;
+		clocks = <&pmucru CLK_PWM0>, <&pmucru PCLK_PWM0>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pmu: power-management@fdd90000 {
+		compatible = "rockchip,rk3568-pmu", "syscon", "simple-mfd";
+		reg = <0x0 0xfdd90000 0x0 0x1000>;
+
+		power: power-controller {
+			compatible = "rockchip,rk3568-power-controller";
+			#power-domain-cells = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "okay";
+
+			/* These power domains are grouped by VD_NPU */
+			pd_npu@RK3568_PD_NPU {
+				reg = <RK3568_PD_NPU>;
+				clocks = <&cru ACLK_NPU_PRE>,
+					 <&cru HCLK_NPU_PRE>,
+					 <&cru PCLK_NPU_PRE>;
+				pm_qos = <&qos_npu>;
+			};
+			/* These power domains are grouped by VD_GPU */
+			pd_gpu@RK3568_PD_GPU {
+				reg = <RK3568_PD_GPU>;
+				clocks = <&cru ACLK_GPU_PRE>,
+					 <&cru PCLK_GPU_PRE>;
+				pm_qos = <&qos_gpu>;
+			};
+			/* These power domains are grouped by VD_LOGIC */
+			pd_vi@RK3568_PD_VI {
+				reg = <RK3568_PD_VI>;
+				clocks = <&cru HCLK_VI>,
+					 <&cru PCLK_VI>;
+				pm_qos = <&qos_isp>,
+					 <&qos_vicap0>,
+					 <&qos_vicap1>;
+			};
+			pd_vo@RK3568_PD_VO {
+				reg = <RK3568_PD_VO>;
+				clocks = <&cru HCLK_VO>,
+					 <&cru PCLK_VO>,
+					 <&cru ACLK_VOP_PRE>;
+				pm_qos = <&qos_hdcp>,
+					 <&qos_vop_m0>,
+					 <&qos_vop_m1>;
+			};
+			pd_rga@RK3568_PD_RGA {
+				reg = <RK3568_PD_RGA>;
+				clocks = <&cru HCLK_RGA_PRE>,
+					 <&cru PCLK_RGA_PRE>;
+				pm_qos = <&qos_ebc>,
+					 <&qos_iep>,
+					 <&qos_jpeg_dec>,
+					 <&qos_jpeg_enc>,
+					 <&qos_rga_rd>,
+					 <&qos_rga_wr>;
+			};
+			pd_vpu@RK3568_PD_VPU {
+				reg = <RK3568_PD_VPU>;
+				clocks = <&cru HCLK_VPU_PRE>;
+				pm_qos = <&qos_vpu>;
+			};
+			pd_rkvdec@RK3568_PD_RKVDEC {
+				clocks = <&cru HCLK_RKVDEC_PRE>;
+				reg = <RK3568_PD_RKVDEC>;
+				pm_qos = <&qos_rkvdec>;
+			};
+			pd_rkvenc@RK3568_PD_RKVENC {
+				reg = <RK3568_PD_RKVENC>;
+				clocks = <&cru HCLK_RKVENC_PRE>;
+				pm_qos = <&qos_rkvenc_rd_m0>,
+					 <&qos_rkvenc_rd_m1>,
+					 <&qos_rkvenc_wr_m0>;
+			};
+			pd_pipe@RK3568_PD_PIPE {
+				reg = <RK3568_PD_PIPE>;
+				clocks = <&cru PCLK_PIPE>;
+				pm_qos = <&qos_pcie2x1>,
+					 <&qos_pcie3x1>,
+					 <&qos_pcie3x2>,
+					 <&qos_sata0>,
+					 <&qos_sata1>,
+					 <&qos_sata2>,
+					 <&qos_usb3_0>,
+					 <&qos_usb3_1>;
+			};
+		};
+	};
+
+	pvtm@fde00000 {
+		compatible = "rockchip,rk3568-core-pvtm";
+		reg = <0x0 0xfde00000 0x0 0x100>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		pvtm@0 {
+			reg = <0>;
+			clocks = <&cru CLK_CORE_PVTM>, <&cru PCLK_CORE_PVTM>;
+			clock-names = "clk", "pclk";
+			resets = <&cru SRST_CORE_PVTM>, <&cru SRST_P_CORE_PVTM>;
+			reset-names = "rts", "rst-p";
+			thermal-zone = "soc-thermal";
+		};
+	};
+
+	rknpu: npu@fde40000 {
+		compatible = "rockchip,rk3568-rknpu", "rockchip,rknpu";
+		reg = <0x0 0xfde40000 0x0 0x10000>;
+		interrupts = <GIC_SPI 151 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&scmi_clk 2>, <&cru CLK_NPU>, <&cru ACLK_NPU>, <&cru HCLK_NPU>;
+		clock-names = "scmi_clk", "clk", "aclk", "hclk";
+		assigned-clocks = <&cru CLK_NPU>;
+		assigned-clock-rates = <600000000>;
+		resets = <&cru SRST_A_NPU>, <&cru SRST_H_NPU>;
+		reset-names = "srst_a", "srst_h";
+		power-domains = <&power RK3568_PD_NPU>;
+		operating-points-v2 = <&npu_opp_table>;
+		iommus = <&rknpu_mmu>;
+		status = "disabled";
+	};
+
+	npu_opp_table: npu-opp-table {
+		compatible = "operating-points-v2";
+
+		mbist-vmin = <825000 900000 950000>;
+		nvmem-cells = <&npu_leakage>, <&core_pvtm>, <&mbist_vmin>, <&npu_opp_info>;
+		nvmem-cell-names = "leakage", "pvtm", "mbist-vmin", "opp-info";
+		rockchip,max-volt = <1000000>;
+		rockchip,temp-hysteresis = <5000>;
+		rockchip,low-temp = <0>;
+		rockchip,low-temp-adjust-volt = <
+			/* MHz    MHz    uV */
+			   0      1000    50000
+		>;
+		rockchip,pvtm-voltage-sel = <
+			0        84000   0
+			84001    87000   1
+			87001    91000   2
+			91001    100000  3
+		>;
+		rockchip,pvtm-ch = <0 5>;
+
+		opp-200000000 {
+			opp-hz = /bits/ 64 <200000000>;
+			opp-microvolt = <850000 850000 1000000>;
+		};
+		opp-300000000 {
+			opp-hz = /bits/ 64 <297000000>;
+			opp-microvolt = <850000 850000 1000000>;
+		};
+		opp-400000000 {
+			opp-hz = /bits/ 64 <400000000>;
+			opp-microvolt = <850000 850000 1000000>;
+		};
+		opp-600000000 {
+			opp-hz = /bits/ 64 <600000000>;
+			opp-microvolt = <850000 850000 1000000>;
+		};
+		opp-700000000 {
+			opp-hz = /bits/ 64 <700000000>;
+			opp-microvolt = <875000 875000 1000000>;
+			opp-microvolt-L0 = <875000 875000 1000000>;
+			opp-microvolt-L1 = <850000 850000 1000000>;
+			opp-microvolt-L2 = <850000 850000 1000000>;
+			opp-microvolt-L3 = <850000 850000 1000000>;
+		};
+		opp-800000000 {
+			opp-hz = /bits/ 64 <800000000>;
+			opp-microvolt = <925000 925000 1000000>;
+			opp-microvolt-L0 = <925000 925000 1000000>;
+			opp-microvolt-L1 = <900000 900000 1000000>;
+			opp-microvolt-L2 = <875000 875000 1000000>;
+			opp-microvolt-L3 = <875000 875000 1000000>;
+		};
+		opp-900000000 {
+			opp-hz = /bits/ 64 <900000000>;
+			opp-microvolt = <975000 975000 1000000>;
+			opp-microvolt-L0 = <975000 975000 1000000>;
+			opp-microvolt-L1 = <950000 950000 1000000>;
+			opp-microvolt-L2 = <925000 925000 1000000>;
+			opp-microvolt-L3 = <900000 900000 1000000>;
+		};
+		opp-1000000000 {
+			opp-hz = /bits/ 64 <1000000000>;
+			opp-microvolt = <1000000 1000000 1000000>;
+			opp-microvolt-L0 = <1000000 1000000 1000000>;
+			opp-microvolt-L1 = <975000 975000 1000000>;
+			opp-microvolt-L2 = <950000 950000 1000000>;
+			opp-microvolt-L3 = <925000 925000 1000000>;
+			status = "disabled";
+		};
+	};
+
+	bus_npu: bus-npu {
+		compatible = "rockchip,rk3568-bus";
+		rockchip,busfreq-policy = "clkfreq";
+		clocks = <&scmi_clk 2>;
+		clock-names = "bus";
+		operating-points-v2 = <&bus_npu_opp_table>;
+		status = "disabled";
+	};
+
+	bus_npu_opp_table: bus-npu-opp-table {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		nvmem-cells = <&core_pvtm>;
+		nvmem-cell-names = "pvtm";
+		rockchip,pvtm-voltage-sel = <
+			0        84000   0
+			84001    91000   1
+			91001    100000  2
+		>;
+		rockchip,pvtm-ch = <0 5>;
+
+		opp-700000000 {
+			opp-hz = /bits/ 64 <700000000>;
+			opp-microvolt = <900000>;
+			opp-microvolt-L0 = <900000>;
+			opp-microvolt-L1 = <875000>;
+			opp-microvolt-L2 = <875000>;
+		};
+		opp-900000000 {
+			opp-hz = /bits/ 64 <900000000>;
+			opp-microvolt = <900000>;
+		};
+		opp-1000000000 {
+			opp-hz = /bits/ 64 <1000000000>;
+			opp-microvolt = <950000>;
+			opp-microvolt-L0 = <950000>;
+			opp-microvolt-L1 = <925000>;
+			opp-microvolt-L2 = <900000>;
+		};
+	};
+
+	rknpu_mmu: iommu@fde4b000 {
+		compatible = "rockchip,iommu-v2";
+		reg = <0x0 0xfde4b000 0x0 0x40>;
+		interrupts = <GIC_SPI 151 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "rknpu_mmu";
+		clocks = <&cru ACLK_NPU>, <&cru HCLK_NPU>;
+		clock-names = "aclk", "iface";
+		power-domains = <&power RK3568_PD_NPU>;
+		#iommu-cells = <0>;
+		status = "disabled";
+	};
+
+	gpu: gpu@fde60000 {
+		compatible = "arm,mali-bifrost";
+		reg = <0x0 0xfde60000 0x0 0x4000>;
+
+		interrupts = <GIC_SPI 39 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "GPU", "MMU", "JOB";
+
+		upthreshold = <40>;
+		downdifferential = <10>;
+
+		clocks = <&scmi_clk 1>, <&cru CLK_GPU>;
+		clock-names = "clk_mali", "clk_gpu";
+		power-domains = <&power RK3568_PD_GPU>;
+		#cooling-cells = <2>;
+		operating-points-v2 = <&gpu_opp_table>;
+
+		status = "disabled";
+		gpu_power_model: power-model {
+			compatible = "simple-power-model";
+			leakage-range= <5 15>;
+			ls = <(-24002) 22823 0>;
+			static-coefficient = <100000>;
+			dynamic-coefficient = <953>;
+			ts = <(-108890) 63610 (-1355) 20>;
+			thermal-zone = "gpu-thermal";
+		};
+	};
+
+	gpu_opp_table: opp-table2 {
+		compatible = "operating-points-v2";
+
+		mbist-vmin = <825000 900000 950000>;
+		nvmem-cells = <&gpu_leakage>, <&core_pvtm>, <&mbist_vmin>, <&gpu_opp_info>;
+		nvmem-cell-names = "leakage", "pvtm", "mbist-vmin", "opp-info";
+		rockchip,max-volt = <1000000>;
+		rockchip,temp-hysteresis = <5000>;
+		rockchip,low-temp = <0>;
+		rockchip,low-temp-adjust-volt = <
+			/* MHz    MHz    uV */
+			   0      800    50000
+		>;
+		rockchip,pvtm-voltage-sel = <
+			0        84000   0
+			84001    87000   1
+			87001    91000   2
+			91001    100000  3
+		>;
+		rockchip,pvtm-ch = <0 5>;
+
+		opp-200000000 {
+			opp-hz = /bits/ 64 <200000000>;
+			opp-microvolt = <850000 850000 1000000>;
+			opp-microvolt-L3 = <900000 900000 1000000>;
+		};
+		opp-300000000 {
+			opp-hz = /bits/ 64 <300000000>;
+			opp-microvolt = <850000 850000 1000000>;
+			opp-microvolt-L3 = <900000 900000 1000000>;
+		};
+		opp-400000000 {
+			opp-hz = /bits/ 64 <400000000>;
+			opp-microvolt = <850000 850000 1000000>;
+			opp-microvolt-L3 = <900000 900000 1000000>;
+		};
+		opp-600000000 {
+			opp-hz = /bits/ 64 <600000000>;
+			opp-microvolt = <900000 900000 1000000>;
+			opp-microvolt-L0 = <900000 900000 1000000>;
+			opp-microvolt-L1 = <875000 875000 1000000>;
+			opp-microvolt-L2 = <850000 850000 1000000>;
+			opp-microvolt-L3 = <850000 850000 1000000>;
+		};
+		opp-700000000 {
+			opp-hz = /bits/ 64 <700000000>;
+			opp-microvolt = <950000 950000 1000000>;
+			opp-microvolt-L0 = <950000 950000 1000000>;
+			opp-microvolt-L1 = <925000 925000 1000000>;
+			opp-microvolt-L2 = <900000 900000 1000000>;
+			opp-microvolt-L3 = <875000 875000 1000000>;
+		};
+		opp-800000000 {
+			opp-hz = /bits/ 64 <800000000>;
+			opp-microvolt = <1000000 1000000 1000000>;
+			opp-microvolt-L0 = <1000000 1000000 1000000>;
+			opp-microvolt-L1 = <975000 975000 1000000>;
+			opp-microvolt-L2 = <950000 950000 1000000>;
+			opp-microvolt-L3 = <925000 925000 1000000>;
+		};
+	};
+
+	pvtm@fde80000 {
+		compatible = "rockchip,rk3568-gpu-pvtm";
+		reg = <0x0 0xfde80000 0x0 0x100>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		pvtm@1 {
+			reg = <1>;
+			clocks = <&cru CLK_GPU_PVTM>, <&cru PCLK_GPU_PVTM>;
+			clock-names = "clk", "pclk";
+			resets = <&cru SRST_GPU_PVTM>, <&cru SRST_P_GPU_PVTM>;
+			reset-names = "rts", "rst-p";
+			thermal-zone = "gpu-thermal";
+		};
+	};
+
+	pvtm@fde90000 {
+		compatible = "rockchip,rk3568-npu-pvtm";
+		reg = <0x0 0xfde90000 0x0 0x100>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		pvtm@2 {
+			reg = <2>;
+			clocks = <&cru CLK_NPU_PVTM>, <&cru PCLK_NPU_PVTM>,
+				 <&cru HCLK_NPU_PRE>;
+			clock-names = "clk", "pclk", "hclk";
+			resets = <&cru SRST_NPU_PVTM>, <&cru SRST_P_NPU_PVTM>;
+			reset-names = "rts", "rst-p";
+			thermal-zone = "soc-thermal";
+		};
+	};
+
+	vdpu: vdpu@fdea0400 {
+		compatible = "rockchip,vpu-decoder-v2";
+		reg = <0x0 0xfdea0400 0x0 0x400>;
+		interrupts = <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_dec";
+		clocks = <&cru ACLK_VPU>, <&cru HCLK_VPU>;
+		clock-names = "aclk_vcodec", "hclk_vcodec";
+		resets = <&cru SRST_A_VPU>, <&cru SRST_H_VPU>;
+		reset-names = "video_a", "video_h";
+		iommus = <&vdpu_mmu>;
+		power-domains = <&power RK3568_PD_VPU>;
+		rockchip,srv = <&mpp_srv>;
+		rockchip,taskqueue-node = <0>;
+		rockchip,resetgroup-node = <0>;
+		status = "disabled";
+	};
+
+	vdpu_mmu: iommu@fdea0800 {
+		compatible = "rockchip,iommu-v2";
+		reg = <0x0 0xfdea0800 0x0 0x40>;
+		interrupts = <GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "vdpu_mmu";
+		clock-names = "aclk", "iface";
+		clocks = <&cru ACLK_VPU>, <&cru HCLK_VPU>;
+		power-domains = <&power RK3568_PD_VPU>;
+		#iommu-cells = <0>;
+		status = "disabled";
+	};
+
+	rk_rga: rk_rga@fdeb0000 {
+		compatible = "rockchip,rga2";
+		reg = <0x0 0xfdeb0000 0x0 0x1000>;
+		interrupts = <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_RGA>, <&cru HCLK_RGA>, <&cru CLK_RGA_CORE>;
+		clock-names = "aclk_rga", "hclk_rga", "clk_rga";
+		power-domains = <&power RK3568_PD_RGA>;
+		status = "disabled";
+	};
+
+	ebc: ebc@fdec0000 {
+		compatible = "rockchip,rk3568-ebc-tcon";
+		reg = <0x0 0xfdec0000 0x0 0x5000>;
+		interrupts = <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_EBC>, <&cru DCLK_EBC>;
+		clock-names = "hclk", "dclk";
+		power-domains = <&power RK3568_PD_RGA>;
+		rockchip,grf = <&grf>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&ebc_pins>;
+		status = "disabled";
+	};
+
+	jpegd: jpegd@fded0000 {
+		compatible = "rockchip,rkv-jpeg-decoder-v1";
+		reg = <0x0 0xfded0000 0x0 0x400>;
+		interrupts = <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_JDEC>, <&cru HCLK_JDEC>;
+		clock-names = "aclk_vcodec", "hclk_vcodec";
+		rockchip,disable-auto-freq;
+		resets = <&cru SRST_A_JDEC>, <&cru SRST_H_JDEC>;
+		reset-names = "video_a", "video_h";
+		iommus = <&jpegd_mmu>;
+		rockchip,srv = <&mpp_srv>;
+		rockchip,taskqueue-node = <1>;
+		rockchip,resetgroup-node = <1>;
+		power-domains = <&power RK3568_PD_RGA>;
+		status = "disabled";
+	};
+
+	jpegd_mmu: iommu@fded0480 {
+		compatible = "rockchip,iommu-v2";
+		reg = <0x0 0xfded0480 0x0 0x40>;
+		interrupts = <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "jpegd_mmu";
+		clock-names = "aclk", "iface";
+		clocks = <&cru ACLK_JDEC>, <&cru HCLK_JDEC>;
+		power-domains = <&power RK3568_PD_RGA>;
+		#iommu-cells = <0>;
+		status = "disabled";
+	};
+
+	vepu: vepu@fdee0000 {
+		compatible = "rockchip,vpu-encoder-v2";
+		reg = <0x0 0xfdee0000 0x0 0x400>;
+		interrupts = <GIC_SPI 64 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_JENC>, <&cru HCLK_JENC>;
+		clock-names = "aclk_vcodec", "hclk_vcodec";
+		rockchip,disable-auto-freq;
+		resets = <&cru SRST_A_JENC>, <&cru SRST_H_JENC>;
+		reset-names = "video_a", "video_h";
+		iommus = <&vepu_mmu>;
+		rockchip,srv = <&mpp_srv>;
+		rockchip,taskqueue-node = <2>;
+		rockchip,resetgroup-node = <2>;
+		power-domains = <&power RK3568_PD_RGA>;
+		status = "disabled";
+	};
+
+	vepu_mmu: iommu@fdee0800 {
+		compatible = "rockchip,iommu-v2";
+		reg = <0x0 0xfdee0800 0x0 0x40>;
+		interrupts = <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "vepu_mmu";
+		clock-names = "aclk", "iface";
+		clocks = <&cru ACLK_JENC>, <&cru HCLK_JENC>;
+		power-domains = <&power RK3568_PD_RGA>;
+		#iommu-cells = <0>;
+		status = "disabled";
+	};
+
+	iep: iep@fdef0000 {
+		compatible = "rockchip,iep-v2";
+		reg = <0x0 0xfdef0000 0x0 0x500>;
+		interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_IEP>, <&cru HCLK_IEP>, <&cru CLK_IEP_CORE>;
+		clock-names = "aclk", "hclk", "sclk";
+		resets = <&cru SRST_A_IEP>, <&cru SRST_H_IEP>,
+			<&cru SRST_IEP_CORE>;
+		reset-names = "rst_a", "rst_h", "rst_s";
+		power-domains = <&power RK3568_PD_RGA>;
+		rockchip,srv = <&mpp_srv>;
+		rockchip,taskqueue-node = <5>;
+		rockchip,resetgroup-node = <5>;
+		iommus = <&iep_mmu>;
+		status = "disabled";
+	};
+
+	iep_mmu: iommu@fdef0800 {
+		compatible = "rockchip,iommu-v2";
+		reg = <0x0 0xfdef0800 0x0 0x100>;
+		interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "iep_mmu";
+		clocks = <&cru ACLK_IEP>, <&cru HCLK_IEP>;
+		clock-names = "aclk", "iface";
+		#iommu-cells = <0>;
+		power-domains = <&power RK3568_PD_RGA>;
+		//rockchip,disable-device-link-resume;
+		status = "disabled";
+	};
+
+	eink: eink@fdf00000 {
+		compatible = "rockchip,rk3568-eink-tcon";
+		reg = <0x0 0xfdf00000 0x0 0x74>;
+		interrupts = <GIC_SPI 178 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru PCLK_EINK>, <&cru HCLK_EINK>;
+		clock-names = "pclk", "hclk";
+		status = "disabled";
+	};
+
+	rkvenc: rkvenc@fdf40000 {
+		compatible = "rockchip,rkv-encoder-v1";
+		reg = <0x0 0xfdf40000 0x0 0x400>;
+		interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_enc";
+		clocks = <&cru ACLK_RKVENC>, <&cru HCLK_RKVENC>,
+			<&cru CLK_RKVENC_CORE>;
+		clock-names = "aclk_vcodec", "hclk_vcodec", "clk_core";
+		rockchip,normal-rates = <297000000>, <0>, <297000000>;
+		resets = <&cru SRST_A_RKVENC>, <&cru SRST_H_RKVENC>,
+			<&cru SRST_RKVENC_CORE>;
+		reset-names = "video_a", "video_h", "video_core";
+		assigned-clocks = <&cru ACLK_RKVENC>, <&cru CLK_RKVENC_CORE>;
+		assigned-clock-rates = <297000000>, <297000000>;
+		iommus = <&rkvenc_mmu>;
+		node-name = "rkvenc";
+		rockchip,srv = <&mpp_srv>;
+		rockchip,taskqueue-node = <3>;
+		rockchip,resetgroup-node = <3>;
+		power-domains = <&power RK3568_PD_RKVENC>;
+		operating-points-v2 = <&rkvenc_opp_table>;
+		status = "disabled";
+	};
+
+	rkvenc_opp_table: rkvenc-opp-table {
+		compatible = "operating-points-v2";
+
+		nvmem-cells = <&core_pvtm>;
+		nvmem-cell-names = "pvtm";
+		rockchip,pvtm-voltage-sel = <
+			0        84000   0
+			84001    91000   1
+			91001    100000  2
+		>;
+		rockchip,pvtm-ch = <0 5>;
+
+		opp-297000000 {
+			opp-hz = /bits/ 64 <297000000>;
+			opp-microvolt = <900000>;
+			opp-microvolt-L0 = <900000>;
+			opp-microvolt-L1 = <875000>;
+			opp-microvolt-L2 = <875000>;
+			opp-microvolt-L3 = <900000>;
+		};
+		opp-400000000 {
+			opp-hz = /bits/ 64 <400000000>;
+			opp-microvolt = <950000>;
+			opp-microvolt-L0 = <950000>;
+			opp-microvolt-L1 = <925000>;
+			opp-microvolt-L2 = <900000>;
+		};
+	};
+
+	rkvenc_mmu: iommu@fdf40f00 {
+		compatible = "rockchip,iommu-v2";
+		reg = <0x0 0xfdf40f00 0x0 0x40>, <0x0 0xfdf40f40 0x0 0x40>;
+		interrupts = <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>,
+			<GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "rkvenc_mmu0", "rkvenc_mmu1";
+		clocks = <&cru ACLK_RKVENC>, <&cru HCLK_RKVENC>;
+		clock-names = "aclk", "iface";
+		rockchip,disable-mmu-reset;
+		rockchip,enable-cmd-retry;
+		#iommu-cells = <0>;
+		power-domains = <&power RK3568_PD_RKVENC>;
+		status = "disabled";
+	};
+
+	rkvdec: rkvdec@fdf80200 {
+		compatible = "rockchip,rkv-decoder-rk3568", "rockchip,rkv-decoder-v2";
+		reg = <0x0 0xfdf80200 0x0 0x400>, <0x0 0xfdf80100 0x0 0x100>;
+		reg-names = "regs", "link";
+		interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_dec";
+		clocks = <&cru ACLK_RKVDEC>, <&cru HCLK_RKVDEC>,
+			 <&cru CLK_RKVDEC_CA>, <&cru CLK_RKVDEC_CORE>,
+			 <&cru CLK_RKVDEC_HEVC_CA>;
+		clock-names = "aclk_vcodec", "hclk_vcodec","clk_cabac",
+			      "clk_core", "clk_hevc_cabac";
+		rockchip,normal-rates = <297000000>, <0>, <297000000>,
+					<297000000>, <600000000>;
+		rockchip,advanced-rates = <396000000>, <0>, <396000000>,
+					<396000000>, <600000000>;
+		rockchip,default-max-load = <2088960>;
+		resets = <&cru SRST_A_RKVDEC>, <&cru SRST_H_RKVDEC>,
+			 <&cru SRST_RKVDEC_CA>, <&cru SRST_RKVDEC_CORE>,
+			 <&cru SRST_RKVDEC_HEVC_CA>;
+		assigned-clocks = <&cru ACLK_RKVDEC>, <&cru CLK_RKVDEC_CA>,
+				  <&cru CLK_RKVDEC_CORE>, <&cru CLK_RKVDEC_HEVC_CA>;
+		assigned-clock-rates = <297000000>, <297000000>, <297000000>, <297000000>;
+		reset-names = "video_a", "video_h", "video_cabac",
+			      "video_core", "video_hevc_cabac";
+		power-domains = <&power RK3568_PD_RKVDEC>;
+		operating-points-v2 = <&rkvdec_opp_table>;
+		vdec-supply = <&vdd_logic>;
+		iommus = <&rkvdec_mmu>;
+		rockchip,srv = <&mpp_srv>;
+		rockchip,taskqueue-node = <4>;
+		rockchip,resetgroup-node = <4>;
+		rockchip,sram = <&rkvdec_sram>;
+		/* rcb_iova: start and size */
+		rockchip,rcb-iova = <0x10000000 65536>;
+		rockchip,rcb-min-width = <512>;
+		rockchip,task-capacity = <16>;
+		status = "disabled";
+	};
+
+	rkvdec_opp_table: rkvdec-opp-table {
+		compatible = "operating-points-v2";
+
+		nvmem-cells = <&log_leakage>, <&core_pvtm>;
+		nvmem-cell-names = "leakage", "pvtm";
+		rockchip,leakage-voltage-sel = <
+			1   80    0
+			81  254   1
+		>;
+		rockchip,pvtm-voltage-sel = <
+			0        84000   0
+			84001    100000  1
+		>;
+		rockchip,pvtm-ch = <0 5>;
+
+		opp-297000000 {
+			opp-hz = /bits/ 64 <297000000>;
+			opp-microvolt = <900000>;
+			opp-microvolt-L0 = <900000>;
+			opp-microvolt-L1 = <875000>;
+		};
+		opp-400000000 {
+			opp-hz = /bits/ 64 <400000000>;
+			opp-microvolt = <900000>;
+		};
+	};
+
+	rkvdec_mmu: iommu@fdf80800 {
+		compatible = "rockchip,iommu-v2";
+		reg = <0x0 0xfdf80800 0x0 0x40>, <0x0 0xfdf80840 0x0 0x40>;
+		interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "rkvdec_mmu";
+		clocks = <&cru ACLK_RKVDEC>, <&cru HCLK_RKVDEC>;
+		clock-names = "aclk", "iface";
+		power-domains = <&power RK3568_PD_RKVDEC>;
+		#iommu-cells = <0>;
+		status = "disabled";
+	};
+
+	mipi_csi2: mipi-csi2@fdfb0000 {
+		compatible = "rockchip,rk3568-mipi-csi2";
+		reg = <0x0 0xfdfb0000 0x0 0x10000>;
+		reg-names = "csihost_regs";
+		interrupts = <GIC_SPI 8 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "csi-intr1", "csi-intr2";
+		clocks = <&cru PCLK_CSI2HOST1>;
+		clock-names = "pclk_csi2host";
+		resets = <&cru SRST_P_CSI2HOST1>;
+		reset-names = "srst_csihost_p";
+		status = "disabled";
+	};
+
+	rkcif: rkcif@fdfe0000 {
+		compatible = "rockchip,rk3568-cif";
+		reg = <0x0 0xfdfe0000 0x0 0x8000>;
+		reg-names = "cif_regs";
+		interrupts = <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "cif-intr";
+
+		clocks = <&cru ACLK_VICAP>, <&cru HCLK_VICAP>,
+			 <&cru DCLK_VICAP>, <&cru ICLK_VICAP_G>;
+		clock-names = "aclk_cif", "hclk_cif",
+			      "dclk_cif", "iclk_cif_g";
+		resets = <&cru SRST_A_VICAP>, <&cru SRST_H_VICAP>,
+			 <&cru SRST_D_VICAP>, <&cru SRST_P_VICAP>,
+			 <&cru SRST_I_VICAP>;
+		reset-names = "rst_cif_a", "rst_cif_h",
+			      "rst_cif_d", "rst_cif_p",
+			      "rst_cif_i";
+		assigned-clocks = <&cru DCLK_VICAP>;
+		assigned-clock-rates = <300000000>;
+		power-domains = <&power RK3568_PD_VI>;
+		rockchip,grf = <&grf>;
+		iommus = <&rkcif_mmu>;
+		status = "disabled";
+	};
+
+	rkcif_mmu: iommu@fdfe0800 {
+		compatible = "rockchip,iommu-v2";
+		reg = <0x0 0xfdfe0800 0x0 0x100>;
+		interrupts = <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "cif_mmu";
+		clocks = <&cru ACLK_VICAP>, <&cru HCLK_VICAP>;
+		clock-names = "aclk", "iface";
+		power-domains = <&power RK3568_PD_VI>;
+		rockchip,disable-mmu-reset;
+		#iommu-cells = <0>;
+		status = "disabled";
+	};
+
+	rkcif_dvp: rkcif_dvp {
+		compatible = "rockchip,rkcif-dvp";
+		rockchip,hw = <&rkcif>;
+		status = "disabled";
+	};
+
+	rkcif_dvp_sditf: rkcif_dvp_sditf {
+		compatible = "rockchip,rkcif-sditf";
+		rockchip,cif = <&rkcif_dvp>;
+		status = "disabled";
+	};
+
+	rkcif_mipi_lvds: rkcif_mipi_lvds {
+		compatible = "rockchip,rkcif-mipi-lvds";
+		rockchip,hw = <&rkcif>;
+		status = "disabled";
+	};
+
+	rkcif_mipi_lvds_sditf: rkcif_mipi_lvds_sditf {
+		compatible = "rockchip,rkcif-sditf";
+		rockchip,cif = <&rkcif_mipi_lvds>;
+		status = "disabled";
+	};
+
+	rkisp: rkisp@fdff0000 {
+		compatible = "rockchip,rk3568-rkisp";
+		reg = <0x0 0xfdff0000 0x0 0x10000>;
+		interrupts = <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "mipi_irq", "mi_irq", "isp_irq";
+		clocks = <&cru ACLK_ISP>, <&cru HCLK_ISP>, <&cru CLK_ISP>;
+		clock-names = "aclk_isp", "hclk_isp", "clk_isp";
+		resets = <&cru SRST_ISP>, <&cru SRST_H_ISP>;
+		reset-names = "isp", "isp-h";
+		rockchip,grf = <&grf>;
+		power-domains = <&power RK3568_PD_VI>;
+		iommus = <&rkisp_mmu>;
+		rockchip,iq-feature = /bits/ 64 <0x1BFBFFFE67FF>;
+		status = "disabled";
+	};
+
+	rkisp_mmu: iommu@fdff1a00 {
+		compatible = "rockchip,iommu-v2";
+		reg = <0x0 0xfdff1a00 0x0 0x100>;
+		interrupts = <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "isp_mmu";
+		clocks = <&cru ACLK_ISP>, <&cru HCLK_ISP>;
+		clock-names = "aclk", "iface";
+		power-domains = <&power RK3568_PD_VI>;
+		#iommu-cells = <0>;
+		rockchip,disable-mmu-reset;
+		status = "disabled";
+	};
+
+	rkisp_vir0: rkisp-vir0 {
+		compatible = "rockchip,rkisp-vir";
+		rockchip,hw = <&rkisp>;
+		status = "disabled";
+	};
+
+	rkisp_vir1: rkisp-vir1 {
+		compatible = "rockchip,rkisp-vir";
+		rockchip,hw = <&rkisp>;
+		status = "disabled";
+	};
+
+	gmac_uio1: uio@fe010000 {
+		compatible = "rockchip,uio-gmac";
+		reg = <0x0 0xfe010000 0x0 0x10000>;
+		rockchip,ethernet = <&gmac1>;
+		status = "disabled";
+	};
+
+	gmac1: ethernet@fe010000 {
+		compatible = "rockchip,rk3568-gmac", "snps,dwmac-4.20a";
+		reg = <0x0 0xfe010000 0x0 0x10000>;
+		interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "macirq", "eth_wake_irq";
+		rockchip,grf = <&grf>;
+		clocks = <&cru SCLK_GMAC1>, <&cru SCLK_GMAC1_RX_TX>,
+			 <&cru SCLK_GMAC1_RX_TX>, <&cru CLK_MAC1_REFOUT>,
+			 <&cru ACLK_GMAC1>, <&cru PCLK_GMAC1>,
+			 <&cru SCLK_GMAC1_RX_TX>, <&cru CLK_GMAC1_PTP_REF>,
+			 <&cru PCLK_XPCS>, <&cru CLK_XPCS_EEE>;
+		clock-names = "stmmaceth", "mac_clk_rx",
+			      "mac_clk_tx", "clk_mac_refout",
+			      "aclk_mac", "pclk_mac",
+			      "clk_mac_speed", "ptp_ref",
+			      "pclk_xpcs", "clk_xpcs_eee";
+		resets = <&cru SRST_A_GMAC1>;
+		reset-names = "stmmaceth";
+
+		snps,mixed-burst;
+		snps,tso;
+
+		snps,axi-config = <&gmac1_stmmac_axi_setup>;
+		snps,mtl-rx-config = <&gmac1_mtl_rx_setup>;
+		snps,mtl-tx-config = <&gmac1_mtl_tx_setup>;
+		status = "disabled";
+
+		mdio1: mdio {
+			compatible = "snps,dwmac-mdio";
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+		};
+
+		gmac1_stmmac_axi_setup: stmmac-axi-config {
+			snps,wr_osr_lmt = <4>;
+			snps,rd_osr_lmt = <8>;
+			snps,blen = <0 0 0 0 16 8 4>;
+		};
+
+		gmac1_mtl_rx_setup: rx-queues-config {
+			snps,rx-queues-to-use = <1>;
+			queue0 {};
+		};
+
+		gmac1_mtl_tx_setup: tx-queues-config {
+			snps,tx-queues-to-use = <1>;
+			queue0 {};
+		};
+	};
+
+	vop: vop@fe040000 {
+		compatible = "rockchip,rk3568-vop";
+		reg = <0x0 0xfe040000 0x0 0x3000>, <0x0 0xfe044000 0x0 0x1000>;
+		reg-names = "regs", "gamma_lut";
+		rockchip,grf = <&grf>;
+		interrupts = <GIC_SPI 148 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_VOP>, <&cru HCLK_VOP>, <&cru DCLK_VOP0>, <&cru DCLK_VOP1>, <&cru DCLK_VOP2>;
+		clock-names = "aclk_vop", "hclk_vop", "dclk_vp0", "dclk_vp1", "dclk_vp2";
+		iommus = <&vop_mmu>;
+		power-domains = <&power RK3568_PD_VO>;
+		status = "disabled";
+
+		vop_out: ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			vp0: port@0 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0>;
+
+				vp0_out_dsi0: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&dsi0_in_vp0>;
+				};
+
+				vp0_out_dsi1: endpoint@1 {
+					reg = <1>;
+					remote-endpoint = <&dsi1_in_vp0>;
+				};
+
+				vp0_out_edp: endpoint@2 {
+					reg = <2>;
+					remote-endpoint = <&edp_in_vp0>;
+				};
+
+				vp0_out_hdmi: endpoint@3 {
+					reg = <3>;
+					remote-endpoint = <&hdmi_in_vp0>;
+				};
+			};
+
+			vp1: port@1 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <1>;
+
+				vp1_out_dsi0: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&dsi0_in_vp1>;
+				};
+
+				vp1_out_dsi1: endpoint@1 {
+					reg = <1>;
+					remote-endpoint = <&dsi1_in_vp1>;
+				};
+
+				vp1_out_edp: endpoint@2 {
+					reg = <2>;
+					remote-endpoint = <&edp_in_vp1>;
+				};
+
+				vp1_out_hdmi: endpoint@3 {
+					reg = <3>;
+					remote-endpoint = <&hdmi_in_vp1>;
+				};
+
+				vp1_out_lvds: endpoint@4 {
+					reg = <4>;
+					remote-endpoint = <&lvds_in_vp1>;
+				};
+			};
+
+			vp2: port@2 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				reg = <2>;
+
+				vp2_out_lvds: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&lvds_in_vp2>;
+				};
+
+				vp2_out_rgb: endpoint@1 {
+					reg = <1>;
+					remote-endpoint = <&rgb_in_vp2>;
+				};
+			};
+		};
+	};
+
+	vop_mmu: iommu@fe043e00 {
+		compatible = "rockchip,iommu-v2";
+		reg = <0x0 0xfe043e00 0x0 0x100>, <0x0 0xfe043f00 0x0 0x100>;
+		interrupts = <GIC_SPI 148 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "vop_mmu";
+		clocks = <&cru ACLK_VOP>, <&cru HCLK_VOP>;
+		clock-names = "aclk", "iface";
+		#iommu-cells = <0>;
+		rockchip,disable-device-link-resume;
+		status = "disabled";
+	};
+
+	dsi0: dsi@fe060000 {
+		compatible = "rockchip,rk3568-mipi-dsi";
+		reg = <0x0 0xfe060000 0x0 0x10000>;
+		interrupts = <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru PCLK_DSITX_0>, <&cru HCLK_VO>;
+		clock-names = "pclk", "hclk";
+		resets = <&cru SRST_P_DSITX_0>;
+		reset-names = "apb";
+		phys = <&video_phy0>;
+		phy-names = "dphy";
+		power-domains = <&power RK3568_PD_VO>;
+		rockchip,grf = <&grf>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "disabled";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			dsi0_in: port@0 {
+				reg = <0>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				dsi0_in_vp0: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&vp0_out_dsi0>;
+					status = "disabled";
+				};
+
+				dsi0_in_vp1: endpoint@1 {
+					reg = <1>;
+					remote-endpoint = <&vp1_out_dsi0>;
+					status = "disabled";
+				};
+			};
+		};
+	};
+
+	dsi1: dsi@fe070000 {
+		compatible = "rockchip,rk3568-mipi-dsi";
+		reg = <0x0 0xfe070000 0x0 0x10000>;
+		interrupts = <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru PCLK_DSITX_1>, <&cru HCLK_VO>;
+		clock-names = "pclk", "hclk";
+		resets = <&cru SRST_P_DSITX_1>;
+		reset-names = "apb";
+		phys = <&video_phy1>;
+		phy-names = "dphy";
+		power-domains = <&power RK3568_PD_VO>;
+		rockchip,grf = <&grf>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "disabled";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			dsi1_in: port@0 {
+				reg = <0>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				dsi1_in_vp0: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&vp0_out_dsi1>;
+					status = "disabled";
+				};
+
+				dsi1_in_vp1: endpoint@1 {
+					reg = <1>;
+					remote-endpoint = <&vp1_out_dsi1>;
+					status = "disabled";
+				};
+			};
+		};
+	};
+
+	hdmi: hdmi@fe0a0000 {
+		compatible = "rockchip,rk3568-dw-hdmi";
+		reg = <0x0 0xfe0a0000 0x0 0x20000>;
+		interrupts = <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru PCLK_HDMI_HOST>,
+			 <&cru CLK_HDMI_SFR>,
+			 <&cru CLK_HDMI_CEC>,
+			 <&pmucru PLL_HPLL>,
+			 <&cru HCLK_VOP>;
+		clock-names = "iahb", "isfr", "cec", "ref", "hclk";
+		power-domains = <&power RK3568_PD_VO>;
+		reg-io-width = <4>;
+		rockchip,grf = <&grf>;
+		#sound-dai-cells = <0>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&hdmitx_scl &hdmitx_sda &hdmitxm0_cec>;
+		status = "disabled";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				hdmi_in_vp0: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&vp0_out_hdmi>;
+					status = "disabled";
+				};
+
+				hdmi_in_vp1: endpoint@1 {
+					reg = <1>;
+					remote-endpoint = <&vp1_out_hdmi>;
+					status = "disabled";
+				};
+			};
+		};
+	};
+
+	edp: edp@fe0c0000 {
+		compatible = "rockchip,rk3568-edp";
+		reg = <0x0 0xfe0c0000 0x0 0x10000>;
+		interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&pmucru XIN_OSC0_EDPPHY_G>, <&cru PCLK_EDP_CTRL>,
+			 <&cru CLK_EDP_200M>, <&cru HCLK_VO>;
+		clock-names = "dp", "pclk", "spdif", "hclk";
+		resets = <&cru SRST_EDP_24M>, <&cru SRST_P_EDP_CTRL>;
+		reset-names = "dp", "apb";
+		phys = <&edp_phy>;
+		phy-names = "dp";
+		power-domains = <&power RK3568_PD_VO>;
+		status = "disabled";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			edp_in: port@0 {
+				reg = <0>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				edp_in_vp0: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&vp0_out_edp>;
+					status = "disabled";
+				};
+
+				edp_in_vp1: endpoint@1 {
+					reg = <1>;
+					remote-endpoint = <&vp1_out_edp>;
+					status = "disabled";
+				};
+			};
+		};
+	};
+
+	nocp_cpu: nocp-cpu@fe102000 {
+		compatible = "rockchip,rk3568-nocp";
+		reg = <0x0 0xfe102000 0x0 0x400>;
+	};
+
+	nocp_gpu_vpu_rga_venc: nocp-gpu-vpu-rga-venc@fe102400 {
+		compatible = "rockchip,rk3568-nocp";
+		reg = <0x0 0xfe102400 0x0 0x400>;
+	};
+
+	nocp_npu_vdec: nocp-vdec@fe102800 {
+		compatible = "rockchip,rk3568-nocp";
+		reg = <0x0 0xfe102800 0x0 0x400>;
+	};
+
+	nocp_vi_usb_peri_pipe: nocp-vi-usb-peri-pipe@fe102c00 {
+		compatible = "rockchip,rk3568-nocp";
+		reg = <0x0 0xfe102c00 0x0 0x400>;
+	};
+
+	nocp_vo: nocp-vo@fe103000 {
+		compatible = "rockchip,rk3568-nocp";
+		reg = <0x0 0xfe103000 0x0 0x400>;
+	};
+
+	qos_gpu: qos@fe128000 {
+		compatible = "syscon";
+		reg = <0x0 0xfe128000 0x0 0x20>;
+	};
+
+	qos_rkvenc_rd_m0: qos@fe138080 {
+		compatible = "syscon";
+		reg = <0x0 0xfe138080 0x0 0x20>;
+	};
+
+	qos_rkvenc_rd_m1: qos@fe138100 {
+		compatible = "syscon";
+		reg = <0x0 0xfe138100 0x0 0x20>;
+	};
+
+	qos_rkvenc_wr_m0: qos@fe138180 {
+		compatible = "syscon";
+		reg = <0x0 0xfe138180 0x0 0x20>;
+	};
+
+	qos_isp: qos@fe148000 {
+		compatible = "syscon";
+		reg = <0x0 0xfe148000 0x0 0x20>;
+	};
+
+	qos_vicap0: qos@fe148080 {
+		compatible = "syscon";
+		reg = <0x0 0xfe148080 0x0 0x20>;
+	};
+
+	qos_vicap1: qos@fe148100 {
+		compatible = "syscon";
+		reg = <0x0 0xfe148100 0x0 0x20>;
+	};
+
+	qos_vpu: qos@fe150000 {
+		compatible = "syscon";
+		reg = <0x0 0xfe150000 0x0 0x20>;
+	};
+
+	qos_ebc: qos@fe158000 {
+		compatible = "syscon";
+		reg = <0x0 0xfe158000 0x0 0x20>;
+	};
+
+	qos_iep: qos@fe158100 {
+		compatible = "syscon";
+		reg = <0x0 0xfe158100 0x0 0x20>;
+	};
+
+	qos_jpeg_dec: qos@fe158180 {
+		compatible = "syscon";
+		reg = <0x0 0xfe158180 0x0 0x20>;
+	};
+
+	qos_jpeg_enc: qos@fe158200 {
+		compatible = "syscon";
+		reg = <0x0 0xfe158200 0x0 0x20>;
+	};
+
+	qos_rga_rd: qos@fe158280 {
+		compatible = "syscon";
+		reg = <0x0 0xfe158280 0x0 0x20>;
+	};
+
+	qos_rga_wr: qos@fe158300 {
+		compatible = "syscon";
+		reg = <0x0 0xfe158300 0x0 0x20>;
+	};
+
+	qos_npu: qos@fe180000 {
+		compatible = "syscon";
+		reg = <0x0 0xfe180000 0x0 0x20>;
+	};
+
+	qos_pcie2x1: qos@fe190000 {
+		compatible = "syscon";
+		reg = <0x0 0xfe190000 0x0 0x20>;
+	};
+
+	qos_pcie3x1: qos@fe190080 {
+		compatible = "syscon";
+		reg = <0x0 0xfe190080 0x0 0x20>;
+	};
+
+	qos_pcie3x2: qos@fe190100 {
+		compatible = "syscon";
+		reg = <0x0 0xfe190100 0x0 0x20>;
+	};
+
+	qos_sata0: qos@fe190200 {
+		compatible = "syscon";
+		reg = <0x0 0xfe190200 0x0 0x20>;
+	};
+
+	qos_sata1: qos@fe190280 {
+		compatible = "syscon";
+		reg = <0x0 0xfe190280 0x0 0x20>;
+	};
+
+	qos_sata2: qos@fe190300 {
+		compatible = "syscon";
+		reg = <0x0 0xfe190300 0x0 0x20>;
+	};
+
+	qos_usb3_0: qos@fe190380 {
+		compatible = "syscon";
+		reg = <0x0 0xfe190380 0x0 0x20>;
+	};
+
+	qos_usb3_1: qos@fe190400 {
+		compatible = "syscon";
+		reg = <0x0 0xfe190400 0x0 0x20>;
+	};
+
+	qos_rkvdec: qos@fe198000 {
+		compatible = "syscon";
+		reg = <0x0 0xfe198000 0x0 0x20>;
+	};
+
+	qos_hdcp: qos@fe1a8000 {
+		compatible = "syscon";
+		reg = <0x0 0xfe1a8000 0x0 0x20>;
+	};
+
+	qos_vop_m0: qos@fe1a8080 {
+		compatible = "syscon";
+		reg = <0x0 0xfe1a8080 0x0 0x20>;
+	};
+
+	qos_vop_m1: qos@fe1a8100 {
+		compatible = "syscon";
+		reg = <0x0 0xfe1a8100 0x0 0x20>;
+	};
+
+	sdmmc2: dwmmc@fe000000 {
+		compatible = "rockchip,rk3568-dw-mshc",
+			     "rockchip,rk3288-dw-mshc";
+		reg = <0x0 0xfe000000 0x0 0x4000>;
+		interrupts = <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>;
+		max-frequency = <150000000>;
+		clocks = <&cru HCLK_SDMMC2>, <&cru CLK_SDMMC2>,
+			 <&cru SCLK_SDMMC2_DRV>, <&cru SCLK_SDMMC2_SAMPLE>;
+		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
+		fifo-depth = <0x100>;
+		resets = <&cru SRST_SDMMC2>;
+		reset-names = "reset";
+		status = "disabled";
+	};
+
+	dfi: dfi@fe230000 {
+		reg = <0x00 0xfe230000 0x00 0x400>;
+		compatible = "rockchip,rk3568-dfi";
+		rockchip,pmugrf = <&pmugrf>;
+		status = "disabled";
+	};
+
+	dmc: dmc {
+		compatible = "rockchip,rk3568-dmc";
+		interrupts = <GIC_SPI 10 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "complete";
+		devfreq-events = <&dfi>, <&nocp_cpu>;
+		clocks = <&scmi_clk 3>;
+		clock-names = "dmc_clk";
+		operating-points-v2 = <&dmc_opp_table>;
+		vop-bw-dmc-freq = <
+		/* min_bw(MB/s) max_bw(MB/s) freq(KHz) */
+			0	286	324000
+			287	99999	528000
+		>;
+		vop-frame-bw-dmc-freq = <
+		/* min_bw(MB/s) max_bw(MB/s) freq(KHz) */
+			0	620	324000
+			621	99999	780000
+		>;
+		cpu-bw-dmc-freq = <
+		/* min_bw(MB/s) max_bw(MB/s) freq(KHz) */
+			0	350	324000
+			351	400	528000
+			401	99999	780000
+		>;
+		upthreshold = <40>;
+		downdifferential = <20>;
+		system-status-level = <
+			/*system status         freq level*/
+			SYS_STATUS_NORMAL       DMC_FREQ_LEVEL_MID_HIGH
+			SYS_STATUS_REBOOT       DMC_FREQ_LEVEL_HIGH
+			SYS_STATUS_SUSPEND      DMC_FREQ_LEVEL_LOW
+			SYS_STATUS_VIDEO_4K     DMC_FREQ_LEVEL_MID_HIGH
+			SYS_STATUS_VIDEO_4K_10B DMC_FREQ_LEVEL_MID_HIGH
+			SYS_STATUS_BOOST        DMC_FREQ_LEVEL_HIGH
+			SYS_STATUS_ISP          DMC_FREQ_LEVEL_HIGH
+			SYS_STATUS_PERFORMANCE  DMC_FREQ_LEVEL_HIGH
+			SYS_STATUS_DUALVIEW     DMC_FREQ_LEVEL_HIGH
+		>;
+		auto-min-freq = <324000>;
+		auto-freq-en = <1>;
+		#cooling-cells = <2>;
+		status = "disabled";
+	};
+
+	dmc_fsp: dmc-fsp {
+		compatible = "rockchip,rk3568-dmc-fsp";
+
+		debug_print_level = <0>;
+		ddr3_params = <&ddr3_params>;
+		ddr4_params = <&ddr4_params>;
+		lpddr3_params = <&lpddr3_params>;
+		lpddr4_params = <&lpddr4_params>;
+		lpddr4x_params = <&lpddr4x_params>;
+
+		status = "okay";
+	};
+
+	dmc_opp_table: dmc-opp-table {
+		compatible = "operating-points-v2";
+
+		mbist-vmin = <825000 900000 950000>;
+		nvmem-cells = <&log_leakage>, <&core_pvtm>, <&mbist_vmin>, <&dmc_opp_info>;
+		nvmem-cell-names = "leakage", "pvtm", "mbist-vmin", "opp-info";
+		rockchip,max-volt = <1000000>;
+		rockchip,temp-hysteresis = <5000>;
+		rockchip,low-temp = <0>;
+		rockchip,low-temp-adjust-volt = <
+			/* MHz    MHz    uV */
+			   0      1560   75000
+		>;
+		rockchip,leakage-voltage-sel = <
+			1   80    0
+			81  254   1
+		>;
+		rockchip,pvtm-voltage-sel = <
+			0        84000   0
+			84001    100000  1
+		>;
+		rockchip,pvtm-ch = <0 5>;
+
+		opp-1560000000 {
+			opp-hz = /bits/ 64 <1560000000>;
+			opp-microvolt = <900000 900000 1000000>;
+			opp-microvolt-L0 = <900000 900000 1000000>;
+			opp-microvolt-L1 = <875000 875000 1000000>;
+		};
+	};
+
+	pcie2x1: pcie@fe260000 {
+		compatible = "rockchip,rk3568-pcie", "snps,dw-pcie";
+		#address-cells = <3>;
+		#size-cells = <2>;
+		bus-range = <0x0 0xf>;
+		clocks = <&cru ACLK_PCIE20_MST>, <&cru ACLK_PCIE20_SLV>,
+			 <&cru ACLK_PCIE20_DBI>, <&cru PCLK_PCIE20>,
+			 <&cru CLK_PCIE20_AUX_NDFT>;
+		clock-names = "aclk_mst", "aclk_slv",
+			      "aclk_dbi", "pclk", "aux";
+		device_type = "pci";
+		interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "sys", "pmc", "msg", "legacy", "err";
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0 0 0 7>;
+		interrupt-map = <0 0 0 1 &pcie2x1_intc 0>,
+				<0 0 0 2 &pcie2x1_intc 1>,
+				<0 0 0 3 &pcie2x1_intc 2>,
+				<0 0 0 4 &pcie2x1_intc 3>;
+		linux,pci-domain = <0>;
+		num-ib-windows = <6>;
+		num-viewport = <8>;
+		num-ob-windows = <2>;
+		max-link-speed = <2>;
+		msi-map = <0x0 &its 0x0 0x1000>;
+		num-lanes = <1>;
+		phys = <&combphy2_psq PHY_TYPE_PCIE>;
+		phy-names = "pcie-phy";
+		power-domains = <&power RK3568_PD_PIPE>;
+		ranges = <0x00000800 0x0 0xf4000000 0x0 0xf4000000 0x0 0x100000
+			  0x81000000 0x0 0xf4100000 0x0 0xf4100000 0x0 0x100000
+			  0x82000000 0x0 0xf4200000 0x0 0xf4200000 0x0 0x1e00000
+			  0xc3000000 0x3 0x00000000 0x3 0x00000000 0x0 0x40000000>;
+		reg = <0x3 0xc0000000 0x0 0x400000>,
+		      <0x0 0xfe260000 0x0 0x10000>;
+		reg-names = "pcie-dbi", "pcie-apb";
+		resets = <&cru SRST_PCIE20_POWERUP>;
+		reset-names = "pipe";
+		status = "disabled";
+
+		pcie2x1_intc: legacy-interrupt-controller {
+			interrupt-controller;
+			#address-cells = <0>;
+			#interrupt-cells = <1>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 72 IRQ_TYPE_EDGE_RISING>;
+		};
+	};
+
+	pcie3x1: pcie@fe270000 {
+		compatible = "rockchip,rk3568-pcie", "snps,dw-pcie";
+		#address-cells = <3>;
+		#size-cells = <2>;
+		bus-range = <0x10 0x1f>;
+		clocks = <&cru ACLK_PCIE30X1_MST>, <&cru ACLK_PCIE30X1_SLV>,
+			 <&cru ACLK_PCIE30X1_DBI>, <&cru PCLK_PCIE30X1>,
+			 <&cru CLK_PCIE30X1_AUX_NDFT>;
+		clock-names = "aclk_mst", "aclk_slv",
+			      "aclk_dbi", "pclk", "aux";
+		device_type = "pci";
+		interrupts = <GIC_SPI 160 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 159 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 158 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 157 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "sys", "pmc", "msg", "legacy", "err";
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0 0 0 7>;
+		interrupt-map = <0 0 0 1 &pcie3x1_intc 0>,
+				<0 0 0 2 &pcie3x1_intc 1>,
+				<0 0 0 3 &pcie3x1_intc 2>,
+				<0 0 0 4 &pcie3x1_intc 3>;
+		linux,pci-domain = <1>;
+		num-ib-windows = <6>;
+		num-ob-windows = <2>;
+		num-viewport = <8>;
+		max-link-speed = <3>;
+		msi-map = <0x1000 &its 0x1000 0x1000>;
+		num-lanes = <1>;
+		phys = <&pcie30phy>;
+		phy-names = "pcie-phy";
+		power-domains = <&power RK3568_PD_PIPE>;
+		ranges = <0x00000800 0x0 0xf2000000 0x0 0xf2000000 0x0 0x100000
+			  0x81000000 0x0 0xf2100000 0x0 0xf2100000 0x0 0x100000
+			  0x82000000 0x0 0xf2200000 0x0 0xf2200000 0x0 0x1e00000
+			  0xc3000000 0x3 0x40000000 0x3 0x40000000 0x0 0x40000000>;
+		reg = <0x3 0xc0400000 0x0 0x400000>,
+		      <0x0 0xfe270000 0x0 0x10000>;
+		reg-names = "pcie-dbi", "pcie-apb";
+		resets = <&cru SRST_PCIE30X1_POWERUP>;
+		reset-names = "pipe";
+		/* rockchip,bifurcation; lane1 when using 1+1 */
+		status = "disabled";
+
+		pcie3x1_intc: legacy-interrupt-controller {
+			interrupt-controller;
+			#address-cells = <0>;
+			#interrupt-cells = <1>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 157 IRQ_TYPE_EDGE_RISING>;
+		};
+	};
+
+	pcie3x2: pcie@fe280000 {
+		compatible = "rockchip,rk3568-pcie", "snps,dw-pcie";
+		#address-cells = <3>;
+		#size-cells = <2>;
+		bus-range = <0x20 0x2f>;
+		clocks = <&cru ACLK_PCIE30X2_MST>, <&cru ACLK_PCIE30X2_SLV>,
+			 <&cru ACLK_PCIE30X2_DBI>, <&cru PCLK_PCIE30X2>,
+			 <&cru CLK_PCIE30X2_AUX_NDFT>;
+		clock-names = "aclk_mst", "aclk_slv",
+			      "aclk_dbi", "pclk", "aux";
+		device_type = "pci";
+		interrupts = <GIC_SPI 165 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 164 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 163 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 162 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 161 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "sys", "pmc", "msg", "legacy", "err";
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0 0 0 7>;
+		interrupt-map = <0 0 0 1 &pcie3x2_intc 0>,
+				<0 0 0 2 &pcie3x2_intc 1>,
+				<0 0 0 3 &pcie3x2_intc 2>,
+				<0 0 0 4 &pcie3x2_intc 3>;
+		linux,pci-domain = <2>;
+		num-ib-windows = <6>;
+		num-viewport = <8>;
+		num-ob-windows = <2>;
+		max-link-speed = <3>;
+		msi-map = <0x2000 &its 0x2000 0x1000>;
+		num-lanes = <2>;
+		phys = <&pcie30phy>;
+		phy-names = "pcie-phy";
+		power-domains = <&power RK3568_PD_PIPE>;
+		ranges = <0x00000800 0x0 0xf0000000 0x0 0xf0000000 0x0 0x100000
+			  0x81000000 0x0 0xf0100000 0x0 0xf0100000 0x0 0x100000
+			  0x82000000 0x0 0xf0200000 0x0 0xf0200000 0x0 0x1e00000
+			  0xc3000000 0x3 0x80000000 0x3 0x80000000 0x0 0x40000000>;
+		reg = <0x3 0xc0800000 0x0 0x400000>,
+		      <0x0 0xfe280000 0x0 0x10000>;
+		reg-names = "pcie-dbi", "pcie-apb";
+		resets = <&cru SRST_PCIE30X2_POWERUP>;
+		reset-names = "pipe";
+		/* rockchip,bifurcation; lane0 when using 1+1 */
+		status = "disabled";
+
+		pcie3x2_intc: legacy-interrupt-controller {
+			interrupt-controller;
+			#address-cells = <0>;
+			#interrupt-cells = <1>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 162 IRQ_TYPE_EDGE_RISING>;
+		};
+	};
+
+	gmac_uio0: uio@fe2a0000 {
+		compatible = "rockchip,uio-gmac";
+		reg = <0x0 0xfe2a0000 0x0 0x10000>;
+		rockchip,ethernet = <&gmac0>;
+		status = "disabled";
+	};
+
+	gmac0: ethernet@fe2a0000 {
+		compatible = "rockchip,rk3568-gmac", "snps,dwmac-4.20a";
+		reg = <0x0 0xfe2a0000 0x0 0x10000>;
+		interrupts = <GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "macirq", "eth_wake_irq";
+		rockchip,grf = <&grf>;
+		clocks = <&cru SCLK_GMAC0>, <&cru SCLK_GMAC0_RX_TX>,
+			 <&cru SCLK_GMAC0_RX_TX>, <&cru CLK_MAC0_REFOUT>,
+			 <&cru ACLK_GMAC0>, <&cru PCLK_GMAC0>,
+			 <&cru SCLK_GMAC0_RX_TX>, <&cru CLK_GMAC0_PTP_REF>,
+			 <&cru PCLK_XPCS>, <&cru CLK_XPCS_EEE>;
+		clock-names = "stmmaceth", "mac_clk_rx",
+			      "mac_clk_tx", "clk_mac_refout",
+			      "aclk_mac", "pclk_mac",
+			      "clk_mac_speed", "ptp_ref",
+			      "pclk_xpcs", "clk_xpcs_eee";
+		resets = <&cru SRST_A_GMAC0>;
+		reset-names = "stmmaceth";
+
+		snps,mixed-burst;
+		snps,tso;
+
+		snps,axi-config = <&gmac0_stmmac_axi_setup>;
+		snps,mtl-rx-config = <&gmac0_mtl_rx_setup>;
+		snps,mtl-tx-config = <&gmac0_mtl_tx_setup>;
+		status = "disabled";
+
+		mdio0: mdio {
+			compatible = "snps,dwmac-mdio";
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+		};
+
+		gmac0_stmmac_axi_setup: stmmac-axi-config {
+			snps,wr_osr_lmt = <4>;
+			snps,rd_osr_lmt = <8>;
+			snps,blen = <0 0 0 0 16 8 4>;
+		};
+
+		gmac0_mtl_rx_setup: rx-queues-config {
+			snps,rx-queues-to-use = <1>;
+			queue0 {};
+		};
+
+		gmac0_mtl_tx_setup: tx-queues-config {
+			snps,tx-queues-to-use = <1>;
+			queue0 {};
+		};
+	};
+
+	sdmmc0: dwmmc@fe2b0000 {
+		compatible = "rockchip,rk3568-dw-mshc",
+			     "rockchip,rk3288-dw-mshc";
+		reg = <0x0 0xfe2b0000 0x0 0x4000>;
+		interrupts = <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>;
+		max-frequency = <150000000>;
+		clocks = <&cru HCLK_SDMMC0>, <&cru CLK_SDMMC0>,
+			 <&cru SCLK_SDMMC0_DRV>, <&cru SCLK_SDMMC0_SAMPLE>;
+		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
+		fifo-depth = <0x100>;
+		resets = <&cru SRST_SDMMC0>;
+		reset-names = "reset";
+		status = "disabled";
+	};
+
+	sdmmc1: dwmmc@fe2c0000 {
+		compatible = "rockchip,rk3568-dw-mshc",
+			     "rockchip,rk3288-dw-mshc";
+		reg = <0x0 0xfe2c0000 0x0 0x4000>;
+		interrupts = <GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH>;
+		max-frequency = <150000000>;
+		clocks = <&cru HCLK_SDMMC1>, <&cru CLK_SDMMC1>,
+			 <&cru SCLK_SDMMC1_DRV>, <&cru SCLK_SDMMC1_SAMPLE>;
+		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
+		fifo-depth = <0x100>;
+		resets = <&cru SRST_SDMMC1>;
+		reset-names = "reset";
+		status = "disabled";
+	};
+
+	sfc: spi@fe300000 {
+		compatible = "rockchip,sfc";
+		reg = <0x0 0xfe300000 0x0 0x4000>;
+		interrupts = <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_SFC>, <&cru HCLK_SFC>;
+		clock-names = "clk_sfc", "hclk_sfc";
+		assigned-clocks = <&cru SCLK_SFC>;
+		assigned-clock-rates = <100000000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "disabled";
+	};
+
+	sdhci: sdhci@fe310000 {
+		compatible = "rockchip,rk3568-dwcmshc", "rockchip,dwcmshc-sdhci";
+		reg = <0x0 0xfe310000 0x0 0x10000>;
+		interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>;
+		assigned-clocks = <&cru BCLK_EMMC>, <&cru TCLK_EMMC>,
+				  <&cru CCLK_EMMC>;
+		assigned-clock-rates = <200000000>, <24000000>, <200000000>;
+		clocks = <&cru CCLK_EMMC>, <&cru HCLK_EMMC>,
+			 <&cru ACLK_EMMC>, <&cru BCLK_EMMC>,
+			 <&cru TCLK_EMMC>;
+		clock-names = "core", "bus", "axi", "block", "timer";
+		resets = <&cru SRST_C_EMMC>, <&cru SRST_H_EMMC>,
+			 <&cru SRST_A_EMMC>, <&cru SRST_B_EMMC>,
+			 <&cru SRST_T_EMMC>;
+		reset-names = "core", "bus", "axi", "block", "timer";
+		status = "disabled";
+	};
+
+	nandc0: nandc@fe330000 {
+		compatible = "rockchip,rk-nandc-v9";
+		reg = <0x0 0xfe330000 0x0 0x4000>;
+		interrupts = <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
+		nandc_id = <0>;
+		clocks = <&cru NCLK_NANDC>, <&cru HCLK_NANDC>;
+		clock-names = "clk_nandc", "hclk_nandc";
+		status = "disabled";
+	};
+
+	crypto: crypto@fe380000 {
+		compatible = "rockchip,rk3568-crypto";
+		reg = <0x0 0xfe380000 0x0 0x4000>;
+		interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_CRYPTO_NS>, <&cru HCLK_CRYPTO_NS>,
+			<&cru CLK_CRYPTO_NS_CORE>, <&cru CLK_CRYPTO_NS_PKA>;
+		clock-names = "aclk", "hclk", "sclk", "apb_pclk";
+		assigned-clocks = <&cru CLK_CRYPTO_NS_CORE>;
+		assigned-clock-rates = <200000000>;
+		resets = <&cru SRST_CRYPTO_NS_CORE>;
+		reset-names = "crypto-rst";
+		status = "disabled";
+	};
+
+	rng: rng@fe388000 {
+		compatible = "rockchip,cryptov2-rng";
+		reg = <0x0 0xfe388000 0x0 0x2000>;
+		clocks = <&cru CLK_TRNG_NS>, <&cru HCLK_TRNG_NS>;
+		clock-names = "clk_trng", "hclk_trng";
+		resets = <&cru SRST_TRNG_NS>;
+		reset-names = "reset";
+		status = "disabled";
+	};
+
+	otp: otp@fe38c000 {
+		compatible = "rockchip,rk3568-otp";
+		reg = <0x0 0xfe38c000 0x0 0x4000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		clocks = <&cru CLK_OTPC_NS_USR>, <&cru CLK_OTPC_NS_SBPI>,
+			 <&cru PCLK_OTPC_NS>, <&cru PCLK_OTPPHY>;
+		clock-names = "usr", "sbpi", "apb", "phy";
+		resets = <&cru SRST_OTPPHY>;
+		reset-names = "otp_phy";
+
+		/* Data cells */
+		cpu_code: cpu-code@2 {
+			reg = <0x02 0x2>;
+		};
+		otp_cpu_version: cpu-version@8 {
+			reg = <0x08 0x1>;
+			bits = <3 3>;
+		};
+		mbist_vmin: mbist-vmin@9 {
+			reg = <0x09 0x1>;
+			bits = <0 4>;
+		};
+		otp_id: id@a {
+			reg = <0x0a 0x10>;
+		};
+		cpu_leakage: cpu-leakage@1a {
+			reg = <0x1a 0x1>;
+		};
+		log_leakage: log-leakage@1b {
+			reg = <0x1b 0x1>;
+		};
+		npu_leakage: npu-leakage@1c {
+			reg = <0x1c 0x1>;
+		};
+		gpu_leakage: gpu-leakage@1d {
+			reg = <0x1d 0x1>;
+		};
+		core_pvtm:core-pvtm@2a {
+			reg = <0x2a 0x2>;
+		};
+		performance:performance@22 {
+			reg = <0x22 0x1>;
+			bits = <0 4>;
+		};
+		cpu_tsadc_trim_l: cpu-tsadc-trim-l@2e {
+			reg = <0x2e 0x1>;
+		};
+		cpu_tsadc_trim_h: cpu-tsadc-trim-h@2f {
+			reg = <0x2f 0x1>;
+			bits = <0 4>;
+		};
+		gpu_tsadc_trim_l: npu-tsadc-trim-l@30 {
+			reg = <0x30 0x1>;
+		};
+		gpu_tsadc_trim_h: npu-tsadc-trim-h@31 {
+			reg = <0x31 0x1>;
+			bits = <0 4>;
+		};
+		tsadc_trim_base_frac: tsadc-trim-base-frac@31 {
+			reg = <0x31 0x1>;
+			bits = <4 4>;
+		};
+		tsadc_trim_base: tsadc-trim-base@32 {
+			reg = <0x32 0x1>;
+		};
+		cpu_opp_info: cpu-opp-info@36 {
+			reg = <0x36 0x6>;
+		};
+		gpu_opp_info: gpu-opp-info@3c {
+			reg = <0x3c 0x6>;
+		};
+		npu_opp_info: npu-opp-info@42 {
+			reg = <0x42 0x6>;
+		};
+		dmc_opp_info: dmc-opp-info@48 {
+			reg = <0x48 0x6>;
+		};
+	};
+
+	i2s0_8ch: i2s@fe400000 {
+		compatible = "rockchip,rk3568-i2s-tdm";
+		reg = <0x0 0xfe400000 0x0 0x1000>;
+		interrupts = <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru MCLK_I2S0_8CH_TX>, <&cru MCLK_I2S0_8CH_RX>, <&cru HCLK_I2S0_8CH>;
+		clock-names = "mclk_tx", "mclk_rx", "hclk";
+		dmas = <&dmac1 0>;
+		dma-names = "tx";
+		resets = <&cru SRST_M_I2S0_8CH_TX>, <&cru SRST_M_I2S0_8CH_RX>;
+		reset-names = "tx-m", "rx-m";
+		rockchip,cru = <&cru>;
+		rockchip,grf = <&grf>;
+		rockchip,playback-only;
+		#sound-dai-cells = <0>;
+		status = "disabled";
+	};
+
+	i2s1_8ch: i2s@fe410000 {
+		compatible = "rockchip,rk3568-i2s-tdm";
+		reg = <0x0 0xfe410000 0x0 0x1000>;
+		interrupts = <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru MCLK_I2S1_8CH_TX>, <&cru MCLK_I2S1_8CH_RX>, <&cru HCLK_I2S1_8CH>;
+		clock-names = "mclk_tx", "mclk_rx", "hclk";
+		dmas = <&dmac1 2>, <&dmac1 3>;
+		dma-names = "tx", "rx";
+		resets = <&cru SRST_M_I2S1_8CH_TX>, <&cru SRST_M_I2S1_8CH_RX>;
+		reset-names = "tx-m", "rx-m";
+		rockchip,cru = <&cru>;
+		rockchip,grf = <&grf>;
+		#sound-dai-cells = <0>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s1m0_sclktx
+			     &i2s1m0_sclkrx
+			     &i2s1m0_lrcktx
+			     &i2s1m0_lrckrx
+			     &i2s1m0_sdi0
+			     &i2s1m0_sdi1
+			     &i2s1m0_sdi2
+			     &i2s1m0_sdi3
+			     &i2s1m0_sdo0
+			     &i2s1m0_sdo1
+			     &i2s1m0_sdo2
+			     &i2s1m0_sdo3>;
+		status = "disabled";
+	};
+
+	i2s2_2ch: i2s@fe420000 {
+		compatible = "rockchip,rk3568-i2s-tdm";
+		reg = <0x0 0xfe420000 0x0 0x1000>;
+		interrupts = <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru MCLK_I2S2_2CH>, <&cru MCLK_I2S2_2CH>, <&cru HCLK_I2S2_2CH>;
+		clock-names = "mclk_tx", "mclk_rx", "hclk";
+		dmas = <&dmac1 4>, <&dmac1 5>;
+		dma-names = "tx", "rx";
+		rockchip,cru = <&cru>;
+		rockchip,grf = <&grf>;
+		rockchip,clk-trcm = <1>;
+		#sound-dai-cells = <0>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s2m0_sclktx
+			     &i2s2m0_lrcktx
+			     &i2s2m0_sdi
+			     &i2s2m0_sdo>;
+		status = "disabled";
+	};
+
+	i2s3_2ch: i2s@fe430000 {
+		compatible = "rockchip,rk3568-i2s-tdm";
+		reg = <0x0 0xfe430000 0x0 0x1000>;
+		interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru MCLK_I2S3_2CH_TX>, <&cru MCLK_I2S3_2CH_RX>, <&cru HCLK_I2S3_2CH>;
+		clock-names = "mclk_tx", "mclk_rx", "hclk";
+		dmas = <&dmac1 6>, <&dmac1 7>;
+		dma-names = "tx", "rx";
+		resets = <&cru SRST_M_I2S3_2CH_TX>, <&cru SRST_M_I2S3_2CH_RX>;
+		reset-names = "tx-m", "rx-m";
+		rockchip,cru = <&cru>;
+		rockchip,grf = <&grf>;
+		rockchip,clk-trcm = <1>;
+		#sound-dai-cells = <0>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s3m0_sclk
+			     &i2s3m0_lrck
+			     &i2s3m0_sdi
+			     &i2s3m0_sdo>;
+		status = "disabled";
+	};
+
+	pdm: pdm@fe440000 {
+		compatible = "rockchip,rk3568-pdm", "rockchip,pdm";
+		reg = <0x0 0xfe440000 0x0 0x1000>;
+		clocks = <&cru MCLK_PDM>, <&cru HCLK_PDM>;
+		clock-names = "pdm_clk", "pdm_hclk";
+		dmas = <&dmac1 9>;
+		dma-names = "rx";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pdmm0_clk
+			     &pdmm0_clk1
+			     &pdmm0_sdi0
+			     &pdmm0_sdi1
+			     &pdmm0_sdi2
+			     &pdmm0_sdi3>;
+		#sound-dai-cells = <0>;
+		status = "disabled";
+	};
+
+	vad: vad@fe450000 {
+		compatible = "rockchip,rk3568-vad";
+		reg = <0x0 0xfe450000 0x0 0x10000>;
+		reg-names = "vad";
+		clocks = <&cru HCLK_VAD>;
+		clock-names = "hclk";
+		interrupts = <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>;
+		rockchip,audio-src = <0>;
+		rockchip,det-channel = <0>;
+		rockchip,mode = <0>;
+		#sound-dai-cells = <0>;
+		status = "disabled";
+	};
+
+	spdif_8ch: spdif@fe460000 {
+		compatible = "rockchip,rk3568-spdif";
+		reg = <0x0 0xfe460000 0x0 0x1000>;
+		interrupts = <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>;
+		dmas = <&dmac1 1>;
+		dma-names = "tx";
+		clock-names = "mclk", "hclk";
+		clocks = <&cru MCLK_SPDIF_8CH>, <&cru HCLK_SPDIF_8CH>;
+		#sound-dai-cells = <0>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&spdifm0_tx>;
+		status = "disabled";
+	};
+
+	audpwm: audpwm@fe470000 {
+		compatible = "rockchip,rk3568-audio-pwm", "rockchip,audio-pwm-v1";
+		reg = <0x0 0xfe470000 0x0 0x1000>;
+		clocks = <&cru SCLK_AUDPWM>, <&cru HCLK_AUDPWM>;
+		clock-names = "clk", "hclk";
+		dmas = <&dmac1 8>;
+		dma-names = "tx";
+		#sound-dai-cells = <0>;
+		rockchip,sample-width-bits = <11>;
+		rockchip,interpolat-points = <1>;
+		status = "disabled";
+	};
+
+	dig_acodec: codec-digital@fe478000 {
+		compatible = "rockchip,rk3568-codec-digital", "rockchip,codec-digital-v1";
+		reg = <0x0 0xfe478000 0x0 0x1000>;
+		clocks = <&cru CLK_ACDCDIG_ADC>, <&cru CLK_ACDCDIG_DAC>,
+			 <&cru CLK_ACDCDIG_I2C>, <&cru HCLK_ACDCDIG>;
+		clock-names = "adc", "dac", "i2c", "pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&acodec_pins>;
+		resets = <&cru SRST_ACDCDIG>;
+		reset-names = "reset" ;
+		rockchip,grf = <&grf>;
+		#sound-dai-cells = <0>;
+		status = "disabled";
+	};
+
+	dmac0: dmac@fe530000 {
+		compatible = "arm,pl330", "arm,primecell";
+		reg = <0x0 0xfe530000 0x0 0x4000>;
+		interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_BUS>;
+		clock-names = "apb_pclk";
+		#dma-cells = <1>;
+		arm,pl330-periph-burst;
+	};
+
+	dmac1: dmac@fe550000 {
+		compatible = "arm,pl330", "arm,primecell";
+		reg = <0x0 0xfe550000 0x0 0x4000>;
+		interrupts = <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_BUS>;
+		clock-names = "apb_pclk";
+		#dma-cells = <1>;
+		arm,pl330-periph-burst;
+	};
+
+	scr: rkscr@fe560000 {
+		compatible = "rockchip-scr";
+		reg = <0x0 0xfe560000 0x0 0x10000>;
+		interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&scr_pins>;
+		clocks = <&cru PCLK_SCR>;
+		clock-names = "g_pclk_sim_card";
+		status = "disabled";
+	};
+
+	can0: can@fe570000 {
+		compatible = "rockchip,rk3568-can-2.0";
+		reg = <0x0 0xfe570000 0x0 0x1000>;
+		interrupts = <GIC_SPI 1 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru CLK_CAN0>, <&cru PCLK_CAN0>;
+		clock-names = "baudclk", "apb_pclk";
+		resets = <&cru SRST_CAN0>, <&cru SRST_P_CAN0>;
+		reset-names = "can", "can-apb";
+		tx-fifo-depth = <1>;
+		rx-fifo-depth = <6>;
+		status = "disabled";
+	};
+
+	can1: can@fe580000 {
+		compatible = "rockchip,rk3568-can-2.0";
+		reg = <0x0 0xfe580000 0x0 0x1000>;
+		interrupts = <GIC_SPI 2 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru CLK_CAN1>, <&cru PCLK_CAN1>;
+		clock-names = "baudclk", "apb_pclk";
+		resets = <&cru SRST_CAN1>, <&cru SRST_P_CAN1>;
+		reset-names = "can", "can-apb";
+		tx-fifo-depth = <1>;
+		rx-fifo-depth = <6>;
+		status = "disabled";
+	};
+
+	can2: can@fe590000 {
+		compatible = "rockchip,rk3568-can-2.0";
+		reg = <0x0 0xfe590000 0x0 0x1000>;
+		interrupts = <GIC_SPI 3 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru CLK_CAN2>, <&cru PCLK_CAN2>;
+		clock-names = "baudclk", "apb_pclk";
+		resets = <&cru SRST_CAN2>, <&cru SRST_P_CAN2>;
+		reset-names = "can", "can-apb";
+		tx-fifo-depth = <1>;
+		rx-fifo-depth = <6>;
+		status = "disabled";
+	};
+
+	i2c1: i2c@fe5a0000 {
+		compatible = "rockchip,rk3399-i2c";
+		reg = <0x0 0xfe5a0000 0x0 0x1000>;
+		clocks = <&cru CLK_I2C1>, <&cru PCLK_I2C1>;
+		clock-names = "i2c", "pclk";
+		interrupts = <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_xfer>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "disabled";
+	};
+
+	i2c2: i2c@fe5b0000 {
+		compatible = "rockchip,rk3399-i2c";
+		reg = <0x0 0xfe5b0000 0x0 0x1000>;
+		clocks = <&cru CLK_I2C2>, <&cru PCLK_I2C2>;
+		clock-names = "i2c", "pclk";
+		interrupts = <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2m0_xfer>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "disabled";
+	};
+
+	i2c3: i2c@fe5c0000 {
+		compatible = "rockchip,rk3399-i2c";
+		reg = <0x0 0xfe5c0000 0x0 0x1000>;
+		clocks = <&cru CLK_I2C3>, <&cru PCLK_I2C3>;
+		clock-names = "i2c", "pclk";
+		interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3m0_xfer>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "disabled";
+	};
+
+	i2c4: i2c@fe5d0000 {
+		compatible = "rockchip,rk3399-i2c";
+		reg = <0x0 0xfe5d0000 0x0 0x1000>;
+		clocks = <&cru CLK_I2C4>, <&cru PCLK_I2C4>;
+		clock-names = "i2c", "pclk";
+		interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c4m0_xfer>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "disabled";
+	};
+
+	i2c5: i2c@fe5e0000 {
+		compatible = "rockchip,rk3399-i2c";
+		reg = <0x0 0xfe5e0000 0x0 0x1000>;
+		clocks = <&cru CLK_I2C5>, <&cru PCLK_I2C5>;
+		clock-names = "i2c", "pclk";
+		interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c5m0_xfer>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "disabled";
+	};
+
+	rktimer: timer@fe5f0000 {
+		compatible = "rockchip,rk3568-timer", "rockchip,rk3288-timer";
+		reg = <0x0 0xfe5f0000 0x0 0x1000>;
+		interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru PCLK_TIMER>, <&cru CLK_TIMER0>;
+		clock-names = "pclk", "timer";
+	};
+
+	wdt: watchdog@fe600000 {
+		compatible = "snps,dw-wdt";
+		reg = <0x0 0xfe600000 0x0 0x100>;
+		clocks = <&cru TCLK_WDT_NS>, <&cru PCLK_WDT_NS>;
+		clock-names = "tclk", "pclk";
+		interrupts = <GIC_SPI 149 IRQ_TYPE_LEVEL_HIGH>;
+		status = "okay";
+	};
+
+	spi0: spi@fe610000 {
+		compatible = "rockchip,rk3066-spi";
+		reg = <0x0 0xfe610000 0x0 0x1000>;
+		interrupts = <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&cru CLK_SPI0>, <&cru PCLK_SPI0>;
+		clock-names = "spiclk", "apb_pclk";
+		dmas = <&dmac0 20>, <&dmac0 21>;
+		dma-names = "tx", "rx";
+		pinctrl-names = "default", "high_speed";
+		pinctrl-0 = <&spi0m0_cs0 &spi0m0_cs1 &spi0m0_pins>;
+		pinctrl-1 = <&spi0m0_cs0 &spi0m0_cs1 &spi0m0_pins_hs>;
+		num-cs = <2>;
+		status = "disabled";
+	};
+
+	spi1: spi@fe620000 {
+		compatible = "rockchip,rk3066-spi";
+		reg = <0x0 0xfe620000 0x0 0x1000>;
+		interrupts = <GIC_SPI 104 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&cru CLK_SPI1>, <&cru PCLK_SPI1>;
+		clock-names = "spiclk", "apb_pclk";
+		dmas = <&dmac0 22>, <&dmac0 23>;
+		dma-names = "tx", "rx";
+		pinctrl-names = "default", "high_speed";
+		pinctrl-0 = <&spi1m0_cs0 &spi1m0_cs1 &spi1m0_pins>;
+		pinctrl-1 = <&spi1m0_cs0 &spi1m0_cs1 &spi1m0_pins_hs>;
+		num-cs = <2>;
+		status = "disabled";
+	};
+
+	spi2: spi@fe630000 {
+		compatible = "rockchip,rk3066-spi";
+		reg = <0x0 0xfe630000 0x0 0x1000>;
+		interrupts = <GIC_SPI 105 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&cru CLK_SPI2>, <&cru PCLK_SPI2>;
+		clock-names = "spiclk", "apb_pclk";
+		dmas = <&dmac0 24>, <&dmac0 25>;
+		dma-names = "tx", "rx";
+		pinctrl-names = "default", "high_speed";
+		pinctrl-0 = <&spi2m0_cs0 &spi2m0_cs1 &spi2m0_pins>;
+		pinctrl-1 = <&spi2m0_cs0 &spi2m0_cs1 &spi2m0_pins_hs>;
+		num-cs = <2>;
+		status = "disabled";
+	};
+
+	spi3: spi@fe640000 {
+		compatible = "rockchip,rk3066-spi";
+		reg = <0x0 0xfe640000 0x0 0x1000>;
+		interrupts = <GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&cru CLK_SPI3>, <&cru PCLK_SPI3>;
+		clock-names = "spiclk", "apb_pclk";
+		dmas = <&dmac0 26>, <&dmac0 27>;
+		dma-names = "tx", "rx";
+		pinctrl-names = "default", "high_speed";
+		pinctrl-0 = <&spi3m0_cs0 &spi3m0_cs1 &spi3m0_pins>;
+		pinctrl-1 = <&spi3m0_cs0 &spi3m0_cs1 &spi3m0_pins_hs>;
+		num-cs = <2>;
+		status = "disabled";
+	};
+
+	uart1: serial@fe650000 {
+		compatible = "rockchip,rk3568-uart", "snps,dw-apb-uart";
+		reg = <0x0 0xfe650000 0x0 0x100>;
+		interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_UART1>, <&cru PCLK_UART1>;
+		clock-names = "baudclk", "apb_pclk";
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		dmas = <&dmac0 2>, <&dmac0 3>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart1m0_xfer>;
+		status = "disabled";
+	};
+
+	uart2: serial@fe660000 {
+		compatible = "rockchip,rk3568-uart", "snps,dw-apb-uart";
+		reg = <0x0 0xfe660000 0x0 0x100>;
+		interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_UART2>, <&cru PCLK_UART2>;
+		clock-names = "baudclk", "apb_pclk";
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		dmas = <&dmac0 4>, <&dmac0 5>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart2m0_xfer>;
+		status = "disabled";
+	};
+
+	uart3: serial@fe670000 {
+		compatible = "rockchip,rk3568-uart", "snps,dw-apb-uart";
+		reg = <0x0 0xfe670000 0x0 0x100>;
+		interrupts = <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_UART3>, <&cru PCLK_UART3>;
+		clock-names = "baudclk", "apb_pclk";
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		dmas = <&dmac0 6>, <&dmac0 7>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart3m0_xfer>;
+		status = "disabled";
+	};
+
+	uart4: serial@fe680000 {
+		compatible = "rockchip,rk3568-uart", "snps,dw-apb-uart";
+		reg = <0x0 0xfe680000 0x0 0x100>;
+		interrupts = <GIC_SPI 120 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_UART4>, <&cru PCLK_UART4>;
+		clock-names = "baudclk", "apb_pclk";
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		dmas = <&dmac0 8>, <&dmac0 9>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart4m0_xfer>;
+		status = "disabled";
+	};
+
+	uart5: serial@fe690000 {
+		compatible = "rockchip,rk3568-uart", "snps,dw-apb-uart";
+		reg = <0x0 0xfe690000 0x0 0x100>;
+		interrupts = <GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_UART5>, <&cru PCLK_UART5>;
+		clock-names = "baudclk", "apb_pclk";
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		dmas = <&dmac0 10>, <&dmac0 11>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart5m0_xfer>;
+		status = "disabled";
 	};
 
-	qos_pcie3x1: qos@fe190080 {
-		compatible = "rockchip,rk3568-qos", "syscon";
-		reg = <0x0 0xfe190080 0x0 0x20>;
+	uart6: serial@fe6a0000 {
+		compatible = "rockchip,rk3568-uart", "snps,dw-apb-uart";
+		reg = <0x0 0xfe6a0000 0x0 0x100>;
+		interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_UART6>, <&cru PCLK_UART6>;
+		clock-names = "baudclk", "apb_pclk";
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		dmas = <&dmac0 12>, <&dmac0 13>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart6m0_xfer>;
+		status = "disabled";
 	};
 
-	qos_pcie3x2: qos@fe190100 {
-		compatible = "rockchip,rk3568-qos", "syscon";
-		reg = <0x0 0xfe190100 0x0 0x20>;
+	uart7: serial@fe6b0000 {
+		compatible = "rockchip,rk3568-uart", "snps,dw-apb-uart";
+		reg = <0x0 0xfe6b0000 0x0 0x100>;
+		interrupts = <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_UART7>, <&cru PCLK_UART7>;
+		clock-names = "baudclk", "apb_pclk";
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		dmas = <&dmac0 14>, <&dmac0 15>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart7m0_xfer>;
+		status = "disabled";
 	};
 
-	qos_sata0: qos@fe190200 {
-		compatible = "rockchip,rk3568-qos", "syscon";
-		reg = <0x0 0xfe190200 0x0 0x20>;
+	uart8: serial@fe6c0000 {
+		compatible = "rockchip,rk3568-uart", "snps,dw-apb-uart";
+		reg = <0x0 0xfe6c0000 0x0 0x100>;
+		interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_UART8>, <&cru PCLK_UART8>;
+		clock-names = "baudclk", "apb_pclk";
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		dmas = <&dmac0 16>, <&dmac0 17>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart8m0_xfer>;
+		status = "disabled";
 	};
 
-	pcie30_phy_grf: syscon@fdcb8000 {
-		compatible = "rockchip,rk3568-pcie3-phy-grf", "syscon";
-		reg = <0x0 0xfdcb8000 0x0 0x10000>;
+	uart9: serial@fe6d0000 {
+		compatible = "rockchip,rk3568-uart", "snps,dw-apb-uart";
+		reg = <0x0 0xfe6d0000 0x0 0x100>;
+		interrupts = <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_UART9>, <&cru PCLK_UART9>;
+		clock-names = "baudclk", "apb_pclk";
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		dmas = <&dmac0 18>, <&dmac0 19>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart9m0_xfer>;
+		status = "disabled";
 	};
 
-	pcie30phy: phy@fe8c0000 {
-		compatible = "rockchip,rk3568-pcie3-phy";
-		reg = <0x0 0xfe8c0000 0x0 0x20000>;
-		#phy-cells = <0>;
-		clocks = <&pmucru CLK_PCIE30PHY_REF_M>, <&pmucru CLK_PCIE30PHY_REF_N>,
-			 <&cru PCLK_PCIE30PHY>;
-		clock-names = "refclk_m", "refclk_n", "pclk";
-		resets = <&cru SRST_PCIE30PHY>;
-		reset-names = "phy";
-		rockchip,phy-grf = <&pcie30_phy_grf>;
+	pwm4: pwm@fe6e0000 {
+		compatible = "rockchip,rk3568-pwm", "rockchip,rk3328-pwm";
+		reg = <0x0 0xfe6e0000 0x0 0x10>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm4_pins>;
+		clocks = <&cru CLK_PWM1>, <&cru PCLK_PWM1>;
+		clock-names = "pwm", "pclk";
 		status = "disabled";
 	};
 
-	pcie3x1: pcie@fe270000 {
-		compatible = "rockchip,rk3568-pcie";
-		#address-cells = <3>;
-		#size-cells = <2>;
-		bus-range = <0x0 0xf>;
-		clocks = <&cru ACLK_PCIE30X1_MST>, <&cru ACLK_PCIE30X1_SLV>,
-			 <&cru ACLK_PCIE30X1_DBI>, <&cru PCLK_PCIE30X1>,
-			 <&cru CLK_PCIE30X1_AUX_NDFT>;
-		clock-names = "aclk_mst", "aclk_slv",
-			      "aclk_dbi", "pclk", "aux";
-		device_type = "pci";
-		interrupts = <GIC_SPI 160 IRQ_TYPE_LEVEL_HIGH>,
-			     <GIC_SPI 159 IRQ_TYPE_LEVEL_HIGH>,
-			     <GIC_SPI 158 IRQ_TYPE_LEVEL_HIGH>,
-			     <GIC_SPI 157 IRQ_TYPE_LEVEL_HIGH>,
-			     <GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>;
-		interrupt-names = "sys", "pmc", "msg", "legacy", "err";
-		#interrupt-cells = <1>;
-		interrupt-map-mask = <0 0 0 7>;
-		interrupt-map = <0 0 0 1 &pcie3x1_intc 0>,
-				<0 0 0 2 &pcie3x1_intc 1>,
-				<0 0 0 3 &pcie3x1_intc 2>,
-				<0 0 0 4 &pcie3x1_intc 3>;
-		linux,pci-domain = <1>;
-		num-ib-windows = <6>;
-		num-ob-windows = <2>;
-		max-link-speed = <3>;
-		msi-map = <0x0 &gic 0x1000 0x1000>;
-		num-lanes = <1>;
-		phys = <&pcie30phy>;
-		phy-names = "pcie-phy";
-		power-domains = <&power RK3568_PD_PIPE>;
-		reg = <0x3 0xc0400000 0x0 0x00400000>,
-		      <0x0 0xfe270000 0x0 0x00010000>,
-		      <0x0 0xf2000000 0x0 0x00100000>;
-		ranges = <0x01000000 0x0 0xf2100000 0x0 0xf2100000 0x0 0x00100000>,
-			 <0x02000000 0x0 0xf2200000 0x0 0xf2200000 0x0 0x01e00000>,
-			 <0x03000000 0x0 0x40000000 0x3 0x40000000 0x0 0x40000000>;
-		reg-names = "dbi", "apb", "config";
-		resets = <&cru SRST_PCIE30X1_POWERUP>;
-		reset-names = "pipe";
-		/* bifurcation; lane1 when using 1+1 */
+	pwm5: pwm@fe6e0010 {
+		compatible = "rockchip,rk3568-pwm", "rockchip,rk3328-pwm";
+		reg = <0x0 0xfe6e0010 0x0 0x10>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm5_pins>;
+		clocks = <&cru CLK_PWM1>, <&cru PCLK_PWM1>;
+		clock-names = "pwm", "pclk";
 		status = "disabled";
+	};
 
-		pcie3x1_intc: legacy-interrupt-controller {
-			interrupt-controller;
-			#address-cells = <0>;
-			#interrupt-cells = <1>;
-			interrupt-parent = <&gic>;
-			interrupts = <GIC_SPI 157 IRQ_TYPE_EDGE_RISING>;
-		};
+	pwm6: pwm@fe6e0020 {
+		compatible = "rockchip,rk3568-pwm", "rockchip,rk3328-pwm";
+		reg = <0x0 0xfe6e0020 0x0 0x10>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm6_pins>;
+		clocks = <&cru CLK_PWM1>, <&cru PCLK_PWM1>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
 	};
 
-	pcie3x2: pcie@fe280000 {
-		compatible = "rockchip,rk3568-pcie";
-		#address-cells = <3>;
-		#size-cells = <2>;
-		bus-range = <0x0 0xf>;
-		clocks = <&cru ACLK_PCIE30X2_MST>, <&cru ACLK_PCIE30X2_SLV>,
-			 <&cru ACLK_PCIE30X2_DBI>, <&cru PCLK_PCIE30X2>,
-			 <&cru CLK_PCIE30X2_AUX_NDFT>;
-		clock-names = "aclk_mst", "aclk_slv",
-			      "aclk_dbi", "pclk", "aux";
-		device_type = "pci";
-		interrupts = <GIC_SPI 165 IRQ_TYPE_LEVEL_HIGH>,
-			     <GIC_SPI 164 IRQ_TYPE_LEVEL_HIGH>,
-			     <GIC_SPI 163 IRQ_TYPE_LEVEL_HIGH>,
-			     <GIC_SPI 162 IRQ_TYPE_LEVEL_HIGH>,
-			     <GIC_SPI 161 IRQ_TYPE_LEVEL_HIGH>;
-		interrupt-names = "sys", "pmc", "msg", "legacy", "err";
-		#interrupt-cells = <1>;
-		interrupt-map-mask = <0 0 0 7>;
-		interrupt-map = <0 0 0 1 &pcie3x2_intc 0>,
-				<0 0 0 2 &pcie3x2_intc 1>,
-				<0 0 0 3 &pcie3x2_intc 2>,
-				<0 0 0 4 &pcie3x2_intc 3>;
-		linux,pci-domain = <2>;
-		num-ib-windows = <6>;
-		num-ob-windows = <2>;
-		max-link-speed = <3>;
-		msi-map = <0x0 &gic 0x2000 0x1000>;
-		num-lanes = <2>;
-		phys = <&pcie30phy>;
-		phy-names = "pcie-phy";
-		power-domains = <&power RK3568_PD_PIPE>;
-		reg = <0x3 0xc0800000 0x0 0x00400000>,
-		      <0x0 0xfe280000 0x0 0x00010000>,
-		      <0x0 0xf0000000 0x0 0x00100000>;
-		ranges = <0x01000000 0x0 0xf0100000 0x0 0xf0100000 0x0 0x00100000>,
-			 <0x02000000 0x0 0xf0200000 0x0 0xf0200000 0x0 0x01e00000>,
-			 <0x03000000 0x0 0x40000000 0x3 0x80000000 0x0 0x40000000>;
-		reg-names = "dbi", "apb", "config";
-		resets = <&cru SRST_PCIE30X2_POWERUP>;
-		reset-names = "pipe";
-		/* bifurcation; lane0 when using 1+1 */
+	pwm7: pwm@fe6e0030 {
+		compatible = "rockchip,rk3568-pwm", "rockchip,rk3328-pwm";
+		reg = <0x0 0xfe6e0030 0x0 0x10>;
+		interrupts = <GIC_SPI 83 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm7_pins>;
+		clocks = <&cru CLK_PWM1>, <&cru PCLK_PWM1>;
+		clock-names = "pwm", "pclk";
 		status = "disabled";
+	};
 
-		pcie3x2_intc: legacy-interrupt-controller {
-			interrupt-controller;
-			#address-cells = <0>;
-			#interrupt-cells = <1>;
-			interrupt-parent = <&gic>;
-			interrupts = <GIC_SPI 162 IRQ_TYPE_EDGE_RISING>;
-		};
+	pwm8: pwm@fe6f0000 {
+		compatible = "rockchip,rk3568-pwm", "rockchip,rk3328-pwm";
+		reg = <0x0 0xfe6f0000 0x0 0x10>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm8m0_pins>;
+		clocks = <&cru CLK_PWM2>, <&cru PCLK_PWM2>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
 	};
 
-	gmac0: ethernet@fe2a0000 {
-		compatible = "rockchip,rk3568-gmac", "snps,dwmac-4.20a";
-		reg = <0x0 0xfe2a0000 0x0 0x10000>;
-		interrupts = <GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH>,
-			     <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>;
-		interrupt-names = "macirq", "eth_wake_irq";
-		clocks = <&cru SCLK_GMAC0>, <&cru SCLK_GMAC0_RX_TX>,
-			 <&cru SCLK_GMAC0_RX_TX>, <&cru CLK_MAC0_REFOUT>,
-			 <&cru ACLK_GMAC0>, <&cru PCLK_GMAC0>,
-			 <&cru SCLK_GMAC0_RX_TX>, <&cru CLK_GMAC0_PTP_REF>;
-		clock-names = "stmmaceth", "mac_clk_rx",
-			      "mac_clk_tx", "clk_mac_refout",
-			      "aclk_mac", "pclk_mac",
-			      "clk_mac_speed", "ptp_ref";
-		resets = <&cru SRST_A_GMAC0>;
-		reset-names = "stmmaceth";
+	pwm9: pwm@fe6f0010 {
+		compatible = "rockchip,rk3568-pwm", "rockchip,rk3328-pwm";
+		reg = <0x0 0xfe6f0010 0x0 0x10>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm9m0_pins>;
+		clocks = <&cru CLK_PWM2>, <&cru PCLK_PWM2>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm10: pwm@fe6f0020 {
+		compatible = "rockchip,rk3568-pwm", "rockchip,rk3328-pwm";
+		reg = <0x0 0xfe6f0020 0x0 0x10>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm10m0_pins>;
+		clocks = <&cru CLK_PWM2>, <&cru PCLK_PWM2>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm11: pwm@fe6f0030 {
+		compatible = "rockchip,rk3568-pwm", "rockchip,rk3328-pwm";
+		reg = <0x0 0xfe6f0030 0x0 0x10>;
+		interrupts = <GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm11m0_pins>;
+		clocks = <&cru CLK_PWM2>, <&cru PCLK_PWM2>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm12: pwm@fe700000 {
+		compatible = "rockchip,rk3568-pwm", "rockchip,rk3328-pwm";
+		reg = <0x0 0xfe700000 0x0 0x10>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm12m0_pins>;
+		clocks = <&cru CLK_PWM3>, <&cru PCLK_PWM3>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm13: pwm@fe700010 {
+		compatible = "rockchip,rk3568-pwm", "rockchip,rk3328-pwm";
+		reg = <0x0 0xfe700010 0x0 0x10>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm13m0_pins>;
+		clocks = <&cru CLK_PWM3>, <&cru PCLK_PWM3>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm14: pwm@fe700020 {
+		compatible = "rockchip,rk3568-pwm", "rockchip,rk3328-pwm";
+		reg = <0x0 0xfe700020 0x0 0x10>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm14m0_pins>;
+		clocks = <&cru CLK_PWM3>, <&cru PCLK_PWM3>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm15: pwm@fe700030 {
+		compatible = "rockchip,rk3568-pwm", "rockchip,rk3328-pwm";
+		reg = <0x0 0xfe700030 0x0 0x10>;
+		interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm15m0_pins>;
+		clocks = <&cru CLK_PWM3>, <&cru PCLK_PWM3>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	tsadc: tsadc@fe710000 {
+		compatible = "rockchip,rk3568-tsadc";
+		reg = <0x0 0xfe710000 0x0 0x100>;
+		interrupts = <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
 		rockchip,grf = <&grf>;
-		snps,axi-config = <&gmac0_stmmac_axi_setup>;
-		snps,mixed-burst;
-		snps,mtl-rx-config = <&gmac0_mtl_rx_setup>;
-		snps,mtl-tx-config = <&gmac0_mtl_tx_setup>;
-		snps,tso;
+		clocks = <&cru CLK_TSADC>, <&cru PCLK_TSADC>;
+		clock-names = "tsadc", "apb_pclk";
+		assigned-clocks = <&cru CLK_TSADC_TSEN>, <&cru CLK_TSADC>;
+		assigned-clock-rates = <17000000>, <700000>;
+		resets = <&cru SRST_TSADC>, <&cru SRST_P_TSADC>,
+			 <&cru SRST_TSADCPHY>;
+		reset-names = "tsadc", "tsadc-apb", "tsadc-phy";
+		#thermal-sensor-cells = <1>;
+		nvmem-cells = <&tsadc_trim_base>, <&tsadc_trim_base_frac>;
+		nvmem-cell-names = "trim_base", "trim_base_frac";
+		rockchip,hw-tshut-temp = <120000>;
+		rockchip,hw-tshut-mode = <0>; /* tshut mode 0:CRU 1:GPIO */
+		rockchip,hw-tshut-polarity = <0>; /* tshut polarity 0:LOW 1:HIGH */
+		pinctrl-names = "gpio", "otpout";
+		pinctrl-0 = <&tsadc_gpio_func>;
+		pinctrl-1 = <&tsadc_shutorg>;
+		#address-cells = <1>;
+		#size-cells = <0>;
 		status = "disabled";
 
-		mdio0: mdio {
-			compatible = "snps,dwmac-mdio";
-			#address-cells = <0x1>;
-			#size-cells = <0x0>;
+		tsadc@0 {
+			reg = <0>;
+			nvmem-cells = <&cpu_tsadc_trim_l>, <&cpu_tsadc_trim_h>;
+			nvmem-cell-names = "trim_l", "trim_h";
 		};
-
-		gmac0_stmmac_axi_setup: stmmac-axi-config {
-			snps,blen = <0 0 0 0 16 8 4>;
-			snps,rd_osr_lmt = <8>;
-			snps,wr_osr_lmt = <4>;
+		tsadc@1 {
+			reg = <1>;
+			nvmem-cells = <&gpu_tsadc_trim_l>, <&gpu_tsadc_trim_h>;
+			nvmem-cell-names = "trim_l", "trim_h";
 		};
+	};
 
-		gmac0_mtl_rx_setup: rx-queues-config {
-			snps,rx-queues-to-use = <1>;
-			queue0 {};
-		};
+	saradc: saradc@fe720000 {
+		compatible = "rockchip,rk3568-saradc", "rockchip,rk3399-saradc";
+		reg = <0x0 0xfe720000 0x0 0x100>;
+		interrupts = <GIC_SPI 93 IRQ_TYPE_LEVEL_HIGH>;
+		#io-channel-cells = <1>;
+		clocks = <&cru CLK_SARADC>, <&cru PCLK_SARADC>;
+		clock-names = "saradc", "apb_pclk";
+		resets = <&cru SRST_P_SARADC>;
+		reset-names = "saradc-apb";
+		status = "disabled";
+	};
 
-		gmac0_mtl_tx_setup: tx-queues-config {
-			snps,tx-queues-to-use = <1>;
-			queue0 {};
-		};
+	mailbox: mailbox@fe780000 {
+		compatible = "rockchip,rk3568-mailbox",
+			     "rockchip,rk3368-mailbox";
+		reg = <0x0 0xfe780000 0x0 0x1000>;
+		interrupts = <GIC_SPI 183 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 184 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 185 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 186 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru PCLK_MAILBOX>;
+		clock-names = "pclk_mailbox";
+		#mbox-cells = <1>;
+		status = "disabled";
 	};
 
-	combphy0: phy@fe820000 {
+	combphy0_us: phy@fe820000 {
 		compatible = "rockchip,rk3568-naneng-combphy";
 		reg = <0x0 0xfe820000 0x0 0x100>;
-		clocks = <&pmucru CLK_PCIEPHY0_REF>,
-			 <&cru PCLK_PIPEPHY0>,
+		#phy-cells = <1>;
+		clocks = <&pmucru CLK_PCIEPHY0_REF>, <&cru PCLK_PIPEPHY0>,
 			 <&cru PCLK_PIPE>;
-		clock-names = "ref", "apb", "pipe";
+		clock-names = "refclk", "apbclk", "pipe_clk";
 		assigned-clocks = <&pmucru CLK_PCIEPHY0_REF>;
 		assigned-clock-rates = <100000000>;
-		resets = <&cru SRST_PIPEPHY0>;
+		resets = <&cru SRST_P_PIPEPHY0>, <&cru SRST_PIPEPHY0>;
+		reset-names = "combphy-apb", "combphy";
 		rockchip,pipe-grf = <&pipegrf>;
 		rockchip,pipe-phy-grf = <&pipe_phy_grf0>;
+		status = "disabled";
+	};
+
+	combphy1_usq: phy@fe830000 {
+		compatible = "rockchip,rk3568-naneng-combphy";
+		reg = <0x0 0xfe830000 0x0 0x100>;
 		#phy-cells = <1>;
+		clocks = <&pmucru CLK_PCIEPHY1_REF>, <&cru PCLK_PIPEPHY1>,
+			 <&cru PCLK_PIPE>;
+		clock-names = "refclk", "apbclk", "pipe_clk";
+		assigned-clocks = <&pmucru CLK_PCIEPHY1_REF>;
+		assigned-clock-rates = <100000000>;
+		resets = <&cru SRST_P_PIPEPHY1>, <&cru SRST_PIPEPHY1>;
+		reset-names = "combphy-apb", "combphy";
+		rockchip,pipe-grf = <&pipegrf>;
+		rockchip,pipe-phy-grf = <&pipe_phy_grf1>;
 		status = "disabled";
 	};
-};
 
-&cpu0_opp_table {
-	opp-1992000000 {
-		opp-hz = /bits/ 64 <1992000000>;
-		opp-microvolt = <1150000 1150000 1150000>;
+	combphy2_psq: phy@fe840000 {
+		compatible = "rockchip,rk3568-naneng-combphy";
+		reg = <0x0 0xfe840000 0x0 0x100>;
+		#phy-cells = <1>;
+		clocks = <&pmucru CLK_PCIEPHY2_REF>, <&cru PCLK_PIPEPHY2>,
+			 <&cru PCLK_PIPE>;
+		clock-names = "refclk", "apbclk", "pipe_clk";
+		assigned-clocks = <&pmucru CLK_PCIEPHY2_REF>;
+		assigned-clock-rates = <100000000>;
+		resets = <&cru SRST_P_PIPEPHY2>, <&cru SRST_PIPEPHY2>;
+		reset-names = "combphy-apb", "combphy";
+		rockchip,pipe-grf = <&pipegrf>;
+		rockchip,pipe-phy-grf = <&pipe_phy_grf2>;
+		status = "disabled";
 	};
-};
 
-&pipegrf {
-	compatible = "rockchip,rk3568-pipe-grf", "syscon";
-};
+	video_phy0: phy@fe850000 {
+		compatible = "rockchip,rk3568-dsi-dphy", "rockchip,rk3568-video-phy";
+		reg = <0x0 0xfe850000  0x0 0x10000>,
+		      <0x0 0xfe060000 0x0 0x10000>;
+		reg-names = "phy", "host";
+		clocks = <&pmucru CLK_MIPIDSIPHY0_REF>,
+			 <&cru PCLK_MIPIDSIPHY0>, <&cru PCLK_DSITX_0>;
+		clock-names = "ref", "pclk", "pclk_host";
+		#clock-cells = <0>;
+		resets = <&cru SRST_P_MIPIDSIPHY0>;
+		reset-names = "apb";
+		power-domains = <&power RK3568_PD_VO>;
+		#phy-cells = <0>;
+		status = "disabled";
+	};
 
-&power {
-	power-domain@RK3568_PD_PIPE {
-		reg = <RK3568_PD_PIPE>;
-		clocks = <&cru PCLK_PIPE>;
-		pm_qos = <&qos_pcie2x1>,
-			 <&qos_pcie3x1>,
-			 <&qos_pcie3x2>,
-			 <&qos_sata0>,
-			 <&qos_sata1>,
-			 <&qos_sata2>,
-			 <&qos_usb3_0>,
-			 <&qos_usb3_1>;
-		#power-domain-cells = <0>;
+	video_phy1: phy@fe860000 {
+		compatible = "rockchip,rk3568-dsi-dphy", "rockchip,rk3568-video-phy";
+		reg = <0x0 0xfe860000  0x0 0x10000>,
+		      <0x0 0xfe070000 0x0 0x10000>;
+		reg-names = "phy", "host";
+		clocks = <&pmucru CLK_MIPIDSIPHY1_REF>,
+			 <&cru PCLK_MIPIDSIPHY1>, <&cru PCLK_DSITX_1>;
+		clock-names = "ref", "pclk", "pclk_host";
+		#clock-cells = <0>;
+		resets = <&cru SRST_P_MIPIDSIPHY1>;
+		reset-names = "apb";
+		power-domains = <&power RK3568_PD_VO>;
+		#phy-cells = <0>;
+		status = "disabled";
 	};
-};
 
-&usb_host0_xhci {
-	phys = <&usb2phy0_otg>, <&combphy0 PHY_TYPE_USB3>;
-	phy-names = "usb2-phy", "usb3-phy";
-};
+	csi2_dphy_hw: csi2-dphy-hw@fe870000 {
+		compatible = "rockchip,rk3568-csi2-dphy-hw";
+		reg = <0x0 0xfe870000 0x0 0x1000>;
+		clocks = <&cru PCLK_MIPICSIPHY>;
+		clock-names = "pclk";
+		rockchip,grf = <&grf>;
+		status = "disabled";
+	};
+
+	/*
+	 * csi2_dphy0: used for csi2 dphy full mode,
+		       is mutually exclusive with
+		       csi2_dphy1 and csi2_dphy2
+	 * csi2_dphy1: used for csi2 dphy split mode,
+		       physical lanes use lane0 and lane1,
+		       can be used with csi2_dphy2  parallel
+	 * csi2_dphy2: used for csi2 dphy split mode,
+		       physical lanes use lane2 and lane3,
+		       can be used with csi2_dphy1  parallel
+	 */
+	csi2_dphy0: csi2-dphy0 {
+		compatible = "rockchip,rk3568-csi2-dphy";
+		rockchip,hw = <&csi2_dphy_hw>;
+		status = "disabled";
+	};
+
+	csi2_dphy1: csi2-dphy1 {
+		compatible = "rockchip,rk3568-csi2-dphy";
+		rockchip,hw = <&csi2_dphy_hw>;
+		status = "disabled";
+	};
+
+	csi2_dphy2: csi2-dphy2 {
+		compatible = "rockchip,rk3568-csi2-dphy";
+		rockchip,hw = <&csi2_dphy_hw>;
+		status = "disabled";
+	};
+
+	usb2phy0: usb2-phy@fe8a0000 {
+		compatible = "rockchip,rk3568-usb2phy";
+		reg = <0x0 0xfe8a0000 0x0 0x10000>;
+		interrupts = <GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&pmucru CLK_USBPHY0_REF>;
+		clock-names = "phyclk";
+		#clock-cells = <0>;
+		assigned-clocks = <&cru USB480M>;
+		assigned-clock-parents = <&usb2phy0>;
+		clock-output-names = "usb480m_phy";
+		rockchip,usbgrf = <&usb2phy0_grf>;
+		status = "disabled";
+
+		u2phy0_host: host-port {
+			#phy-cells = <0>;
+			status = "disabled";
+		};
+
+		u2phy0_otg: otg-port {
+			#phy-cells = <0>;
+			status = "disabled";
+		};
+	};
+
+	usb2phy1: usb2-phy@fe8b0000 {
+		compatible = "rockchip,rk3568-usb2phy";
+		reg = <0x0 0xfe8b0000 0x0 0x10000>;
+		interrupts = <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&pmucru CLK_USBPHY1_REF>;
+		clock-names = "phyclk";
+		#clock-cells = <0>;
+		rockchip,usbgrf = <&usb2phy1_grf>;
+		status = "disabled";
+
+		u2phy1_host: host-port {
+			#phy-cells = <0>;
+			status = "disabled";
+		};
+
+		u2phy1_otg: otg-port {
+			#phy-cells = <0>;
+			status = "disabled";
+		};
+	};
+
+	pcie30phy: phy@fe8c0000 {
+		compatible = "rockchip,rk3568-pcie3-phy";
+		reg = <0x0 0xfe8c0000 0x0 0x20000>;
+		#phy-cells = <0>;
+		clocks = <&pmucru CLK_PCIE30PHY_REF_M>, <&pmucru CLK_PCIE30PHY_REF_N>,
+			 <&cru PCLK_PCIE30PHY>;
+		clock-names = "refclk_m", "refclk_n", "pclk";
+		resets = <&cru SRST_PCIE30PHY>;
+		reset-names = "phy";
+		rockchip,phy-grf = <&pcie30_phy_grf>;
+		status = "disabled";
+	};
+
+	pinctrl: pinctrl {
+		compatible = "rockchip,rk3568-pinctrl";
+		rockchip,grf = <&grf>;
+		rockchip,pmu = <&pmugrf>;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		gpio0: gpio0@fdd60000 {
+			compatible = "rockchip,gpio-bank";
+			reg = <0x0 0xfdd60000 0x0 0x100>;
+			interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&pmucru PCLK_GPIO0>, <&pmucru DBCLK_GPIO0>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		gpio1: gpio1@fe740000 {
+			compatible = "rockchip,gpio-bank";
+			reg = <0x0 0xfe740000 0x0 0x100>;
+			interrupts = <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cru PCLK_GPIO1>, <&cru DBCLK_GPIO1>;
 
-&vop {
-	compatible = "rockchip,rk3568-vop";
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		gpio2: gpio2@fe750000 {
+			compatible = "rockchip,gpio-bank";
+			reg = <0x0 0xfe750000 0x0 0x100>;
+			interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cru PCLK_GPIO2>, <&cru DBCLK_GPIO2>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		gpio3: gpio3@fe760000 {
+			compatible = "rockchip,gpio-bank";
+			reg = <0x0 0xfe760000 0x0 0x100>;
+			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cru PCLK_GPIO3>, <&cru DBCLK_GPIO3>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		gpio4: gpio4@fe770000 {
+			compatible = "rockchip,gpio-bank";
+			reg = <0x0 0xfe770000 0x0 0x100>;
+			interrupts = <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cru PCLK_GPIO4>, <&cru DBCLK_GPIO4>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+	};
 };
+
+#include "rk3568-pinctrl.dtsi"
diff --git a/arch/arm64/boot/dts/rockchip/rockchip-pinconf.dtsi b/arch/arm64/boot/dts/rockchip/rockchip-pinconf.dtsi
index 5c645437b507..72d644575cf9 100644
--- a/arch/arm64/boot/dts/rockchip/rockchip-pinconf.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rockchip-pinconf.dtsi
@@ -332,13 +332,84 @@ pcfg_pull_none_drv_level_0_smt: pcfg-pull-none-drv-level-0-smt {
 		input-schmitt-enable;
 	};
 
+	/omit-if-no-ref/
+	pcfg_pull_none_drv_level_1_smt: pcfg-pull-none-drv-level-1-smt {
+		bias-disable;
+		drive-strength = <1>;
+		input-schmitt-enable;
+	};
+
+	/omit-if-no-ref/
+	pcfg_pull_none_drv_level_2_smt: pcfg-pull-none-drv-level-2-smt {
+		bias-disable;
+		drive-strength = <2>;
+		input-schmitt-enable;
+	};
+
+	/omit-if-no-ref/
+	pcfg_pull_none_drv_level_3_smt: pcfg-pull-none-drv-level-3-smt {
+		bias-disable;
+		drive-strength = <3>;
+		input-schmitt-enable;
+	};
+
+	/omit-if-no-ref/
+	pcfg_pull_none_drv_level_4_smt: pcfg-pull-none-drv-level-4-smt {
+		bias-disable;
+		drive-strength = <4>;
+		input-schmitt-enable;
+	};
+
+	/omit-if-no-ref/
+	pcfg_pull_none_drv_level_5_smt: pcfg-pull-none-drv-level-5-smt {
+		bias-disable;
+		drive-strength = <5>;
+		input-schmitt-enable;
+	};
+
 	/omit-if-no-ref/
 	pcfg_output_high: pcfg-output-high {
 		output-high;
 	};
 
+	/omit-if-no-ref/
+	pcfg_output_high_pull_up: pcfg-output-high-pull-up {
+		output-high;
+		bias-pull-up;
+	};
+
+	/omit-if-no-ref/
+	pcfg_output_high_pull_down: pcfg-output-high-pull-down {
+		output-high;
+		bias-pull-down;
+	};
+
+	/omit-if-no-ref/
+	pcfg_output_high_pull_none: pcfg-output-high-pull-none {
+		output-high;
+		bias-disable;
+	};
+
 	/omit-if-no-ref/
 	pcfg_output_low: pcfg-output-low {
 		output-low;
 	};
+
+	/omit-if-no-ref/
+	pcfg_output_low_pull_up: pcfg-output-low-pull-up {
+		output-low;
+		bias-pull-up;
+	};
+
+	/omit-if-no-ref/
+	pcfg_output_low_pull_down: pcfg-output-low-pull-down {
+		output-low;
+		bias-pull-down;
+	};
+
+	/omit-if-no-ref/
+	pcfg_output_low_pull_none: pcfg-output-low-pull-none {
+		output-low;
+		bias-disable;
+	};
 };
diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
index dd6cda270294..bc37a46d401a 100644
--- a/drivers/pinctrl/Makefile
+++ b/drivers/pinctrl/Makefile
@@ -41,6 +41,7 @@ obj-$(CONFIG_PINCTRL_OCELOT)	+= pinctrl-ocelot.o
 obj-$(CONFIG_PINCTRL_PALMAS)	+= pinctrl-palmas.o
 obj-$(CONFIG_PINCTRL_PIC32)	+= pinctrl-pic32.o
 obj-$(CONFIG_PINCTRL_PISTACHIO)	+= pinctrl-pistachio.o
+obj-$(CONFIG_PINCTRL_ROCKCHIP)	+= pinctrl-rockchip.o
 obj-$(CONFIG_PINCTRL_RK805)	+= pinctrl-rk805.o
 obj-$(CONFIG_PINCTRL_ROCKCHIP)	+= pinctrl-rockchip.o
 obj-$(CONFIG_PINCTRL_SINGLE)	+= pinctrl-single.o
diff --git a/drivers/pinctrl/pinctrl-rockchip.c b/drivers/pinctrl/pinctrl-rockchip.c
index 45e416f68e74..81191ae3f8ed 100644
--- a/drivers/pinctrl/pinctrl-rockchip.c
+++ b/drivers/pinctrl/pinctrl-rockchip.c
@@ -21,8 +21,9 @@
 #include <linux/io.h>
 #include <linux/bitops.h>
 #include <linux/gpio/driver.h>
-#include <linux/of.h>
-#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
 #include <linux/pinctrl/machine.h>
 #include <linux/pinctrl/pinconf.h>
 #include <linux/pinctrl/pinctrl.h>
@@ -32,8 +33,7 @@
 #include <linux/clk.h>
 #include <linux/regmap.h>
 #include <linux/mfd/syscon.h>
-#include <linux/string_helpers.h>
-
+#include <linux/rockchip/cpu.h>
 #include <dt-bindings/pinctrl/rockchip.h>
 
 #include "core.h"
@@ -56,7 +56,8 @@
 #define IOMUX_UNROUTED		BIT(3)
 #define IOMUX_WIDTH_3BIT	BIT(4)
 #define IOMUX_WIDTH_2BIT	BIT(5)
-#define IOMUX_L_SOURCE_PMU	BIT(6)
+#define IOMUX_WRITABLE_32BIT	BIT(6)
+#define IOMUX_L_SOURCE_PMU	BIT(7)
 
 #define PIN_BANK(id, pins, label)			\
 	{						\
@@ -84,6 +85,21 @@
 		},							\
 	}
 
+#define PIN_BANK_IOMUX_FLAGS_OFFSET(id, pins, label, iom0, iom1, iom2,	\
+				    iom3, offset0, offset1, offset2,	\
+				    offset3)				\
+	{								\
+		.bank_num	= id,					\
+		.nr_pins	= pins,					\
+		.name		= label,				\
+		.iomux		= {					\
+			{ .type = iom0, .offset = offset0 },		\
+			{ .type = iom1, .offset = offset1 },		\
+			{ .type = iom2, .offset = offset2 },		\
+			{ .type = iom3, .offset = offset3 },		\
+		},							\
+	}
+
 #define PIN_BANK_DRV_FLAGS(id, pins, label, type0, type1, type2, type3) \
 	{								\
 		.bank_num	= id,					\
@@ -147,21 +163,6 @@
 		.pull_type[3] = pull3,					\
 	}
 
-#define PIN_BANK_IOMUX_FLAGS_OFFSET(id, pins, label, iom0, iom1, iom2,	\
-				    iom3, offset0, offset1, offset2,	\
-				    offset3)				\
-	{								\
-		.bank_num	= id,					\
-		.nr_pins	= pins,					\
-		.name		= label,				\
-		.iomux		= {					\
-			{ .type = iom0, .offset = offset0 },		\
-			{ .type = iom1, .offset = offset1 },		\
-			{ .type = iom2, .offset = offset2 },		\
-			{ .type = iom3, .offset = offset3 },		\
-		},							\
-	}
-
 #define PIN_BANK_IOMUX_DRV_FLAGS_OFFSET(id, pins, label, iom0, iom1,	\
 					iom2, iom3, drv0, drv1, drv2,	\
 					drv3, offset0, offset1,		\
@@ -222,6 +223,12 @@
 		.route_location	= FLAG,					\
 	}
 
+#define S_PIN_BANK_FLAGS(ID, PIN, LABEL, MTYPE, DTYPE)			\
+	PIN_BANK_IOMUX_DRV_FLAGS_OFFSET(ID, PIN, LABEL,			\
+					MTYPE, MTYPE, MTYPE, MTYPE,	\
+					DTYPE, DTYPE, DTYPE, DTYPE,	\
+					-1, -1, -1, -1)
+
 #define RK_MUXROUTE_SAME(ID, PIN, FUNC, REG, VAL)	\
 	PIN_BANK_MUX_ROUTE_FLAGS(ID, PIN, FUNC, REG, VAL, ROCKCHIP_ROUTE_SAME)
 
@@ -234,6 +241,9 @@
 #define RK3588_PIN_BANK_FLAGS(ID, PIN, LABEL, M, P)			\
 	PIN_BANK_IOMUX_FLAGS_PULL_FLAGS(ID, PIN, LABEL, M, M, M, M, P, P, P, P)
 
+static struct pinctrl_dev *g_pctldev;
+static DEFINE_MUTEX(iomux_lock);
+
 static struct regmap_config rockchip_regmap_config = {
 	.reg_bits = 32,
 	.val_bits = 32,
@@ -581,40 +591,40 @@ static struct rockchip_mux_recalced_data rk3308_mux_recalced_data[] = {
 		.bit = 8,
 		.mask = 0xf
 	}, {
-		/* gpio2a2_sel */
+		/* gpio2a2_sel_plus */
 		.num = 2,
 		.pin = 2,
-		.reg = 0x40,
-		.bit = 4,
-		.mask = 0x3
+		.reg = 0x608,
+		.bit = 0,
+		.mask = 0x7
 	}, {
-		/* gpio2a3_sel */
+		/* gpio2a3_sel_plus */
 		.num = 2,
 		.pin = 3,
-		.reg = 0x40,
-		.bit = 6,
-		.mask = 0x3
+		.reg = 0x608,
+		.bit = 4,
+		.mask = 0x7
 	}, {
-		/* gpio2c0_sel */
+		/* gpio2c0_sel_plus */
 		.num = 2,
 		.pin = 16,
-		.reg = 0x50,
-		.bit = 0,
-		.mask = 0x3
+		.reg = 0x610,
+		.bit = 8,
+		.mask = 0x7
 	}, {
-		/* gpio3b2_sel */
+		/* gpio3b2_sel_plus */
 		.num = 3,
 		.pin = 10,
-		.reg = 0x68,
-		.bit = 4,
-		.mask = 0x3
+		.reg = 0x610,
+		.bit = 0,
+		.mask = 0x7
 	}, {
-		/* gpio3b3_sel */
+		/* gpio3b3_sel_plus */
 		.num = 3,
 		.pin = 11,
-		.reg = 0x68,
-		.bit = 6,
-		.mask = 0x3
+		.reg = 0x610,
+		.bit = 4,
+		.mask = 0x7
 	}, {
 		/* gpio3b4_sel */
 		.num = 3,
@@ -634,11 +644,47 @@ static struct rockchip_mux_recalced_data rk3308_mux_recalced_data[] = {
 
 static struct rockchip_mux_recalced_data rk3328_mux_recalced_data[] = {
 	{
+		.num = 2,
+		.pin = 8,
+		.reg = 0x24,
+		.bit = 0,
+		.mask = 0x3
+	}, {
+		.num = 2,
+		.pin = 9,
+		.reg = 0x24,
+		.bit = 2,
+		.mask = 0x3
+	}, {
+		.num = 2,
+		.pin = 10,
+		.reg = 0x24,
+		.bit = 4,
+		.mask = 0x3
+	}, {
+		.num = 2,
+		.pin = 11,
+		.reg = 0x24,
+		.bit = 6,
+		.mask = 0x3
+	}, {
 		.num = 2,
 		.pin = 12,
 		.reg = 0x24,
 		.bit = 8,
 		.mask = 0x3
+	}, {
+		.num = 2,
+		.pin = 13,
+		.reg = 0x24,
+		.bit = 10,
+		.mask = 0x3
+	}, {
+		.num = 2,
+		.pin = 14,
+		.reg = 0x24,
+		.bit = 12,
+		.mask = 0x3
 	}, {
 		.num = 2,
 		.pin = 15,
@@ -654,80 +700,6 @@ static struct rockchip_mux_recalced_data rk3328_mux_recalced_data[] = {
 	},
 };
 
-static void rockchip_get_recalced_mux(struct rockchip_pin_bank *bank, int pin,
-				      int *reg, u8 *bit, int *mask)
-{
-	struct rockchip_pinctrl *info = bank->drvdata;
-	struct rockchip_pin_ctrl *ctrl = info->ctrl;
-	struct rockchip_mux_recalced_data *data;
-	int i;
-
-	for (i = 0; i < ctrl->niomux_recalced; i++) {
-		data = &ctrl->iomux_recalced[i];
-		if (data->num == bank->bank_num &&
-		    data->pin == pin)
-			break;
-	}
-
-	if (i >= ctrl->niomux_recalced)
-		return;
-
-	*reg = data->reg;
-	*mask = data->mask;
-	*bit = data->bit;
-}
-
-static struct rockchip_mux_route_data px30_mux_route_data[] = {
-	RK_MUXROUTE_SAME(2, RK_PB4, 1, 0x184, BIT(16 + 7)), /* cif-d0m0 */
-	RK_MUXROUTE_SAME(3, RK_PA1, 3, 0x184, BIT(16 + 7) | BIT(7)), /* cif-d0m1 */
-	RK_MUXROUTE_SAME(2, RK_PB6, 1, 0x184, BIT(16 + 7)), /* cif-d1m0 */
-	RK_MUXROUTE_SAME(3, RK_PA2, 3, 0x184, BIT(16 + 7) | BIT(7)), /* cif-d1m1 */
-	RK_MUXROUTE_SAME(2, RK_PA0, 1, 0x184, BIT(16 + 7)), /* cif-d2m0 */
-	RK_MUXROUTE_SAME(3, RK_PA3, 3, 0x184, BIT(16 + 7) | BIT(7)), /* cif-d2m1 */
-	RK_MUXROUTE_SAME(2, RK_PA1, 1, 0x184, BIT(16 + 7)), /* cif-d3m0 */
-	RK_MUXROUTE_SAME(3, RK_PA5, 3, 0x184, BIT(16 + 7) | BIT(7)), /* cif-d3m1 */
-	RK_MUXROUTE_SAME(2, RK_PA2, 1, 0x184, BIT(16 + 7)), /* cif-d4m0 */
-	RK_MUXROUTE_SAME(3, RK_PA7, 3, 0x184, BIT(16 + 7) | BIT(7)), /* cif-d4m1 */
-	RK_MUXROUTE_SAME(2, RK_PA3, 1, 0x184, BIT(16 + 7)), /* cif-d5m0 */
-	RK_MUXROUTE_SAME(3, RK_PB0, 3, 0x184, BIT(16 + 7) | BIT(7)), /* cif-d5m1 */
-	RK_MUXROUTE_SAME(2, RK_PA4, 1, 0x184, BIT(16 + 7)), /* cif-d6m0 */
-	RK_MUXROUTE_SAME(3, RK_PB1, 3, 0x184, BIT(16 + 7) | BIT(7)), /* cif-d6m1 */
-	RK_MUXROUTE_SAME(2, RK_PA5, 1, 0x184, BIT(16 + 7)), /* cif-d7m0 */
-	RK_MUXROUTE_SAME(3, RK_PB4, 3, 0x184, BIT(16 + 7) | BIT(7)), /* cif-d7m1 */
-	RK_MUXROUTE_SAME(2, RK_PA6, 1, 0x184, BIT(16 + 7)), /* cif-d8m0 */
-	RK_MUXROUTE_SAME(3, RK_PB6, 3, 0x184, BIT(16 + 7) | BIT(7)), /* cif-d8m1 */
-	RK_MUXROUTE_SAME(2, RK_PA7, 1, 0x184, BIT(16 + 7)), /* cif-d9m0 */
-	RK_MUXROUTE_SAME(3, RK_PB7, 3, 0x184, BIT(16 + 7) | BIT(7)), /* cif-d9m1 */
-	RK_MUXROUTE_SAME(2, RK_PB7, 1, 0x184, BIT(16 + 7)), /* cif-d10m0 */
-	RK_MUXROUTE_SAME(3, RK_PC6, 3, 0x184, BIT(16 + 7) | BIT(7)), /* cif-d10m1 */
-	RK_MUXROUTE_SAME(2, RK_PC0, 1, 0x184, BIT(16 + 7)), /* cif-d11m0 */
-	RK_MUXROUTE_SAME(3, RK_PC7, 3, 0x184, BIT(16 + 7) | BIT(7)), /* cif-d11m1 */
-	RK_MUXROUTE_SAME(2, RK_PB0, 1, 0x184, BIT(16 + 7)), /* cif-vsyncm0 */
-	RK_MUXROUTE_SAME(3, RK_PD1, 3, 0x184, BIT(16 + 7) | BIT(7)), /* cif-vsyncm1 */
-	RK_MUXROUTE_SAME(2, RK_PB1, 1, 0x184, BIT(16 + 7)), /* cif-hrefm0 */
-	RK_MUXROUTE_SAME(3, RK_PD2, 3, 0x184, BIT(16 + 7) | BIT(7)), /* cif-hrefm1 */
-	RK_MUXROUTE_SAME(2, RK_PB2, 1, 0x184, BIT(16 + 7)), /* cif-clkinm0 */
-	RK_MUXROUTE_SAME(3, RK_PD3, 3, 0x184, BIT(16 + 7) | BIT(7)), /* cif-clkinm1 */
-	RK_MUXROUTE_SAME(2, RK_PB3, 1, 0x184, BIT(16 + 7)), /* cif-clkoutm0 */
-	RK_MUXROUTE_SAME(3, RK_PD0, 3, 0x184, BIT(16 + 7) | BIT(7)), /* cif-clkoutm1 */
-	RK_MUXROUTE_SAME(3, RK_PC6, 2, 0x184, BIT(16 + 8)), /* pdm-m0 */
-	RK_MUXROUTE_SAME(2, RK_PC6, 1, 0x184, BIT(16 + 8) | BIT(8)), /* pdm-m1 */
-	RK_MUXROUTE_SAME(3, RK_PD3, 2, 0x184, BIT(16 + 8)), /* pdm-sdi0m0 */
-	RK_MUXROUTE_SAME(2, RK_PC5, 2, 0x184, BIT(16 + 8) | BIT(8)), /* pdm-sdi0m1 */
-	RK_MUXROUTE_SAME(1, RK_PD3, 2, 0x184, BIT(16 + 10)), /* uart2-rxm0 */
-	RK_MUXROUTE_SAME(2, RK_PB6, 2, 0x184, BIT(16 + 10) | BIT(10)), /* uart2-rxm1 */
-	RK_MUXROUTE_SAME(1, RK_PD2, 2, 0x184, BIT(16 + 10)), /* uart2-txm0 */
-	RK_MUXROUTE_SAME(2, RK_PB4, 2, 0x184, BIT(16 + 10) | BIT(10)), /* uart2-txm1 */
-	RK_MUXROUTE_SAME(0, RK_PC1, 2, 0x184, BIT(16 + 9)), /* uart3-rxm0 */
-	RK_MUXROUTE_SAME(1, RK_PB7, 2, 0x184, BIT(16 + 9) | BIT(9)), /* uart3-rxm1 */
-	RK_MUXROUTE_SAME(0, RK_PC0, 2, 0x184, BIT(16 + 9)), /* uart3-txm0 */
-	RK_MUXROUTE_SAME(1, RK_PB6, 2, 0x184, BIT(16 + 9) | BIT(9)), /* uart3-txm1 */
-	RK_MUXROUTE_SAME(0, RK_PC2, 2, 0x184, BIT(16 + 9)), /* uart3-ctsm0 */
-	RK_MUXROUTE_SAME(1, RK_PB4, 2, 0x184, BIT(16 + 9) | BIT(9)), /* uart3-ctsm1 */
-	RK_MUXROUTE_SAME(0, RK_PC3, 2, 0x184, BIT(16 + 9)), /* uart3-rtsm0 */
-	RK_MUXROUTE_SAME(1, RK_PB5, 2, 0x184, BIT(16 + 9) | BIT(9)), /* uart3-rtsm1 */
-};
-
 static struct rockchip_mux_route_data rv1126_mux_route_data[] = {
 	RK_MUXROUTE_GRF(3, RK_PD2, 1, 0x10260, WRITE_MASK_VAL(0, 0, 0)), /* I2S0_MCLK_M0 */
 	RK_MUXROUTE_GRF(3, RK_PB0, 3, 0x10260, WRITE_MASK_VAL(0, 0, 1)), /* I2S0_MCLK_M1 */
@@ -825,6 +797,54 @@ static struct rockchip_mux_route_data rv1126_mux_route_data[] = {
 	RK_MUXROUTE_PMU(1, RK_PD0, 5, 0x0118, WRITE_MASK_VAL(2, 2, 1)), /* UART1_TX_M1 */
 };
 
+static void rockchip_get_recalced_mux(struct rockchip_pin_bank *bank, int pin,
+				      int *reg, u8 *bit, int *mask)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+	struct rockchip_pin_ctrl *ctrl = info->ctrl;
+	struct rockchip_mux_recalced_data *data;
+	int i;
+
+	for (i = 0; i < ctrl->niomux_recalced; i++) {
+		data = &ctrl->iomux_recalced[i];
+		if (data->num == bank->bank_num &&
+		    data->pin == pin)
+			break;
+	}
+
+	if (i >= ctrl->niomux_recalced)
+		return;
+
+	*reg = data->reg;
+	*mask = data->mask;
+	*bit = data->bit;
+}
+
+static struct rockchip_mux_route_data rk1808_mux_route_data[] = {
+	RK_MUXROUTE_SAME(3, RK_PB4, 2, 0x190, BIT(16 + 3)), /* i2c2m0_sda */
+	RK_MUXROUTE_SAME(1, RK_PB5, 2, 0x190, BIT(16 + 3) | BIT(3)), /* i2c2m1_sda */
+	RK_MUXROUTE_SAME(1, RK_PA6, 2, 0x190, BIT(16 + 4)), /* spi2m0_miso */
+	RK_MUXROUTE_SAME(2, RK_PA4, 3, 0x190, BIT(16 + 4) | BIT(4)), /* spi2m1_miso */
+	RK_MUXROUTE_SAME(4, RK_PB7, 2, 0x190, BIT(16 + 5)), /* spi1m0_miso */
+	RK_MUXROUTE_SAME(3, RK_PD2, 3, 0x190, BIT(16 + 5) | BIT(5)), /* spi1m1_miso */
+	RK_MUXROUTE_SAME(4, RK_PB0, 2, 0x190, BIT(16 + 13)), /* uart1_rxm0 */
+	RK_MUXROUTE_SAME(1, RK_PB4, 3, 0x190, BIT(16 + 13) | BIT(13)), /* uart1_rxm1 */
+	RK_MUXROUTE_SAME(4, RK_PA3, 2, 0x190, BIT(16 + 14) | BIT(16 + 15)), /* uart2_rxm0 */
+	RK_MUXROUTE_SAME(2, RK_PD1, 2, 0x190, BIT(16 + 14) | BIT(16 + 15) | BIT(14)), /* uart2_rxm1 */
+	RK_MUXROUTE_SAME(3, RK_PA4, 2, 0x190, BIT(16 + 14) | BIT(16 + 15) | BIT(15)), /* uart2_rxm2 */
+};
+
+static struct rockchip_mux_route_data px30_mux_route_data[] = {
+	RK_MUXROUTE_SAME(2, RK_PA0, 1, 0x184, BIT(16 + 7)), /* cif-d2m0 */
+	RK_MUXROUTE_SAME(3, RK_PA3, 3, 0x184, BIT(16 + 7) | BIT(7)), /* cif-d2m1 */
+	RK_MUXROUTE_SAME(3, RK_PC6, 2, 0x184, BIT(16 + 8)), /* pdm-m0 */
+	RK_MUXROUTE_SAME(2, RK_PC6, 1, 0x184, BIT(16 + 8) | BIT(8)), /* pdm-m1 */
+	RK_MUXROUTE_SAME(1, RK_PD3, 2, 0x184, BIT(16 + 10)), /* uart2-rxm0 */
+	RK_MUXROUTE_SAME(2, RK_PB6, 2, 0x184, BIT(16 + 10) | BIT(10)), /* uart2-rxm1 */
+	RK_MUXROUTE_SAME(0, RK_PC1, 2, 0x184, BIT(16 + 9)), /* uart3-rxm0 */
+	RK_MUXROUTE_SAME(1, RK_PB7, 2, 0x184, BIT(16 + 9) | BIT(9)), /* uart3-rxm1 */
+};
+
 static struct rockchip_mux_route_data rk3128_mux_route_data[] = {
 	RK_MUXROUTE_SAME(1, RK_PB2, 1, 0x144, BIT(16 + 3) | BIT(16 + 4)), /* spi-0 */
 	RK_MUXROUTE_SAME(1, RK_PD3, 3, 0x144, BIT(16 + 3) | BIT(16 + 4) | BIT(3)), /* spi-1 */
@@ -935,6 +955,7 @@ static struct rockchip_mux_route_data rk3568_mux_route_data[] = {
 	RK_MUXROUTE_GRF(0, RK_PC2, 2, 0x0300, WRITE_MASK_VAL(6, 6, 1)), /* HPDIN IO mux M1 */
 	RK_MUXROUTE_GRF(3, RK_PB1, 3, 0x0300, WRITE_MASK_VAL(8, 8, 0)), /* GMAC1 IO mux M0 */
 	RK_MUXROUTE_GRF(4, RK_PA7, 3, 0x0300, WRITE_MASK_VAL(8, 8, 1)), /* GMAC1 IO mux M1 */
+	RK_MUXROUTE_GRF(4, RK_PB7, 3, 0x0300, WRITE_MASK_VAL(8, 8, 1)), /* GMAC1 IO mux M1 */
 	RK_MUXROUTE_GRF(4, RK_PD1, 1, 0x0300, WRITE_MASK_VAL(10, 10, 0)), /* HDMITX IO mux M0 */
 	RK_MUXROUTE_GRF(0, RK_PC7, 1, 0x0300, WRITE_MASK_VAL(10, 10, 1)), /* HDMITX IO mux M1 */
 	RK_MUXROUTE_GRF(0, RK_PB6, 1, 0x0300, WRITE_MASK_VAL(14, 14, 0)), /* I2C2 IO mux M0 */
@@ -1098,7 +1119,7 @@ static int rockchip_get_mux(struct rockchip_pin_bank *bank, int pin)
 				if (ret)
 					return ret;
 
-				if (!(val & BIT(8)))
+				if (((val >> bit) & mask) != 8)
 					return ((val >> bit) & mask);
 
 				reg = reg + 0x8000; /* BUS_IOC_BASE */
@@ -1202,15 +1223,36 @@ static int rockchip_set_mux(struct rockchip_pin_bank *bank, int pin, int mux)
 	if (bank->recalced_mask & BIT(pin))
 		rockchip_get_recalced_mux(bank, pin, &reg, &bit, &mask);
 
+	/* rk3562 force jtag m1 */
+	if (ctrl->type == RK3562) {
+		if (bank->bank_num == 1) {
+			if ((pin == RK_PB5) || (pin == RK_PB6)) {
+				if (mux == 1) {
+					regmap_update_bits(regmap, 0x504, 0x10001, 0x10001);
+				} else {
+					regmap_update_bits(regmap, 0x504, 0x10001, 0x10000);
+				}
+			}
+		}
+	}
+
 	if (ctrl->type == RK3588) {
 		if (bank->bank_num == 0) {
 			if ((pin >= RK_PB4) && (pin <= RK_PD7)) {
 				if (mux < 8) {
-					reg += 0x4000 - 0xC; /* PMU2_IOC_BASE */
+					u32 reg0 = 0;
+
+					reg0 = reg + 0x4000 - 0xC; /* PMU2_IOC_BASE */
 					data = (mask << (bit + 16));
 					rmask = data | (data >> 16);
 					data |= (mux & mask) << bit;
-					ret = regmap_update_bits(regmap, reg, rmask, data);
+					ret = regmap_update_bits(regmap, reg0, rmask, data);
+
+					reg0 = reg + 0x8000; /* BUS_IOC_BASE */
+					data = (mask << (bit + 16));
+					rmask = data | (data >> 16);
+					regmap = info->regmap_base;
+					ret |= regmap_update_bits(regmap, reg0, rmask, data);
 				} else {
 					u32 reg0 = 0;
 
@@ -1223,7 +1265,7 @@ static int rockchip_set_mux(struct rockchip_pin_bank *bank, int pin, int mux)
 					reg0 = reg + 0x8000; /* BUS_IOC_BASE */
 					data = (mask << (bit + 16));
 					rmask = data | (data >> 16);
-					data |= mux << bit;
+					data |= (mux & mask) << bit;
 					regmap = info->regmap_base;
 					ret |= regmap_update_bits(regmap, reg0, rmask, data);
 				}
@@ -1263,10 +1305,20 @@ static int rockchip_set_mux(struct rockchip_pin_bank *bank, int pin, int mux)
 		}
 	}
 
-	data = (mask << (bit + 16));
-	rmask = data | (data >> 16);
-	data |= (mux & mask) << bit;
-	ret = regmap_update_bits(regmap, reg, rmask, data);
+	if (mux_type & IOMUX_WRITABLE_32BIT) {
+		ret = regmap_read(regmap, reg, &data);
+		if (ret)
+			return ret;
+
+		data &= ~(mask << bit);
+		data |= (mux & mask) << bit;
+		ret = regmap_write(regmap, reg, data);
+	} else {
+		data = (mask << (bit + 16));
+		rmask = data | (data >> 16);
+		data |= (mux & mask) << bit;
+		ret = regmap_update_bits(regmap, reg, rmask, data);
+	}
 
 	return ret;
 }
@@ -1366,68 +1418,228 @@ static int px30_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,
 	return 0;
 }
 
-#define RV1108_PULL_PMU_OFFSET		0x10
-#define RV1108_PULL_OFFSET		0x110
-#define RV1108_PULL_PINS_PER_REG	8
-#define RV1108_PULL_BITS_PER_PIN	2
-#define RV1108_PULL_BANK_STRIDE		16
+#define RV1106_DRV_BITS_PER_PIN		8
+#define RV1106_DRV_PINS_PER_REG		2
+#define RV1106_DRV_GPIO0_OFFSET		0x10
+#define RV1106_DRV_GPIO1_OFFSET		0x80
+#define RV1106_DRV_GPIO2_OFFSET		0x100C0
+#define RV1106_DRV_GPIO3_OFFSET		0x20100
+#define RV1106_DRV_GPIO4_OFFSET		0x30020
 
-static int rv1108_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,
-					int pin_num, struct regmap **regmap,
-					int *reg, u8 *bit)
+static int rv1106_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,
+				       int pin_num, struct regmap **regmap,
+				       int *reg, u8 *bit)
 {
 	struct rockchip_pinctrl *info = bank->drvdata;
 
-	/* The first 24 pins of the first bank are located in PMU */
-	if (bank->bank_num == 0) {
+	/* GPIO0_IOC is located in PMU */
+	switch (bank->bank_num) {
+	case 0:
 		*regmap = info->regmap_pmu;
-		*reg = RV1108_PULL_PMU_OFFSET;
-	} else {
-		*reg = RV1108_PULL_OFFSET;
+		*reg = RV1106_DRV_GPIO0_OFFSET;
+		break;
+
+	case 1:
 		*regmap = info->regmap_base;
-		/* correct the offset, as we're starting with the 2nd bank */
-		*reg -= 0x10;
-		*reg += bank->bank_num * RV1108_PULL_BANK_STRIDE;
+		*reg = RV1106_DRV_GPIO1_OFFSET;
+		break;
+
+	case 2:
+		*regmap = info->regmap_base;
+		*reg = RV1106_DRV_GPIO2_OFFSET;
+		break;
+
+	case 3:
+		*regmap = info->regmap_base;
+		*reg = RV1106_DRV_GPIO3_OFFSET;
+		break;
+
+	case 4:
+		*regmap = info->regmap_base;
+		*reg = RV1106_DRV_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
 	}
 
-	*reg += ((pin_num / RV1108_PULL_PINS_PER_REG) * 4);
-	*bit = (pin_num % RV1108_PULL_PINS_PER_REG);
-	*bit *= RV1108_PULL_BITS_PER_PIN;
+	*reg += ((pin_num / RV1106_DRV_PINS_PER_REG) * 4);
+	*bit = pin_num % RV1106_DRV_PINS_PER_REG;
+	*bit *= RV1106_DRV_BITS_PER_PIN;
 
 	return 0;
 }
 
-#define RV1108_DRV_PMU_OFFSET		0x20
-#define RV1108_DRV_GRF_OFFSET		0x210
-#define RV1108_DRV_BITS_PER_PIN		2
-#define RV1108_DRV_PINS_PER_REG		8
-#define RV1108_DRV_BANK_STRIDE		16
+#define RV1106_PULL_BITS_PER_PIN		2
+#define RV1106_PULL_PINS_PER_REG		8
+#define RV1106_PULL_GPIO0_OFFSET		0x38
+#define RV1106_PULL_GPIO1_OFFSET		0x1C0
+#define RV1106_PULL_GPIO2_OFFSET		0x101D0
+#define RV1106_PULL_GPIO3_OFFSET		0x201E0
+#define RV1106_PULL_GPIO4_OFFSET		0x30070
 
-static int rv1108_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,
-				       int pin_num, struct regmap **regmap,
-				       int *reg, u8 *bit)
+static int rv1106_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,
+					int pin_num, struct regmap **regmap,
+					int *reg, u8 *bit)
 {
 	struct rockchip_pinctrl *info = bank->drvdata;
 
-	/* The first 24 pins of the first bank are located in PMU */
-	if (bank->bank_num == 0) {
+	/* GPIO0_IOC is located in PMU */
+	switch (bank->bank_num) {
+	case 0:
 		*regmap = info->regmap_pmu;
-		*reg = RV1108_DRV_PMU_OFFSET;
-	} else {
+		*reg = RV1106_PULL_GPIO0_OFFSET;
+		break;
+
+	case 1:
 		*regmap = info->regmap_base;
-		*reg = RV1108_DRV_GRF_OFFSET;
+		*reg = RV1106_PULL_GPIO1_OFFSET;
+		break;
 
-		/* correct the offset, as we're starting with the 2nd bank */
-		*reg -= 0x10;
-		*reg += bank->bank_num * RV1108_DRV_BANK_STRIDE;
-	}
+	case 2:
+		*regmap = info->regmap_base;
+		*reg = RV1106_PULL_GPIO2_OFFSET;
+		break;
 
-	*reg += ((pin_num / RV1108_DRV_PINS_PER_REG) * 4);
-	*bit = pin_num % RV1108_DRV_PINS_PER_REG;
-	*bit *= RV1108_DRV_BITS_PER_PIN;
+	case 3:
+		*regmap = info->regmap_base;
+		*reg = RV1106_PULL_GPIO3_OFFSET;
+		break;
 
-	return 0;
-}
+	case 4:
+		*regmap = info->regmap_base;
+		*reg = RV1106_PULL_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
+	}
+
+	*reg += ((pin_num / RV1106_PULL_PINS_PER_REG) * 4);
+	*bit = pin_num % RV1106_PULL_PINS_PER_REG;
+	*bit *= RV1106_PULL_BITS_PER_PIN;
+
+	return 0;
+}
+
+#define RV1106_SMT_BITS_PER_PIN		1
+#define RV1106_SMT_PINS_PER_REG		8
+#define RV1106_SMT_GPIO0_OFFSET		0x40
+#define RV1106_SMT_GPIO1_OFFSET		0x280
+#define RV1106_SMT_GPIO2_OFFSET		0x10290
+#define RV1106_SMT_GPIO3_OFFSET		0x202A0
+#define RV1106_SMT_GPIO4_OFFSET		0x300A0
+
+static int rv1106_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,
+					   int pin_num,
+					   struct regmap **regmap,
+					   int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	/* GPIO0_IOC is located in PMU */
+	switch (bank->bank_num) {
+	case 0:
+		*regmap = info->regmap_pmu;
+		*reg = RV1106_SMT_GPIO0_OFFSET;
+		break;
+
+	case 1:
+		*regmap = info->regmap_base;
+		*reg = RV1106_SMT_GPIO1_OFFSET;
+		break;
+
+	case 2:
+		*regmap = info->regmap_base;
+		*reg = RV1106_SMT_GPIO2_OFFSET;
+		break;
+
+	case 3:
+		*regmap = info->regmap_base;
+		*reg = RV1106_SMT_GPIO3_OFFSET;
+		break;
+
+	case 4:
+		*regmap = info->regmap_base;
+		*reg = RV1106_SMT_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
+	}
+
+	*reg += ((pin_num / RV1106_SMT_PINS_PER_REG) * 4);
+	*bit = pin_num % RV1106_SMT_PINS_PER_REG;
+	*bit *= RV1106_SMT_BITS_PER_PIN;
+
+	return 0;
+}
+
+#define RV1108_PULL_PMU_OFFSET		0x10
+#define RV1108_PULL_OFFSET		0x110
+#define RV1108_PULL_PINS_PER_REG	8
+#define RV1108_PULL_BITS_PER_PIN	2
+#define RV1108_PULL_BANK_STRIDE		16
+
+static int rv1108_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,
+					int pin_num, struct regmap **regmap,
+					int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	/* The first 24 pins of the first bank are located in PMU */
+	if (bank->bank_num == 0) {
+		*regmap = info->regmap_pmu;
+		*reg = RV1108_PULL_PMU_OFFSET;
+	} else {
+		*reg = RV1108_PULL_OFFSET;
+		*regmap = info->regmap_base;
+		/* correct the offset, as we're starting with the 2nd bank */
+		*reg -= 0x10;
+		*reg += bank->bank_num * RV1108_PULL_BANK_STRIDE;
+	}
+
+	*reg += ((pin_num / RV1108_PULL_PINS_PER_REG) * 4);
+	*bit = (pin_num % RV1108_PULL_PINS_PER_REG);
+	*bit *= RV1108_PULL_BITS_PER_PIN;
+
+	return 0;
+}
+
+#define RV1108_DRV_PMU_OFFSET		0x20
+#define RV1108_DRV_GRF_OFFSET		0x210
+#define RV1108_DRV_BITS_PER_PIN		2
+#define RV1108_DRV_PINS_PER_REG		8
+#define RV1108_DRV_BANK_STRIDE		16
+
+static int rv1108_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,
+				       int pin_num, struct regmap **regmap,
+				       int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	/* The first 24 pins of the first bank are located in PMU */
+	if (bank->bank_num == 0) {
+		*regmap = info->regmap_pmu;
+		*reg = RV1108_DRV_PMU_OFFSET;
+	} else {
+		*regmap = info->regmap_base;
+		*reg = RV1108_DRV_GRF_OFFSET;
+
+		/* correct the offset, as we're starting with the 2nd bank */
+		*reg -= 0x10;
+		*reg += bank->bank_num * RV1108_DRV_BANK_STRIDE;
+	}
+
+	*reg += ((pin_num / RV1108_DRV_PINS_PER_REG) * 4);
+	*bit = pin_num % RV1108_DRV_PINS_PER_REG;
+	*bit *= RV1108_DRV_BITS_PER_PIN;
+
+	return 0;
+}
 
 #define RV1108_SCHMITT_PMU_OFFSET		0x30
 #define RV1108_SCHMITT_GRF_OFFSET		0x388
@@ -1460,11 +1672,11 @@ static int rv1108_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,
 }
 
 #define RV1126_PULL_PMU_OFFSET		0x40
-#define RV1126_PULL_GRF_GPIO1A0_OFFSET	0x10108
+#define RV1126_PULL_GRF_GPIO1A0_OFFSET		0x10108
 #define RV1126_PULL_PINS_PER_REG	8
 #define RV1126_PULL_BITS_PER_PIN	2
 #define RV1126_PULL_BANK_STRIDE		16
-#define RV1126_GPIO_C4_D7(p)		(p >= 20 && p <= 31) /* GPIO0_C4 ~ GPIO0_D7 */
+#define RV1126_GPIO_C4_D7(p)	(p >= 20 && p <= 31) /* GPIO0_C4 ~ GPIO0_D7 */
 
 static int rv1126_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,
 					int pin_num, struct regmap **regmap,
@@ -1498,7 +1710,7 @@ static int rv1126_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,
 }
 
 #define RV1126_DRV_PMU_OFFSET		0x20
-#define RV1126_DRV_GRF_GPIO1A0_OFFSET	0x10090
+#define RV1126_DRV_GRF_GPIO1A0_OFFSET		0x10090
 #define RV1126_DRV_BITS_PER_PIN		4
 #define RV1126_DRV_PINS_PER_REG		4
 #define RV1126_DRV_BANK_STRIDE		32
@@ -1536,7 +1748,7 @@ static int rv1126_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,
 }
 
 #define RV1126_SCHMITT_PMU_OFFSET		0x60
-#define RV1126_SCHMITT_GRF_GPIO1A0_OFFSET	0x10188
+#define RV1126_SCHMITT_GRF_GPIO1A0_OFFSET		0x10188
 #define RV1126_SCHMITT_BANK_STRIDE		16
 #define RV1126_SCHMITT_PINS_PER_GRF_REG		8
 #define RV1126_SCHMITT_PINS_PER_PMU_REG		8
@@ -1592,6 +1804,115 @@ static int rk3308_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,
 	return 0;
 }
 
+#define RK1808_PULL_PMU_OFFSET		0x10
+#define RK1808_PULL_GRF_OFFSET		0x80
+#define RK1808_PULL_PINS_PER_REG	8
+#define RK1808_PULL_BITS_PER_PIN	2
+#define RK1808_PULL_BANK_STRIDE		16
+
+static int rk1808_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,
+					int pin_num, struct regmap **regmap,
+					int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	if (bank->bank_num == 0) {
+		*regmap = info->regmap_pmu;
+		*reg = RK1808_PULL_PMU_OFFSET;
+	} else {
+		*reg = RK1808_PULL_GRF_OFFSET;
+		*regmap = info->regmap_base;
+		*reg += (bank->bank_num - 1) * RK1808_PULL_BANK_STRIDE;
+	}
+
+	*reg += ((pin_num / RK1808_PULL_PINS_PER_REG) * 4);
+	*bit = (pin_num % RK1808_PULL_PINS_PER_REG);
+	*bit *= RK1808_PULL_BITS_PER_PIN;
+
+	return 0;
+}
+
+#define RK1808_DRV_PMU_OFFSET		0x20
+#define RK1808_DRV_GRF_OFFSET		0x140
+#define RK1808_DRV_BITS_PER_PIN		2
+#define RK1808_DRV_PINS_PER_REG		8
+#define RK1808_DRV_BANK_STRIDE		16
+
+static int rk1808_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,
+				       int pin_num,
+				       struct regmap **regmap,
+				       int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	if (bank->bank_num == 0) {
+		*regmap = info->regmap_pmu;
+		*reg = RK1808_DRV_PMU_OFFSET;
+	} else {
+		*regmap = info->regmap_base;
+		*reg = RK1808_DRV_GRF_OFFSET;
+		*reg += (bank->bank_num - 1) * RK1808_DRV_BANK_STRIDE;
+	}
+
+	*reg += ((pin_num / RK1808_DRV_PINS_PER_REG) * 4);
+	*bit = pin_num % RK1808_DRV_PINS_PER_REG;
+	*bit *= RK1808_DRV_BITS_PER_PIN;
+
+	return 0;
+}
+
+#define RK1808_SR_PMU_OFFSET		0x0030
+#define RK1808_SR_GRF_OFFSET		0x00c0
+#define RK1808_SR_BANK_STRIDE		16
+#define RK1808_SR_PINS_PER_REG		8
+
+static int rk1808_calc_slew_rate_reg_and_bit(struct rockchip_pin_bank *bank,
+					   int pin_num,
+					   struct regmap **regmap,
+					   int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	if (bank->bank_num == 0) {
+		*regmap = info->regmap_pmu;
+		*reg = RK1808_SR_PMU_OFFSET;
+	} else {
+		*regmap = info->regmap_base;
+		*reg = RK1808_SR_GRF_OFFSET;
+		*reg += (bank->bank_num  - 1) * RK1808_SR_BANK_STRIDE;
+	}
+	*reg += ((pin_num / RK1808_SR_PINS_PER_REG) * 4);
+	*bit = pin_num % RK1808_SR_PINS_PER_REG;
+
+	return 0;
+}
+
+#define RK1808_SCHMITT_PMU_OFFSET		0x0040
+#define RK1808_SCHMITT_GRF_OFFSET		0x0100
+#define RK1808_SCHMITT_BANK_STRIDE		16
+#define RK1808_SCHMITT_PINS_PER_REG		8
+
+static int rk1808_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,
+					   int pin_num,
+					   struct regmap **regmap,
+					   int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	if (bank->bank_num == 0) {
+		*regmap = info->regmap_pmu;
+		*reg = RK1808_SCHMITT_PMU_OFFSET;
+	} else {
+		*regmap = info->regmap_base;
+		*reg = RK1808_SCHMITT_GRF_OFFSET;
+		*reg += (bank->bank_num  - 1) * RK1808_SCHMITT_BANK_STRIDE;
+	}
+	*reg += ((pin_num / RK1808_SCHMITT_PINS_PER_REG) * 4);
+	*bit = pin_num % RK1808_SCHMITT_PINS_PER_REG;
+
+	return 0;
+}
+
 #define RK2928_PULL_OFFSET		0x118
 #define RK2928_PULL_PINS_PER_REG	16
 #define RK2928_PULL_BANK_STRIDE		8
@@ -1815,6 +2136,29 @@ static int rk3308_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,
 	return 0;
 }
 
+#define RK3308_SLEW_RATE_GRF_OFFSET		0x150
+#define RK3308_SLEW_RATE_BANK_STRIDE		16
+#define RK3308_SLEW_RATE_PINS_PER_GRF_REG	8
+
+static int rk3308_calc_slew_rate_reg_and_bit(struct rockchip_pin_bank *bank,
+					     int pin_num,
+					     struct regmap **regmap,
+					     int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+	int pins_per_reg;
+
+	*regmap = info->regmap_base;
+	*reg = RK3308_SLEW_RATE_GRF_OFFSET;
+	*reg += (bank->bank_num) * RK3308_SLEW_RATE_BANK_STRIDE;
+	pins_per_reg = RK3308_SLEW_RATE_PINS_PER_GRF_REG;
+
+	*reg += ((pin_num / pins_per_reg) * 4);
+	*bit = pin_num % pins_per_reg;
+
+	return 0;
+}
+
 #define RK3368_PULL_GRF_OFFSET		0x100
 #define RK3368_PULL_PMU_OFFSET		0x10
 
@@ -1940,6 +2284,323 @@ static int rk3399_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,
 	return 0;
 }
 
+#define RK3528_DRV_BITS_PER_PIN		8
+#define RK3528_DRV_PINS_PER_REG		2
+#define RK3528_DRV_GPIO0_OFFSET		0x100
+#define RK3528_DRV_GPIO1_OFFSET		0x20120
+#define RK3528_DRV_GPIO2_OFFSET		0x30160
+#define RK3528_DRV_GPIO3_OFFSET		0x20190
+#define RK3528_DRV_GPIO4_OFFSET		0x101C0
+
+static int rk3528_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,
+				       int pin_num, struct regmap **regmap,
+				       int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	*regmap = info->regmap_base;
+	switch (bank->bank_num) {
+	case 0:
+		*reg = RK3528_DRV_GPIO0_OFFSET;
+		break;
+
+	case 1:
+		*reg = RK3528_DRV_GPIO1_OFFSET;
+		break;
+
+	case 2:
+		*reg = RK3528_DRV_GPIO2_OFFSET;
+		break;
+
+	case 3:
+		*reg = RK3528_DRV_GPIO3_OFFSET;
+		break;
+
+	case 4:
+		*reg = RK3528_DRV_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
+	}
+
+	*reg += ((pin_num / RK3528_DRV_PINS_PER_REG) * 4);
+	*bit = pin_num % RK3528_DRV_PINS_PER_REG;
+	*bit *= RK3528_DRV_BITS_PER_PIN;
+
+	return 0;
+}
+
+#define RK3528_PULL_BITS_PER_PIN		2
+#define RK3528_PULL_PINS_PER_REG		8
+#define RK3528_PULL_GPIO0_OFFSET		0x200
+#define RK3528_PULL_GPIO1_OFFSET		0x20210
+#define RK3528_PULL_GPIO2_OFFSET		0x30220
+#define RK3528_PULL_GPIO3_OFFSET		0x20230
+#define RK3528_PULL_GPIO4_OFFSET		0x10240
+
+static int rk3528_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,
+					int pin_num, struct regmap **regmap,
+					int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	*regmap = info->regmap_base;
+	switch (bank->bank_num) {
+	case 0:
+		*reg = RK3528_PULL_GPIO0_OFFSET;
+		break;
+
+	case 1:
+		*reg = RK3528_PULL_GPIO1_OFFSET;
+		break;
+
+	case 2:
+		*reg = RK3528_PULL_GPIO2_OFFSET;
+		break;
+
+	case 3:
+		*reg = RK3528_PULL_GPIO3_OFFSET;
+		break;
+
+	case 4:
+		*reg = RK3528_PULL_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
+	}
+
+	*reg += ((pin_num / RK3528_PULL_PINS_PER_REG) * 4);
+	*bit = pin_num % RK3528_PULL_PINS_PER_REG;
+	*bit *= RK3528_PULL_BITS_PER_PIN;
+
+	return 0;
+}
+
+#define RK3528_SMT_BITS_PER_PIN		1
+#define RK3528_SMT_PINS_PER_REG		8
+#define RK3528_SMT_GPIO0_OFFSET		0x400
+#define RK3528_SMT_GPIO1_OFFSET		0x20410
+#define RK3528_SMT_GPIO2_OFFSET		0x30420
+#define RK3528_SMT_GPIO3_OFFSET		0x20430
+#define RK3528_SMT_GPIO4_OFFSET		0x10440
+
+static int rk3528_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,
+					   int pin_num,
+					   struct regmap **regmap,
+					   int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	*regmap = info->regmap_base;
+	switch (bank->bank_num) {
+	case 0:
+		*reg = RK3528_SMT_GPIO0_OFFSET;
+		break;
+
+	case 1:
+		*reg = RK3528_SMT_GPIO1_OFFSET;
+		break;
+
+	case 2:
+		*reg = RK3528_SMT_GPIO2_OFFSET;
+		break;
+
+	case 3:
+		*reg = RK3528_SMT_GPIO3_OFFSET;
+		break;
+
+	case 4:
+		*reg = RK3528_SMT_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
+	}
+
+	*reg += ((pin_num / RK3528_SMT_PINS_PER_REG) * 4);
+	*bit = pin_num % RK3528_SMT_PINS_PER_REG;
+	*bit *= RK3528_SMT_BITS_PER_PIN;
+	return 0;
+}
+
+#define RK3562_DRV_BITS_PER_PIN		8
+#define RK3562_DRV_PINS_PER_REG		2
+#define RK3562_DRV_GPIO0_OFFSET		0x20070
+#define RK3562_DRV_GPIO1_OFFSET		0x200
+#define RK3562_DRV_GPIO2_OFFSET		0x240
+#define RK3562_DRV_GPIO3_OFFSET		0x10280
+#define RK3562_DRV_GPIO4_OFFSET		0x102C0
+
+static int rk3562_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,
+				       int pin_num, struct regmap **regmap,
+				       int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	*regmap = info->regmap_base;
+	switch (bank->bank_num) {
+	case 0:
+		*reg = RK3562_DRV_GPIO0_OFFSET;
+		break;
+
+	case 1:
+		*reg = RK3562_DRV_GPIO1_OFFSET;
+		break;
+
+	case 2:
+		*reg = RK3562_DRV_GPIO2_OFFSET;
+		break;
+
+	case 3:
+		*reg = RK3562_DRV_GPIO3_OFFSET;
+		break;
+
+	case 4:
+		*reg = RK3562_DRV_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
+	}
+
+	*reg += ((pin_num / RK3562_DRV_PINS_PER_REG) * 4);
+	*bit = pin_num % RK3562_DRV_PINS_PER_REG;
+	*bit *= RK3562_DRV_BITS_PER_PIN;
+
+	return 0;
+}
+
+#define RK3562_PULL_BITS_PER_PIN		2
+#define RK3562_PULL_PINS_PER_REG		8
+#define RK3562_PULL_GPIO0_OFFSET		0x20020
+#define RK3562_PULL_GPIO1_OFFSET		0x80
+#define RK3562_PULL_GPIO2_OFFSET		0x90
+#define RK3562_PULL_GPIO3_OFFSET		0x100A0
+#define RK3562_PULL_GPIO4_OFFSET		0x100B0
+
+static int rk3562_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,
+					int pin_num, struct regmap **regmap,
+					int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	*regmap = info->regmap_base;
+	switch (bank->bank_num) {
+	case 0:
+		*reg = RK3562_PULL_GPIO0_OFFSET;
+		break;
+
+	case 1:
+		*reg = RK3562_PULL_GPIO1_OFFSET;
+		break;
+
+	case 2:
+		*reg = RK3562_PULL_GPIO2_OFFSET;
+		break;
+
+	case 3:
+		*reg = RK3562_PULL_GPIO3_OFFSET;
+		break;
+
+	case 4:
+		*reg = RK3562_PULL_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
+	}
+
+	*reg += ((pin_num / RK3562_PULL_PINS_PER_REG) * 4);
+	*bit = pin_num % RK3562_PULL_PINS_PER_REG;
+	*bit *= RK3562_PULL_BITS_PER_PIN;
+
+	return 0;
+}
+
+#define RK3562_SMT_BITS_PER_PIN		2
+#define RK3562_SMT_PINS_PER_REG		8
+#define RK3562_SMT_GPIO0_OFFSET		0x20030
+#define RK3562_SMT_GPIO1_OFFSET		0xC0
+#define RK3562_SMT_GPIO2_OFFSET		0xD0
+#define RK3562_SMT_GPIO3_OFFSET		0x100E0
+#define RK3562_SMT_GPIO4_OFFSET		0x100F0
+
+static int rk3562_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,
+					   int pin_num,
+					   struct regmap **regmap,
+					   int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	*regmap = info->regmap_base;
+	switch (bank->bank_num) {
+	case 0:
+		*reg = RK3562_SMT_GPIO0_OFFSET;
+		break;
+
+	case 1:
+		*reg = RK3562_SMT_GPIO1_OFFSET;
+		break;
+
+	case 2:
+		*reg = RK3562_SMT_GPIO2_OFFSET;
+		break;
+
+	case 3:
+		*reg = RK3562_SMT_GPIO3_OFFSET;
+		break;
+
+	case 4:
+		*reg = RK3562_SMT_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
+	}
+
+	*reg += ((pin_num / RK3562_SMT_PINS_PER_REG) * 4);
+	*bit = pin_num % RK3562_SMT_PINS_PER_REG;
+	*bit *= RK3562_SMT_BITS_PER_PIN;
+
+	return 0;
+}
+
+#define RK3568_SR_PMU_OFFSET		0x60
+#define RK3568_SR_GRF_OFFSET		0x0180
+#define RK3568_SR_BANK_STRIDE		0x10
+#define RK3568_SR_BITS_PER_PIN		2
+#define RK3568_SR_PINS_PER_REG		8
+
+static int rk3568_calc_slew_rate_reg_and_bit(struct rockchip_pin_bank *bank,
+					     int pin_num,
+					     struct regmap **regmap,
+					     int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	if (bank->bank_num == 0) {
+		*regmap = info->regmap_pmu;
+		*reg = RK3568_SR_PMU_OFFSET;
+	} else {
+		*regmap = info->regmap_base;
+		*reg = RK3568_SR_GRF_OFFSET;
+		*reg += (bank->bank_num  - 1) * RK3568_SR_BANK_STRIDE;
+	}
+	*reg += ((pin_num / RK3568_SR_PINS_PER_REG) * 4);
+	*bit = pin_num % RK3568_SR_PINS_PER_REG;
+	*bit *= RK3568_SR_BITS_PER_PIN;
+
+	return 0;
+}
+
 #define RK3568_PULL_PMU_OFFSET		0x20
 #define RK3568_PULL_GRF_OFFSET		0x80
 #define RK3568_PULL_BITS_PER_PIN	2
@@ -2003,6 +2664,12 @@ static int rk3568_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,
 		*bit *= RK3568_DRV_BITS_PER_PIN;
 	}
 
+	if (rockchip_get_cpu_version() == 0)
+		if ((bank->bank_num == 1 && (pin_num == 15 || pin_num == 23 || pin_num == 31)) ||
+		    ((bank->bank_num == 2 || bank->bank_num == 3 || bank->bank_num == 4) &&
+		     (pin_num == 7 || pin_num == 15 || pin_num == 23 || pin_num == 31)))
+			*bit -= RK3568_DRV_BITS_PER_PIN;
+
 	return 0;
 }
 
@@ -2056,7 +2723,6 @@ static const u32 rk3588_ds_regs[][2] = {
 	{RK_GPIO4_C2, RK3588_VCCIO3_5_IOC_REG + 0x0090},
 	{RK_GPIO4_C4, RK3588_VCCIO3_5_IOC_REG + 0x0094},
 	{RK_GPIO4_D0, RK3588_VCCIO2_IOC_REG + 0x0098},
-	{RK_GPIO4_D4, RK3588_VCCIO2_IOC_REG + 0x009C},
 };
 
 static const u32 rk3588_p_regs[][2] = {
@@ -2070,7 +2736,7 @@ static const u32 rk3588_p_regs[][2] = {
 	{RK_GPIO1_C0, RK3588_VCCIO1_4_IOC_REG + 0x0118},
 	{RK_GPIO1_D0, RK3588_VCCIO1_4_IOC_REG + 0x011C},
 	{RK_GPIO2_A0, RK3588_EMMC_IOC_REG + 0x0120},
-	{RK_GPIO2_A6, RK3588_VCCIO3_5_IOC_REG + 0x0120},
+	{RK_GPIO2_A4, RK3588_VCCIO3_5_IOC_REG + 0x0120},
 	{RK_GPIO2_B0, RK3588_VCCIO3_5_IOC_REG + 0x0124},
 	{RK_GPIO2_C0, RK3588_VCCIO3_5_IOC_REG + 0x0128},
 	{RK_GPIO2_D0, RK3588_EMMC_IOC_REG + 0x012C},
@@ -2096,7 +2762,7 @@ static const u32 rk3588_smt_regs[][2] = {
 	{RK_GPIO1_C0, RK3588_VCCIO1_4_IOC_REG + 0x0218},
 	{RK_GPIO1_D0, RK3588_VCCIO1_4_IOC_REG + 0x021C},
 	{RK_GPIO2_A0, RK3588_EMMC_IOC_REG + 0x0220},
-	{RK_GPIO2_A6, RK3588_VCCIO3_5_IOC_REG + 0x0220},
+	{RK_GPIO2_A4, RK3588_VCCIO3_5_IOC_REG + 0x0220},
 	{RK_GPIO2_B0, RK3588_VCCIO3_5_IOC_REG + 0x0224},
 	{RK_GPIO2_C0, RK3588_VCCIO3_5_IOC_REG + 0x0228},
 	{RK_GPIO2_D0, RK3588_EMMC_IOC_REG + 0x022C},
@@ -2126,14 +2792,17 @@ static int rk3588_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,
 	for (i = ARRAY_SIZE(rk3588_p_regs) - 1; i >= 0; i--) {
 		if (pin >= rk3588_p_regs[i][0]) {
 			*reg = rk3588_p_regs[i][1];
-			*regmap = info->regmap_base;
-			*bit = pin_num % RK3588_PULL_PINS_PER_REG;
-			*bit *= RK3588_PULL_BITS_PER_PIN;
-			return 0;
+			break;
 		}
+		BUG_ON(i == 0);
 	}
 
-	return -EINVAL;
+	*regmap = info->regmap_base;
+	*reg += ((pin - rk3588_p_regs[i][0]) / RK3588_PULL_PINS_PER_REG) * 4;
+	*bit = pin_num % RK3588_PULL_PINS_PER_REG;
+	*bit *= RK3588_PULL_BITS_PER_PIN;
+
+	return 0;
 }
 
 #define RK3588_DRV_BITS_PER_PIN		4
@@ -2151,14 +2820,17 @@ static int rk3588_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,
 	for (i = ARRAY_SIZE(rk3588_ds_regs) - 1; i >= 0; i--) {
 		if (pin >= rk3588_ds_regs[i][0]) {
 			*reg = rk3588_ds_regs[i][1];
-			*regmap = info->regmap_base;
-			*bit = pin_num % RK3588_DRV_PINS_PER_REG;
-			*bit *= RK3588_DRV_BITS_PER_PIN;
-			return 0;
+			break;
 		}
+		BUG_ON(i == 0);
 	}
 
-	return -EINVAL;
+	*regmap = info->regmap_base;
+	*reg += ((pin - rk3588_ds_regs[i][0]) / RK3588_DRV_PINS_PER_REG) * 4;
+	*bit = pin_num % RK3588_DRV_PINS_PER_REG;
+	*bit *= RK3588_DRV_BITS_PER_PIN;
+
+	return 0;
 }
 
 #define RK3588_SMT_BITS_PER_PIN		1
@@ -2177,14 +2849,17 @@ static int rk3588_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,
 	for (i = ARRAY_SIZE(rk3588_smt_regs) - 1; i >= 0; i--) {
 		if (pin >= rk3588_smt_regs[i][0]) {
 			*reg = rk3588_smt_regs[i][1];
-			*regmap = info->regmap_base;
-			*bit = pin_num % RK3588_SMT_PINS_PER_REG;
-			*bit *= RK3588_SMT_BITS_PER_PIN;
-			return 0;
+			break;
 		}
+		BUG_ON(i == 0);
 	}
 
-	return -EINVAL;
+	*regmap = info->regmap_base;
+	*reg += ((pin - rk3588_smt_regs[i][0]) / RK3588_SMT_PINS_PER_REG) * 4;
+	*bit = pin_num % RK3588_SMT_PINS_PER_REG;
+	*bit *= RK3588_SMT_BITS_PER_PIN;
+
+	return 0;
 }
 
 static int rockchip_perpin_drv_list[DRV_TYPE_MAX][8] = {
@@ -2192,7 +2867,8 @@ static int rockchip_perpin_drv_list[DRV_TYPE_MAX][8] = {
 	{ 3, 6, 9, 12, -1, -1, -1, -1 },
 	{ 5, 10, 15, 20, -1, -1, -1, -1 },
 	{ 4, 6, 8, 10, 12, 14, 16, 18 },
-	{ 4, 7, 10, 13, 16, 19, 22, 26 }
+	{ 4, 7, 10, 13, 16, 19, 22, 26 },
+	{ 0, 2, 4, 6, 6, 8, 10, 12 }
 };
 
 static int rockchip_get_drive_perpin(struct rockchip_pin_bank *bank,
@@ -2257,6 +2933,7 @@ static int rockchip_get_drive_perpin(struct rockchip_pin_bank *bank,
 	case DRV_TYPE_IO_DEFAULT:
 	case DRV_TYPE_IO_1V8_OR_3V0:
 	case DRV_TYPE_IO_1V8_ONLY:
+	case DRV_TYPE_IO_SMIC:
 		rmask_bits = RK3288_DRV_BITS_PER_PIN;
 		break;
 	default:
@@ -2271,6 +2948,20 @@ static int rockchip_get_drive_perpin(struct rockchip_pin_bank *bank,
 	data >>= bit;
 	data &= (1 << rmask_bits) - 1;
 
+	if (drv_type == DRV_TYPE_IO_SMIC) {
+		u32 tmp = 0;
+
+		ctrl->slew_rate_calc_reg(bank, pin_num, &regmap, &reg, &bit);
+		ret = regmap_read(regmap, reg, &tmp);
+		if (ret)
+			return ret;
+
+		tmp >>= bit;
+		tmp &= 0x1;
+
+		data |= tmp << 2;
+	}
+
 	return rockchip_perpin_drv_list[drv_type][data];
 }
 
@@ -2281,7 +2972,7 @@ static int rockchip_set_drive_perpin(struct rockchip_pin_bank *bank,
 	struct rockchip_pin_ctrl *ctrl = info->ctrl;
 	struct device *dev = info->dev;
 	struct regmap *regmap;
-	int reg, ret, i;
+	int reg, ret, i, err;
 	u32 data, rmask, rmask_bits, temp;
 	u8 bit;
 	int drv_type = bank->drv[pin_num / 8].drv_type;
@@ -2292,22 +2983,20 @@ static int rockchip_set_drive_perpin(struct rockchip_pin_bank *bank,
 	ret = ctrl->drv_calc_reg(bank, pin_num, &regmap, &reg, &bit);
 	if (ret)
 		return ret;
-	if (ctrl->type == RK3588) {
-		rmask_bits = RK3588_DRV_BITS_PER_PIN;
+
+	if (ctrl->type == RV1126 || ctrl->type == RK3588) {
+		rmask_bits = RV1126_DRV_BITS_PER_PIN;
 		ret = strength;
 		goto config;
-	} else if (ctrl->type == RK3568) {
+	} else if (ctrl->type == RV1106 ||
+		   ctrl->type == RK3528 ||
+		   ctrl->type == RK3562 ||
+		   ctrl->type == RK3568) {
 		rmask_bits = RK3568_DRV_BITS_PER_PIN;
 		ret = (1 << (strength + 1)) - 1;
 		goto config;
 	}
 
-	if (ctrl->type == RV1126) {
-		rmask_bits = RV1126_DRV_BITS_PER_PIN;
-		ret = strength;
-		goto config;
-	}
-
 	ret = -EINVAL;
 	for (i = 0; i < ARRAY_SIZE(rockchip_perpin_drv_list[drv_type]); i++) {
 		if (rockchip_perpin_drv_list[drv_type][i] == strength) {
@@ -2343,16 +3032,16 @@ static int rockchip_set_drive_perpin(struct rockchip_pin_bank *bank,
 
 			rmask = BIT(15) | BIT(31);
 			data |= BIT(31);
-			ret = regmap_update_bits(regmap, reg, rmask, data);
-			if (ret)
-				return ret;
+			err = regmap_update_bits(regmap, reg, rmask, data);
+			if (err)
+				return err;
 
 			rmask = 0x3 | (0x3 << 16);
 			temp |= (0x3 << 16);
 			reg += 0x4;
-			ret = regmap_update_bits(regmap, reg, rmask, temp);
+			err = regmap_update_bits(regmap, reg, rmask, temp);
 
-			return ret;
+			return err;
 		case 18 ... 21:
 			/* setting fully enclosed in the second register */
 			reg += 4;
@@ -2367,6 +3056,7 @@ static int rockchip_set_drive_perpin(struct rockchip_pin_bank *bank,
 	case DRV_TYPE_IO_DEFAULT:
 	case DRV_TYPE_IO_1V8_OR_3V0:
 	case DRV_TYPE_IO_1V8_ONLY:
+	case DRV_TYPE_IO_SMIC:
 		rmask_bits = RK3288_DRV_BITS_PER_PIN;
 		break;
 	default:
@@ -2380,9 +3070,44 @@ static int rockchip_set_drive_perpin(struct rockchip_pin_bank *bank,
 	rmask = data | (data >> 16);
 	data |= (ret << bit);
 
-	ret = regmap_update_bits(regmap, reg, rmask, data);
+	err = regmap_update_bits(regmap, reg, rmask, data);
+	if (err)
+		return err;
+
+	if (ctrl->type == RK3568 && rockchip_get_cpu_version() == 0) {
+		if (bank->bank_num == 1 && pin_num == 21)
+			reg = 0x0840;
+		else if (bank->bank_num == 2 && pin_num == 2)
+			reg = 0x0844;
+		else if (bank->bank_num == 2 && pin_num == 8)
+			reg = 0x0848;
+		else if (bank->bank_num == 3 && pin_num == 0)
+			reg = 0x084c;
+		else if (bank->bank_num == 3 && pin_num == 6)
+			reg = 0x0850;
+		else if (bank->bank_num == 4 && pin_num == 0)
+			reg = 0x0854;
+		else
+			return 0;
 
-	return ret;
+		data = ((1 << rmask_bits) - 1) << 16;
+		rmask = data | (data >> 16);
+		data |= (1 << (strength + 1)) - 1;
+
+		err = regmap_update_bits(regmap, reg, rmask, data);
+		if (err)
+			return err;
+	}
+
+	if (drv_type == DRV_TYPE_IO_SMIC) {
+		ctrl->slew_rate_calc_reg(bank, pin_num, &regmap, &reg, &bit);
+		data = BIT(bit + 16) | (((ret >> 2) & 0x1) << bit);
+		err = regmap_write(regmap, reg, data);
+		if (err)
+			return err;
+	}
+
+	return 0;
 }
 
 static int rockchip_pull_list[PULL_TYPE_MAX][4] = {
@@ -2429,25 +3154,22 @@ static int rockchip_get_pull(struct rockchip_pin_bank *bank, int pin_num)
 				? PIN_CONFIG_BIAS_PULL_PIN_DEFAULT
 				: PIN_CONFIG_BIAS_DISABLE;
 	case PX30:
+	case RV1106:
 	case RV1108:
+	case RV1126:
+	case RK1808:
 	case RK3188:
 	case RK3288:
 	case RK3308:
 	case RK3368:
 	case RK3399:
+	case RK3528:
+	case RK3562:
 	case RK3568:
 	case RK3588:
 		pull_type = bank->pull_type[pin_num / 8];
 		data >>= bit;
 		data &= (1 << RK3188_PULL_BITS_PER_PIN) - 1;
-		/*
-		 * In the TRM, pull-up being 1 for everything except the GPIO0_D3-D6,
-		 * where that pull up value becomes 3.
-		 */
-		if (ctrl->type == RK3568 && bank->bank_num == 0 && pin_num >= 27 && pin_num <= 30) {
-			if (data == 3)
-				data = 1;
-		}
 
 		return rockchip_pull_list[pull_type][data];
 	default:
@@ -2486,13 +3208,17 @@ static int rockchip_set_pull(struct rockchip_pin_bank *bank,
 		ret = regmap_write(regmap, reg, data);
 		break;
 	case PX30:
+	case RV1106:
 	case RV1108:
 	case RV1126:
+	case RK1808:
 	case RK3188:
 	case RK3288:
 	case RK3308:
 	case RK3368:
 	case RK3399:
+	case RK3528:
+	case RK3562:
 	case RK3568:
 	case RK3588:
 		pull_type = bank->pull_type[pin_num / 8];
@@ -2552,39 +3278,133 @@ static int rk3328_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,
 	*reg += ((pin_num / RK3328_SCHMITT_PINS_PER_REG) * 4);
 	*bit = pin_num % RK3328_SCHMITT_PINS_PER_REG;
 
-	return 0;
+	return 0;
+}
+
+#define RK3568_SCHMITT_BITS_PER_PIN		2
+#define RK3568_SCHMITT_PINS_PER_REG		8
+#define RK3568_SCHMITT_BANK_STRIDE		0x10
+#define RK3568_SCHMITT_GRF_OFFSET		0xc0
+#define RK3568_SCHMITT_PMUGRF_OFFSET		0x30
+
+static int rk3568_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,
+					   int pin_num,
+					   struct regmap **regmap,
+					   int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	if (bank->bank_num == 0) {
+		*regmap = info->regmap_pmu;
+		*reg = RK3568_SCHMITT_PMUGRF_OFFSET;
+	} else {
+		*regmap = info->regmap_base;
+		*reg = RK3568_SCHMITT_GRF_OFFSET;
+		*reg += (bank->bank_num - 1) * RK3568_SCHMITT_BANK_STRIDE;
+	}
+
+	*reg += ((pin_num / RK3568_SCHMITT_PINS_PER_REG) * 4);
+	*bit = pin_num % RK3568_SCHMITT_PINS_PER_REG;
+	*bit *= RK3568_SCHMITT_BITS_PER_PIN;
+
+	return 0;
+}
+
+static int rockchip_get_schmitt(struct rockchip_pin_bank *bank, int pin_num)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+	struct rockchip_pin_ctrl *ctrl = info->ctrl;
+	struct regmap *regmap;
+	int reg, ret;
+	u8 bit;
+	u32 data;
+
+	ret = ctrl->schmitt_calc_reg(bank, pin_num, &regmap, &reg, &bit);
+	if (ret)
+		return ret;
+
+	ret = regmap_read(regmap, reg, &data);
+	if (ret)
+		return ret;
+
+	data >>= bit;
+	switch (ctrl->type) {
+	case RK3562:
+	case RK3568:
+		return data & ((1 << RK3568_SCHMITT_BITS_PER_PIN) - 1);
+	default:
+		break;
+	}
+
+	return data & 0x1;
+}
+
+static int rockchip_set_schmitt(struct rockchip_pin_bank *bank,
+				int pin_num, int enable)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+	struct rockchip_pin_ctrl *ctrl = info->ctrl;
+	struct device *dev = info->dev;
+	struct regmap *regmap;
+	int reg, ret;
+	u8 bit;
+	u32 data, rmask;
+
+	dev_dbg(dev, "setting input schmitt of GPIO%d-%d to %d\n",
+		bank->bank_num, pin_num, enable);
+
+	ret = ctrl->schmitt_calc_reg(bank, pin_num, &regmap, &reg, &bit);
+	if (ret)
+		return ret;
+
+	/* enable the write to the equivalent lower bits */
+	switch (ctrl->type) {
+	case RK3562:
+	case RK3568:
+		data = ((1 << RK3568_SCHMITT_BITS_PER_PIN) - 1) << (bit + 16);
+		rmask = data | (data >> 16);
+		data |= ((enable ? 0x2 : 0x1) << bit);
+		break;
+	default:
+		data = BIT(bit + 16) | (enable << bit);
+		rmask = BIT(bit + 16) | BIT(bit);
+		break;
+	}
+
+	return regmap_update_bits(regmap, reg, rmask, data);
 }
 
-#define RK3568_SCHMITT_BITS_PER_PIN		2
-#define RK3568_SCHMITT_PINS_PER_REG		8
-#define RK3568_SCHMITT_BANK_STRIDE		0x10
-#define RK3568_SCHMITT_GRF_OFFSET		0xc0
-#define RK3568_SCHMITT_PMUGRF_OFFSET		0x30
+#define PX30_SLEW_RATE_PMU_OFFSET		0x30
+#define PX30_SLEW_RATE_GRF_OFFSET		0x90
+#define PX30_SLEW_RATE_PINS_PER_PMU_REG		16
+#define PX30_SLEW_RATE_BANK_STRIDE		16
+#define PX30_SLEW_RATE_PINS_PER_GRF_REG		8
 
-static int rk3568_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,
+static int px30_calc_slew_rate_reg_and_bit(struct rockchip_pin_bank *bank,
 					   int pin_num,
 					   struct regmap **regmap,
 					   int *reg, u8 *bit)
 {
 	struct rockchip_pinctrl *info = bank->drvdata;
+	int pins_per_reg;
 
 	if (bank->bank_num == 0) {
 		*regmap = info->regmap_pmu;
-		*reg = RK3568_SCHMITT_PMUGRF_OFFSET;
+		*reg = PX30_SLEW_RATE_PMU_OFFSET;
+		pins_per_reg = PX30_SLEW_RATE_PINS_PER_PMU_REG;
 	} else {
 		*regmap = info->regmap_base;
-		*reg = RK3568_SCHMITT_GRF_OFFSET;
-		*reg += (bank->bank_num - 1) * RK3568_SCHMITT_BANK_STRIDE;
+		*reg = PX30_SLEW_RATE_GRF_OFFSET;
+		pins_per_reg = PX30_SLEW_RATE_PINS_PER_GRF_REG;
+		*reg += (bank->bank_num  - 1) * PX30_SLEW_RATE_BANK_STRIDE;
 	}
-
-	*reg += ((pin_num / RK3568_SCHMITT_PINS_PER_REG) * 4);
-	*bit = pin_num % RK3568_SCHMITT_PINS_PER_REG;
-	*bit *= RK3568_SCHMITT_BITS_PER_PIN;
+	*reg += ((pin_num / pins_per_reg) * 4);
+	*bit = pin_num % pins_per_reg;
 
 	return 0;
 }
 
-static int rockchip_get_schmitt(struct rockchip_pin_bank *bank, int pin_num)
+static int rockchip_get_slew_rate(struct rockchip_pin_bank *bank, int pin_num)
 {
 	struct rockchip_pinctrl *info = bank->drvdata;
 	struct rockchip_pin_ctrl *ctrl = info->ctrl;
@@ -2592,8 +3412,12 @@ static int rockchip_get_schmitt(struct rockchip_pin_bank *bank, int pin_num)
 	int reg, ret;
 	u8 bit;
 	u32 data;
+	int drv_type = bank->drv[pin_num / 8].drv_type;
 
-	ret = ctrl->schmitt_calc_reg(bank, pin_num, &regmap, &reg, &bit);
+	if (drv_type == DRV_TYPE_IO_SMIC)
+		return 0;
+
+	ret = ctrl->slew_rate_calc_reg(bank, pin_num, &regmap, &reg, &bit);
 	if (ret)
 		return ret;
 
@@ -2602,46 +3426,33 @@ static int rockchip_get_schmitt(struct rockchip_pin_bank *bank, int pin_num)
 		return ret;
 
 	data >>= bit;
-	switch (ctrl->type) {
-	case RK3568:
-		return data & ((1 << RK3568_SCHMITT_BITS_PER_PIN) - 1);
-	default:
-		break;
-	}
-
 	return data & 0x1;
 }
 
-static int rockchip_set_schmitt(struct rockchip_pin_bank *bank,
-				int pin_num, int enable)
+static int rockchip_set_slew_rate(struct rockchip_pin_bank *bank,
+				  int pin_num, int speed)
 {
 	struct rockchip_pinctrl *info = bank->drvdata;
 	struct rockchip_pin_ctrl *ctrl = info->ctrl;
-	struct device *dev = info->dev;
 	struct regmap *regmap;
 	int reg, ret;
 	u8 bit;
 	u32 data, rmask;
+	int drv_type = bank->drv[pin_num / 8].drv_type;
 
-	dev_dbg(dev, "setting input schmitt of GPIO%d-%d to %d\n",
-		bank->bank_num, pin_num, enable);
+	if (drv_type == DRV_TYPE_IO_SMIC)
+		return 0;
 
-	ret = ctrl->schmitt_calc_reg(bank, pin_num, &regmap, &reg, &bit);
+	dev_dbg(info->dev, "setting slew rate of GPIO%d-%d to %d\n",
+		bank->bank_num, pin_num, speed);
+
+	ret = ctrl->slew_rate_calc_reg(bank, pin_num, &regmap, &reg, &bit);
 	if (ret)
 		return ret;
 
 	/* enable the write to the equivalent lower bits */
-	switch (ctrl->type) {
-	case RK3568:
-		data = ((1 << RK3568_SCHMITT_BITS_PER_PIN) - 1) << (bit + 16);
-		rmask = data | (data >> 16);
-		data |= ((enable ? 0x2 : 0x1) << bit);
-		break;
-	default:
-		data = BIT(bit + 16) | (enable << bit);
-		rmask = BIT(bit + 16) | BIT(bit);
-		break;
-	}
+	data = BIT(bit + 16) | (speed << bit);
+	rmask = BIT(bit + 16) | BIT(bit);
 
 	return regmap_update_bits(regmap, reg, rmask, data);
 }
@@ -2702,9 +3513,9 @@ static int rockchip_pmx_set(struct pinctrl_dev *pctldev, unsigned selector,
 			break;
 	}
 
-	if (ret) {
+	if (ret && cnt) {
 		/* revert the already done pin settings */
-		for (cnt--; cnt >= 0; cnt--)
+		for (cnt--; cnt >= 0 && !data[cnt].func; cnt--)
 			rockchip_set_mux(bank, pins[cnt] - bank->pin_base, 0);
 
 		return ret;
@@ -2713,24 +3524,11 @@ static int rockchip_pmx_set(struct pinctrl_dev *pctldev, unsigned selector,
 	return 0;
 }
 
-static int rockchip_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,
-					   struct pinctrl_gpio_range *range,
-					   unsigned offset,
-					   bool input)
-{
-	struct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);
-	struct rockchip_pin_bank *bank;
-
-	bank = pin_to_bank(info, offset);
-	return rockchip_set_mux(bank, offset - bank->pin_base, RK_FUNC_GPIO);
-}
-
 static const struct pinmux_ops rockchip_pmx_ops = {
 	.get_functions_count	= rockchip_pmx_get_funcs_count,
 	.get_function_name	= rockchip_pmx_get_func_name,
 	.get_function_groups	= rockchip_pmx_get_groups,
 	.set_mux		= rockchip_pmx_set,
-	.gpio_set_direction	= rockchip_pmx_gpio_set_direction,
 };
 
 /*
@@ -2748,13 +3546,17 @@ static bool rockchip_pinconf_pull_valid(struct rockchip_pin_ctrl *ctrl,
 	case RK3066B:
 		return pull ? false : true;
 	case PX30:
+	case RV1106:
 	case RV1108:
 	case RV1126:
+	case RK1808:
 	case RK3188:
 	case RK3288:
 	case RK3308:
 	case RK3368:
 	case RK3399:
+	case RK3528:
+	case RK3562:
 	case RK3568:
 	case RK3588:
 		return (pull != PIN_CONFIG_BIAS_PULL_PIN_DEFAULT);
@@ -2878,9 +3680,17 @@ static int rockchip_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,
 			if (rc < 0)
 				return rc;
 			break;
+		case PIN_CONFIG_SLEW_RATE:
+			if (!info->ctrl->slew_rate_calc_reg)
+				return -ENOTSUPP;
+
+			rc = rockchip_set_slew_rate(bank,
+						    pin - bank->pin_base, arg);
+			if (rc < 0)
+				return rc;
+			break;
 		default:
 			return -ENOTSUPP;
-			break;
 		}
 	} /* for each config */
 
@@ -2952,11 +3762,20 @@ static int rockchip_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,
 		if (rc < 0)
 			return rc;
 
+		arg = rc;
+		break;
+	case PIN_CONFIG_SLEW_RATE:
+		if (!info->ctrl->slew_rate_calc_reg)
+			return -ENOTSUPP;
+
+		rc = rockchip_get_slew_rate(bank, pin - bank->pin_base);
+		if (rc < 0)
+			return rc;
+
 		arg = rc;
 		break;
 	default:
 		return -ENOTSUPP;
-		break;
 	}
 
 	*config = pinconf_to_config_packed(param, arg);
@@ -3044,7 +3863,6 @@ static int rockchip_pinctrl_parse_groups(struct device_node *np,
 		np_config = of_find_node_by_phandle(be32_to_cpup(phandle));
 		ret = pinconf_generic_parse_dt_config(np_config, NULL,
 				&grp->data[j].configs, &grp->data[j].nconfigs);
-		of_node_put(np_config);
 		if (ret)
 			return ret;
 	}
@@ -3137,7 +3955,6 @@ static int rockchip_pinctrl_register(struct platform_device *pdev,
 	struct pinctrl_pin_desc *pindesc, *pdesc;
 	struct rockchip_pin_bank *pin_bank;
 	struct device *dev = &pdev->dev;
-	char **pin_names;
 	int pin, bank, ret;
 	int k;
 
@@ -3157,14 +3974,10 @@ static int rockchip_pinctrl_register(struct platform_device *pdev,
 	pdesc = pindesc;
 	for (bank = 0, k = 0; bank < info->ctrl->nr_banks; bank++) {
 		pin_bank = &info->ctrl->pin_banks[bank];
-
-		pin_names = devm_kasprintf_strarray(dev, pin_bank->name, pin_bank->nr_pins);
-		if (IS_ERR(pin_names))
-			return PTR_ERR(pin_names);
-
 		for (pin = 0; pin < pin_bank->nr_pins; pin++, k++) {
 			pdesc->number = k;
-			pdesc->name = pin_names[pin];
+			pdesc->name = kasprintf(GFP_KERNEL, "%s-%d",
+						pin_bank->name, pin);
 			pdesc++;
 		}
 
@@ -3184,6 +3997,8 @@ static int rockchip_pinctrl_register(struct platform_device *pdev,
 }
 
 static const struct of_device_id rockchip_pinctrl_dt_match[];
+static struct rockchip_pin_bank rk3308bs_pin_banks[];
+static struct rockchip_pin_bank px30s_pin_banks[];
 
 /* retrieve the soc specific data */
 static struct rockchip_pin_ctrl *rockchip_pinctrl_get_soc_data(
@@ -3199,6 +4014,10 @@ static struct rockchip_pin_ctrl *rockchip_pinctrl_get_soc_data(
 
 	match = of_match_node(rockchip_pinctrl_dt_match, node);
 	ctrl = (struct rockchip_pin_ctrl *)match->data;
+	if (IS_ENABLED(CONFIG_CPU_RK3308) && soc_is_rk3308bs())
+		ctrl->pin_banks = rk3308bs_pin_banks;
+	if (IS_ENABLED(CONFIG_CPU_PX30) && soc_is_px30s())
+		ctrl->pin_banks = px30s_pin_banks;
 
 	grf_offs = ctrl->grf_mux_offset;
 	pmu_offs = ctrl->pmu_mux_offset;
@@ -3224,8 +4043,7 @@ static struct rockchip_pin_ctrl *rockchip_pinctrl_get_soc_data(
 
 			/* preset iomux offset value, set new start value */
 			if (iom->offset >= 0) {
-				if ((iom->type & IOMUX_SOURCE_PMU) ||
-				    (iom->type & IOMUX_L_SOURCE_PMU))
+				if ((iom->type & IOMUX_SOURCE_PMU) || (iom->type & IOMUX_L_SOURCE_PMU))
 					pmu_offs = iom->offset;
 				else
 					grf_offs = iom->offset;
@@ -3351,6 +4169,46 @@ static int __maybe_unused rockchip_pinctrl_resume(struct device *dev)
 static SIMPLE_DEV_PM_OPS(rockchip_pinctrl_dev_pm_ops, rockchip_pinctrl_suspend,
 			 rockchip_pinctrl_resume);
 
+/* SoC data specially handle */
+
+/* rk3308 SoC data initialize */
+#define RK3308_GRF_SOC_CON13			0x608
+#define RK3308_GRF_SOC_CON15			0x610
+
+/* RK3308_GRF_SOC_CON13 */
+#define RK3308_GRF_I2C3_IOFUNC_SRC_CTRL	(BIT(16 + 10) | BIT(10))
+#define RK3308_GRF_GPIO2A3_SEL_SRC_CTRL	(BIT(16 + 7)  | BIT(7))
+#define RK3308_GRF_GPIO2A2_SEL_SRC_CTRL	(BIT(16 + 3)  | BIT(3))
+
+/* RK3308_GRF_SOC_CON15 */
+#define RK3308_GRF_GPIO2C0_SEL_SRC_CTRL	(BIT(16 + 11) | BIT(11))
+#define RK3308_GRF_GPIO3B3_SEL_SRC_CTRL	(BIT(16 + 7)  | BIT(7))
+#define RK3308_GRF_GPIO3B2_SEL_SRC_CTRL	(BIT(16 + 3)  | BIT(3))
+
+static int rk3308_soc_data_init(struct rockchip_pinctrl *info)
+{
+	int ret;
+
+	/*
+	 * Enable the special ctrl of selected sources.
+	 */
+
+	ret = regmap_write(info->regmap_base, RK3308_GRF_SOC_CON13,
+			   RK3308_GRF_I2C3_IOFUNC_SRC_CTRL |
+			   RK3308_GRF_GPIO2A3_SEL_SRC_CTRL |
+			   RK3308_GRF_GPIO2A2_SEL_SRC_CTRL);
+	if (ret)
+		return ret;
+
+	ret = regmap_write(info->regmap_base, RK3308_GRF_SOC_CON15,
+			   RK3308_GRF_GPIO2C0_SEL_SRC_CTRL |
+			   RK3308_GRF_GPIO3B3_SEL_SRC_CTRL |
+			   RK3308_GRF_GPIO3B2_SEL_SRC_CTRL);
+
+	return ret;
+
+}
+
 static int rockchip_pinctrl_probe(struct platform_device *pdev)
 {
 	struct rockchip_pinctrl *info;
@@ -3416,16 +4274,25 @@ static int rockchip_pinctrl_probe(struct platform_device *pdev)
 			return PTR_ERR(info->regmap_pmu);
 	}
 
+	if (IS_ENABLED(CONFIG_CPU_RK3308) && ctrl->type == RK3308) {
+		ret = rk3308_soc_data_init(info);
+		if (ret)
+			return ret;
+	}
+
 	ret = rockchip_pinctrl_register(pdev, info);
 	if (ret)
 		return ret;
 
 	platform_set_drvdata(pdev, info);
+	g_pctldev = info->pctl_dev;
 
 	ret = of_platform_populate(np, NULL, NULL, &pdev->dev);
 	if (ret)
 		return dev_err_probe(dev, ret, "failed to register gpio device\n");
 
+	dev_info(dev, "probed %s\n", dev_name(dev));
+
 	return 0;
 }
 
@@ -3436,6 +4303,7 @@ static int rockchip_pinctrl_remove(struct platform_device *pdev)
 	struct rockchip_pin_deferred *cfg;
 	int i;
 
+	g_pctldev = NULL;
 	of_platform_depopulate(&pdev->dev);
 
 	for (i = 0; i < info->ctrl->nr_banks; i++) {
@@ -3454,6 +4322,13 @@ static int rockchip_pinctrl_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static struct rockchip_pin_bank px30s_pin_banks[] __maybe_unused = {
+	S_PIN_BANK_FLAGS(0, 32, "gpio0", IOMUX_SOURCE_PMU, DRV_TYPE_IO_SMIC),
+	S_PIN_BANK_FLAGS(1, 32, "gpio1", IOMUX_WIDTH_4BIT, DRV_TYPE_IO_SMIC),
+	S_PIN_BANK_FLAGS(2, 32, "gpio2", IOMUX_WIDTH_4BIT, DRV_TYPE_IO_SMIC),
+	S_PIN_BANK_FLAGS(3, 32, "gpio3", IOMUX_WIDTH_4BIT, DRV_TYPE_IO_SMIC),
+};
+
 static struct rockchip_pin_bank px30_pin_banks[] = {
 	PIN_BANK_IOMUX_FLAGS(0, 32, "gpio0", IOMUX_SOURCE_PMU,
 					     IOMUX_SOURCE_PMU,
@@ -3477,7 +4352,7 @@ static struct rockchip_pin_bank px30_pin_banks[] = {
 			    ),
 };
 
-static struct rockchip_pin_ctrl px30_pin_ctrl = {
+static struct rockchip_pin_ctrl px30_pin_ctrl __maybe_unused = {
 		.pin_banks		= px30_pin_banks,
 		.nr_banks		= ARRAY_SIZE(px30_pin_banks),
 		.label			= "PX30-GPIO",
@@ -3489,6 +4364,49 @@ static struct rockchip_pin_ctrl px30_pin_ctrl = {
 		.pull_calc_reg		= px30_calc_pull_reg_and_bit,
 		.drv_calc_reg		= px30_calc_drv_reg_and_bit,
 		.schmitt_calc_reg	= px30_calc_schmitt_reg_and_bit,
+		.slew_rate_calc_reg	= px30_calc_slew_rate_reg_and_bit,
+};
+
+static struct rockchip_pin_bank rv1106_pin_banks[] = {
+	PIN_BANK_IOMUX_FLAGS(0, 32, "gpio0",
+			     IOMUX_WIDTH_4BIT | IOMUX_SOURCE_PMU,
+			     IOMUX_WIDTH_4BIT | IOMUX_SOURCE_PMU,
+			     IOMUX_WIDTH_4BIT | IOMUX_SOURCE_PMU,
+			     IOMUX_WIDTH_4BIT | IOMUX_SOURCE_PMU),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(1, 32, "gpio1",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0, 0x08, 0x10, 0x18),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(2, 32, "gpio2",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x10020, 0x10028, 0, 0),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(3, 32, "gpio3",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x20040, 0x20048, 0x20050, 0x20058),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(4, 24, "gpio4",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0,
+				    0x30000, 0x30008, 0x30010, 0),
+};
+
+static struct rockchip_pin_ctrl rv1106_pin_ctrl __maybe_unused = {
+	.pin_banks		= rv1106_pin_banks,
+	.nr_banks		= ARRAY_SIZE(rv1106_pin_banks),
+	.label			= "RV1106-GPIO",
+	.type			= RV1106,
+	.pull_calc_reg		= rv1106_calc_pull_reg_and_bit,
+	.drv_calc_reg		= rv1106_calc_drv_reg_and_bit,
+	.schmitt_calc_reg	= rv1106_calc_schmitt_reg_and_bit,
 };
 
 static struct rockchip_pin_bank rv1108_pin_banks[] = {
@@ -3501,7 +4419,7 @@ static struct rockchip_pin_bank rv1108_pin_banks[] = {
 	PIN_BANK_IOMUX_FLAGS(3, 32, "gpio3", 0, 0, 0, 0),
 };
 
-static struct rockchip_pin_ctrl rv1108_pin_ctrl = {
+static struct rockchip_pin_ctrl rv1108_pin_ctrl __maybe_unused = {
 	.pin_banks		= rv1108_pin_banks,
 	.nr_banks		= ARRAY_SIZE(rv1108_pin_banks),
 	.label			= "RV1108-GPIO",
@@ -3522,11 +4440,11 @@ static struct rockchip_pin_bank rv1126_pin_banks[] = {
 			     IOMUX_WIDTH_4BIT | IOMUX_L_SOURCE_PMU,
 			     IOMUX_WIDTH_4BIT),
 	PIN_BANK_IOMUX_FLAGS_OFFSET(1, 32, "gpio1",
-				    IOMUX_WIDTH_4BIT,
-				    IOMUX_WIDTH_4BIT,
-				    IOMUX_WIDTH_4BIT,
-				    IOMUX_WIDTH_4BIT,
-				    0x10010, 0x10018, 0x10020, 0x10028),
+			     IOMUX_WIDTH_4BIT,
+			     IOMUX_WIDTH_4BIT,
+			     IOMUX_WIDTH_4BIT,
+			     IOMUX_WIDTH_4BIT,
+			     0x10010, 0x10018, 0x10020, 0x10028),
 	PIN_BANK_IOMUX_FLAGS(2, 32, "gpio2",
 			     IOMUX_WIDTH_4BIT,
 			     IOMUX_WIDTH_4BIT,
@@ -3541,7 +4459,7 @@ static struct rockchip_pin_bank rv1126_pin_banks[] = {
 			     IOMUX_WIDTH_4BIT, 0, 0, 0),
 };
 
-static struct rockchip_pin_ctrl rv1126_pin_ctrl = {
+static struct rockchip_pin_ctrl rv1126_pin_ctrl __maybe_unused = {
 	.pin_banks		= rv1126_pin_banks,
 	.nr_banks		= ARRAY_SIZE(rv1126_pin_banks),
 	.label			= "RV1126-GPIO",
@@ -3557,6 +4475,44 @@ static struct rockchip_pin_ctrl rv1126_pin_ctrl = {
 	.schmitt_calc_reg	= rv1126_calc_schmitt_reg_and_bit,
 };
 
+static struct rockchip_pin_bank rk1808_pin_banks[] = {
+	PIN_BANK_IOMUX_FLAGS(0, 32, "gpio0", IOMUX_SOURCE_PMU,
+					     IOMUX_SOURCE_PMU,
+					     IOMUX_SOURCE_PMU,
+					     IOMUX_SOURCE_PMU),
+	PIN_BANK_IOMUX_FLAGS(1, 32, "gpio1", IOMUX_WIDTH_4BIT,
+					     IOMUX_WIDTH_4BIT,
+					     IOMUX_WIDTH_4BIT,
+					     IOMUX_WIDTH_4BIT),
+	PIN_BANK_IOMUX_FLAGS(2, 32, "gpio2", IOMUX_WIDTH_4BIT,
+					     IOMUX_WIDTH_4BIT,
+					     IOMUX_WIDTH_4BIT,
+					     IOMUX_WIDTH_4BIT),
+	PIN_BANK_IOMUX_FLAGS(3, 32, "gpio3", IOMUX_WIDTH_4BIT,
+					     IOMUX_WIDTH_4BIT,
+					     IOMUX_WIDTH_4BIT,
+					     IOMUX_WIDTH_4BIT),
+	PIN_BANK_IOMUX_FLAGS(4, 32, "gpio4", IOMUX_WIDTH_4BIT,
+					     IOMUX_WIDTH_4BIT,
+					     IOMUX_WIDTH_4BIT,
+					     IOMUX_WIDTH_4BIT),
+};
+
+static struct rockchip_pin_ctrl rk1808_pin_ctrl __maybe_unused = {
+	.pin_banks		= rk1808_pin_banks,
+	.nr_banks		= ARRAY_SIZE(rk1808_pin_banks),
+	.label			= "RK1808-GPIO",
+	.type			= RK1808,
+	.iomux_routes		= rk1808_mux_route_data,
+	.niomux_routes		= ARRAY_SIZE(rk1808_mux_route_data),
+	.grf_mux_offset		= 0x0,
+	.pmu_mux_offset		= 0x0,
+	.pull_calc_reg		= rk1808_calc_pull_reg_and_bit,
+	.drv_calc_reg		= rk1808_calc_drv_reg_and_bit,
+	.schmitt_calc_reg	= rk1808_calc_schmitt_reg_and_bit,
+	.slew_rate_calc_reg	= rk1808_calc_slew_rate_reg_and_bit,
+};
+
 static struct rockchip_pin_bank rk2928_pin_banks[] = {
 	PIN_BANK(0, 32, "gpio0"),
 	PIN_BANK(1, 32, "gpio1"),
@@ -3564,7 +4520,7 @@ static struct rockchip_pin_bank rk2928_pin_banks[] = {
 	PIN_BANK(3, 32, "gpio3"),
 };
 
-static struct rockchip_pin_ctrl rk2928_pin_ctrl = {
+static struct rockchip_pin_ctrl rk2928_pin_ctrl __maybe_unused = {
 		.pin_banks		= rk2928_pin_banks,
 		.nr_banks		= ARRAY_SIZE(rk2928_pin_banks),
 		.label			= "RK2928-GPIO",
@@ -3579,7 +4535,7 @@ static struct rockchip_pin_bank rk3036_pin_banks[] = {
 	PIN_BANK(2, 32, "gpio2"),
 };
 
-static struct rockchip_pin_ctrl rk3036_pin_ctrl = {
+static struct rockchip_pin_ctrl rk3036_pin_ctrl __maybe_unused = {
 		.pin_banks		= rk3036_pin_banks,
 		.nr_banks		= ARRAY_SIZE(rk3036_pin_banks),
 		.label			= "RK3036-GPIO",
@@ -3597,7 +4553,7 @@ static struct rockchip_pin_bank rk3066a_pin_banks[] = {
 	PIN_BANK(6, 16, "gpio6"),
 };
 
-static struct rockchip_pin_ctrl rk3066a_pin_ctrl = {
+static struct rockchip_pin_ctrl rk3066a_pin_ctrl __maybe_unused = {
 		.pin_banks		= rk3066a_pin_banks,
 		.nr_banks		= ARRAY_SIZE(rk3066a_pin_banks),
 		.label			= "RK3066a-GPIO",
@@ -3613,7 +4569,7 @@ static struct rockchip_pin_bank rk3066b_pin_banks[] = {
 	PIN_BANK(3, 32, "gpio3"),
 };
 
-static struct rockchip_pin_ctrl rk3066b_pin_ctrl = {
+static struct rockchip_pin_ctrl rk3066b_pin_ctrl __maybe_unused = {
 		.pin_banks	= rk3066b_pin_banks,
 		.nr_banks	= ARRAY_SIZE(rk3066b_pin_banks),
 		.label		= "RK3066b-GPIO",
@@ -3628,7 +4584,7 @@ static struct rockchip_pin_bank rk3128_pin_banks[] = {
 	PIN_BANK(3, 32, "gpio3"),
 };
 
-static struct rockchip_pin_ctrl rk3128_pin_ctrl = {
+static struct rockchip_pin_ctrl rk3128_pin_ctrl __maybe_unused = {
 		.pin_banks		= rk3128_pin_banks,
 		.nr_banks		= ARRAY_SIZE(rk3128_pin_banks),
 		.label			= "RK3128-GPIO",
@@ -3648,7 +4604,7 @@ static struct rockchip_pin_bank rk3188_pin_banks[] = {
 	PIN_BANK(3, 32, "gpio3"),
 };
 
-static struct rockchip_pin_ctrl rk3188_pin_ctrl = {
+static struct rockchip_pin_ctrl rk3188_pin_ctrl __maybe_unused = {
 		.pin_banks		= rk3188_pin_banks,
 		.nr_banks		= ARRAY_SIZE(rk3188_pin_banks),
 		.label			= "RK3188-GPIO",
@@ -3666,7 +4622,7 @@ static struct rockchip_pin_bank rk3228_pin_banks[] = {
 	PIN_BANK(3, 32, "gpio3"),
 };
 
-static struct rockchip_pin_ctrl rk3228_pin_ctrl = {
+static struct rockchip_pin_ctrl rk3228_pin_ctrl __maybe_unused = {
 		.pin_banks		= rk3228_pin_banks,
 		.nr_banks		= ARRAY_SIZE(rk3228_pin_banks),
 		.label			= "RK3228-GPIO",
@@ -3679,9 +4635,9 @@ static struct rockchip_pin_ctrl rk3228_pin_ctrl = {
 };
 
 static struct rockchip_pin_bank rk3288_pin_banks[] = {
-	PIN_BANK_IOMUX_FLAGS(0, 24, "gpio0", IOMUX_SOURCE_PMU,
-					     IOMUX_SOURCE_PMU,
-					     IOMUX_SOURCE_PMU,
+	PIN_BANK_IOMUX_FLAGS(0, 24, "gpio0", IOMUX_SOURCE_PMU | IOMUX_WRITABLE_32BIT,
+					     IOMUX_SOURCE_PMU | IOMUX_WRITABLE_32BIT,
+					     IOMUX_SOURCE_PMU | IOMUX_WRITABLE_32BIT,
 					     IOMUX_UNROUTED
 			    ),
 	PIN_BANK_IOMUX_FLAGS(1, 32, "gpio1", IOMUX_UNROUTED,
@@ -3710,7 +4666,7 @@ static struct rockchip_pin_bank rk3288_pin_banks[] = {
 	PIN_BANK(8, 16, "gpio8"),
 };
 
-static struct rockchip_pin_ctrl rk3288_pin_ctrl = {
+static struct rockchip_pin_ctrl rk3288_pin_ctrl __maybe_unused = {
 		.pin_banks		= rk3288_pin_banks,
 		.nr_banks		= ARRAY_SIZE(rk3288_pin_banks),
 		.label			= "RK3288-GPIO",
@@ -3723,6 +4679,14 @@ static struct rockchip_pin_ctrl rk3288_pin_ctrl = {
 		.drv_calc_reg		= rk3288_calc_drv_reg_and_bit,
 };
 
+static struct rockchip_pin_bank rk3308bs_pin_banks[] __maybe_unused = {
+	S_PIN_BANK_FLAGS(0, 32, "gpio0", IOMUX_WIDTH_2BIT, DRV_TYPE_IO_SMIC),
+	S_PIN_BANK_FLAGS(1, 32, "gpio1", IOMUX_WIDTH_2BIT, DRV_TYPE_IO_SMIC),
+	S_PIN_BANK_FLAGS(2, 32, "gpio2", IOMUX_WIDTH_2BIT, DRV_TYPE_IO_SMIC),
+	S_PIN_BANK_FLAGS(3, 32, "gpio3", IOMUX_WIDTH_2BIT, DRV_TYPE_IO_SMIC),
+	S_PIN_BANK_FLAGS(4, 32, "gpio4", IOMUX_WIDTH_2BIT, DRV_TYPE_IO_SMIC),
+};
+
 static struct rockchip_pin_bank rk3308_pin_banks[] = {
 	PIN_BANK_IOMUX_FLAGS(0, 32, "gpio0", IOMUX_WIDTH_2BIT,
 					     IOMUX_WIDTH_2BIT,
@@ -3746,7 +4710,7 @@ static struct rockchip_pin_bank rk3308_pin_banks[] = {
 					     IOMUX_WIDTH_2BIT),
 };
 
-static struct rockchip_pin_ctrl rk3308_pin_ctrl = {
+static struct rockchip_pin_ctrl rk3308_pin_ctrl __maybe_unused = {
 		.pin_banks		= rk3308_pin_banks,
 		.nr_banks		= ARRAY_SIZE(rk3308_pin_banks),
 		.label			= "RK3308-GPIO",
@@ -3759,6 +4723,7 @@ static struct rockchip_pin_ctrl rk3308_pin_ctrl = {
 		.pull_calc_reg		= rk3308_calc_pull_reg_and_bit,
 		.drv_calc_reg		= rk3308_calc_drv_reg_and_bit,
 		.schmitt_calc_reg	= rk3308_calc_schmitt_reg_and_bit,
+		.slew_rate_calc_reg	= rk3308_calc_slew_rate_reg_and_bit,
 };
 
 static struct rockchip_pin_bank rk3328_pin_banks[] = {
@@ -3775,7 +4740,7 @@ static struct rockchip_pin_bank rk3328_pin_banks[] = {
 			     0),
 };
 
-static struct rockchip_pin_ctrl rk3328_pin_ctrl = {
+static struct rockchip_pin_ctrl rk3328_pin_ctrl __maybe_unused = {
 		.pin_banks		= rk3328_pin_banks,
 		.nr_banks		= ARRAY_SIZE(rk3328_pin_banks),
 		.label			= "RK3328-GPIO",
@@ -3801,7 +4766,7 @@ static struct rockchip_pin_bank rk3368_pin_banks[] = {
 	PIN_BANK(3, 32, "gpio3"),
 };
 
-static struct rockchip_pin_ctrl rk3368_pin_ctrl = {
+static struct rockchip_pin_ctrl rk3368_pin_ctrl __maybe_unused = {
 		.pin_banks		= rk3368_pin_banks,
 		.nr_banks		= ARRAY_SIZE(rk3368_pin_banks),
 		.label			= "RK3368-GPIO",
@@ -3865,7 +4830,7 @@ static struct rockchip_pin_bank rk3399_pin_banks[] = {
 			   ),
 };
 
-static struct rockchip_pin_ctrl rk3399_pin_ctrl = {
+static struct rockchip_pin_ctrl rk3399_pin_ctrl __maybe_unused = {
 		.pin_banks		= rk3399_pin_banks,
 		.nr_banks		= ARRAY_SIZE(rk3399_pin_banks),
 		.label			= "RK3399-GPIO",
@@ -3880,6 +4845,92 @@ static struct rockchip_pin_ctrl rk3399_pin_ctrl = {
 		.drv_calc_reg		= rk3399_calc_drv_reg_and_bit,
 };
 
+static struct rockchip_pin_bank rk3528_pin_banks[] = {
+	PIN_BANK_IOMUX_FLAGS_OFFSET(0, 32, "gpio0",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0, 0, 0, 0),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(1, 32, "gpio1",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x20020, 0x20028, 0x20030, 0x20038),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(2, 32, "gpio2",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x30040, 0, 0, 0),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(3, 32, "gpio3",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x20060, 0x20068, 0x20070, 0),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(4, 32, "gpio4",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x10080, 0x10088, 0x10090, 0x10098),
+};
+
+static struct rockchip_pin_ctrl rk3528_pin_ctrl __maybe_unused = {
+	.pin_banks		= rk3528_pin_banks,
+	.nr_banks		= ARRAY_SIZE(rk3528_pin_banks),
+	.label			= "RK3528-GPIO",
+	.type			= RK3528,
+	.pull_calc_reg		= rk3528_calc_pull_reg_and_bit,
+	.drv_calc_reg		= rk3528_calc_drv_reg_and_bit,
+	.schmitt_calc_reg	= rk3528_calc_schmitt_reg_and_bit,
+};
+
+static struct rockchip_pin_bank rk3562_pin_banks[] = {
+	PIN_BANK_IOMUX_FLAGS_OFFSET(0, 32, "gpio0",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x20000, 0x20008, 0x20010, 0x20018),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(1, 32, "gpio1",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0, 0x08, 0x10, 0x18),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(2, 32, "gpio2",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x20, 0, 0, 0),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(3, 32, "gpio3",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x10040, 0x10048, 0x10050, 0x10058),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(4, 16, "gpio4",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0,
+				    0,
+				    0x10060, 0x10068, 0, 0),
+};
+
+static struct rockchip_pin_ctrl rk3562_pin_ctrl __maybe_unused = {
+	.pin_banks		= rk3562_pin_banks,
+	.nr_banks		= ARRAY_SIZE(rk3562_pin_banks),
+	.label			= "RK3562-GPIO",
+	.type			= RK3562,
+	.pull_calc_reg		= rk3562_calc_pull_reg_and_bit,
+	.drv_calc_reg		= rk3562_calc_drv_reg_and_bit,
+	.schmitt_calc_reg	= rk3562_calc_schmitt_reg_and_bit,
+};
+
 static struct rockchip_pin_bank rk3568_pin_banks[] = {
 	PIN_BANK_IOMUX_FLAGS(0, 32, "gpio0", IOMUX_SOURCE_PMU | IOMUX_WIDTH_4BIT,
 					     IOMUX_SOURCE_PMU | IOMUX_WIDTH_4BIT,
@@ -3903,7 +4954,7 @@ static struct rockchip_pin_bank rk3568_pin_banks[] = {
 					     IOMUX_WIDTH_4BIT),
 };
 
-static struct rockchip_pin_ctrl rk3568_pin_ctrl = {
+static struct rockchip_pin_ctrl rk3568_pin_ctrl __maybe_unused = {
 	.pin_banks		= rk3568_pin_banks,
 	.nr_banks		= ARRAY_SIZE(rk3568_pin_banks),
 	.label			= "RK3568-GPIO",
@@ -3916,6 +4967,7 @@ static struct rockchip_pin_ctrl rk3568_pin_ctrl = {
 	.niomux_routes		= ARRAY_SIZE(rk3568_mux_route_data),
 	.pull_calc_reg		= rk3568_calc_pull_reg_and_bit,
 	.drv_calc_reg		= rk3568_calc_drv_reg_and_bit,
+	.slew_rate_calc_reg	= rk3568_calc_slew_rate_reg_and_bit,
 	.schmitt_calc_reg	= rk3568_calc_schmitt_reg_and_bit,
 };
 
@@ -3932,7 +4984,7 @@ static struct rockchip_pin_bank rk3588_pin_banks[] = {
 			      IOMUX_WIDTH_4BIT, PULL_TYPE_IO_1V8_ONLY),
 };
 
-static struct rockchip_pin_ctrl rk3588_pin_ctrl = {
+static struct rockchip_pin_ctrl rk3588_pin_ctrl __maybe_unused = {
 	.pin_banks		= rk3588_pin_banks,
 	.nr_banks		= ARRAY_SIZE(rk3588_pin_banks),
 	.label			= "RK3588-GPIO",
@@ -3943,40 +4995,88 @@ static struct rockchip_pin_ctrl rk3588_pin_ctrl = {
 };
 
 static const struct of_device_id rockchip_pinctrl_dt_match[] = {
+#ifdef CONFIG_CPU_PX30
 	{ .compatible = "rockchip,px30-pinctrl",
 		.data = &px30_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RV1106
+	{ .compatible = "rockchip,rv1106-pinctrl",
+		.data = &rv1106_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RV1108
 	{ .compatible = "rockchip,rv1108-pinctrl",
 		.data = &rv1108_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RV1126
 	{ .compatible = "rockchip,rv1126-pinctrl",
 		.data = &rv1126_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RK1808
+	{ .compatible = "rockchip,rk1808-pinctrl",
+		.data = &rk1808_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RK2928
 	{ .compatible = "rockchip,rk2928-pinctrl",
 		.data = &rk2928_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RK3036
 	{ .compatible = "rockchip,rk3036-pinctrl",
 		.data = &rk3036_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RK30XX
 	{ .compatible = "rockchip,rk3066a-pinctrl",
 		.data = &rk3066a_pin_ctrl },
 	{ .compatible = "rockchip,rk3066b-pinctrl",
 		.data = &rk3066b_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RK312X
 	{ .compatible = "rockchip,rk3128-pinctrl",
 		.data = (void *)&rk3128_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RK3188
 	{ .compatible = "rockchip,rk3188-pinctrl",
 		.data = &rk3188_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RK322X
 	{ .compatible = "rockchip,rk3228-pinctrl",
 		.data = &rk3228_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RK3288
 	{ .compatible = "rockchip,rk3288-pinctrl",
 		.data = &rk3288_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RK3308
 	{ .compatible = "rockchip,rk3308-pinctrl",
 		.data = &rk3308_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RK3328
 	{ .compatible = "rockchip,rk3328-pinctrl",
 		.data = &rk3328_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RK3368
 	{ .compatible = "rockchip,rk3368-pinctrl",
 		.data = &rk3368_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RK3399
 	{ .compatible = "rockchip,rk3399-pinctrl",
 		.data = &rk3399_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RK3528
+	{ .compatible = "rockchip,rk3528-pinctrl",
+		.data = &rk3528_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RK3562
+	{ .compatible = "rockchip,rk3562-pinctrl",
+		.data = &rk3562_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RK3568
 	{ .compatible = "rockchip,rk3568-pinctrl",
 		.data = &rk3568_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RK3588
 	{ .compatible = "rockchip,rk3588-pinctrl",
 		.data = &rk3588_pin_ctrl },
+#endif
 	{},
 };
 
@@ -4002,6 +5102,103 @@ static void __exit rockchip_pinctrl_drv_unregister(void)
 }
 module_exit(rockchip_pinctrl_drv_unregister);
 
+/**
+ * rk_iomux_set - set the rockchip iomux by pin number.
+ *
+ * @bank: the gpio bank index, from 0 to the max bank num.
+ * @pin: the gpio pin index, from 0 to 31.
+ * @mux: the pointer to store mux value.
+ *
+ * Return 0 if set success, else return error code.
+ */
+int rk_iomux_set(int bank, int pin, int mux)
+{
+	struct pinctrl_dev *pctldev = g_pctldev;
+	struct rockchip_pinctrl *info;
+	struct rockchip_pin_bank *gpio;
+	struct rockchip_pin_group *grp = NULL;
+	struct rockchip_pin_config *cfg = NULL;
+	int i, j, ret;
+
+	if (!g_pctldev)
+		return -ENODEV;
+
+	info = pinctrl_dev_get_drvdata(pctldev);
+	if (bank >= info->ctrl->nr_banks)
+		return -EINVAL;
+
+	if (pin > 31 || pin < 0)
+		return -EINVAL;
+
+	gpio = &info->ctrl->pin_banks[bank];
+
+	mutex_lock(&iomux_lock);
+	for (i = 0; i < info->ngroups; i++) {
+		grp = &info->groups[i];
+		for (j = 0; j < grp->npins; i++) {
+			if (grp->pins[i] == (gpio->pin_base + pin)) {
+				cfg = grp->data;
+				break;
+			}
+		}
+	}
+
+	ret = rockchip_set_mux(gpio, pin, mux);
+	if (ret) {
+		dev_err(info->dev, "mux GPIO%d-%d %d fail\n", bank, pin, mux);
+		goto out;
+	}
+
+	if (cfg && (cfg->func != mux))
+		cfg->func = mux;
+
+out:
+	mutex_unlock(&iomux_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(rk_iomux_set);
+
+/**
+ * rk_iomux_get - get the rockchip iomux by pin number.
+ *
+ * @bank: the gpio bank index, from 0 to the max bank num.
+ * @pin: the gpio pin index, from 0 to 31.
+ * @mux: the pointer to store mux value.
+ *
+ * Return 0 if get success, else return error code.
+ */
+int rk_iomux_get(int bank, int pin, int *mux)
+{
+	struct pinctrl_dev *pctldev = g_pctldev;
+	struct rockchip_pinctrl *info;
+	struct rockchip_pin_bank *gpio;
+	int ret;
+
+	if (!g_pctldev)
+		return -ENODEV;
+	if (!mux)
+		return -EINVAL;
+
+	info = pinctrl_dev_get_drvdata(pctldev);
+	if (bank >= info->ctrl->nr_banks)
+		return -EINVAL;
+
+	if (pin > 31 || pin < 0)
+		return -EINVAL;
+
+	gpio = &info->ctrl->pin_banks[bank];
+
+	mutex_lock(&iomux_lock);
+	ret = rockchip_get_mux(gpio, pin);
+	mutex_unlock(&iomux_lock);
+
+	*mux = ret;
+
+	return (ret >= 0) ? 0 : ret;
+}
+EXPORT_SYMBOL_GPL(rk_iomux_get);
+
 MODULE_DESCRIPTION("ROCKCHIP Pin Controller Driver");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:pinctrl-rockchip");
diff --git a/drivers/pinctrl/pinctrl-rockchip.h b/drivers/pinctrl/pinctrl-rockchip.h
index 4759f336941e..80b5552fd8d0 100644
--- a/drivers/pinctrl/pinctrl-rockchip.h
+++ b/drivers/pinctrl/pinctrl-rockchip.h
@@ -185,8 +185,10 @@
 
 enum rockchip_pinctrl_type {
 	PX30,
+	RV1106,
 	RV1108,
 	RV1126,
+	RK1808,
 	RK2928,
 	RK3066B,
 	RK3128,
@@ -195,6 +197,8 @@ enum rockchip_pinctrl_type {
 	RK3308,
 	RK3368,
 	RK3399,
+	RK3528,
+	RK3562,
 	RK3568,
 	RK3588,
 };
@@ -256,6 +260,7 @@ enum rockchip_pin_drv_type {
 	DRV_TYPE_IO_1V8_ONLY,
 	DRV_TYPE_IO_1V8_3V0_AUTO,
 	DRV_TYPE_IO_3V3_ONLY,
+	DRV_TYPE_IO_SMIC,
 	DRV_TYPE_MAX
 };
 
@@ -398,14 +403,17 @@ struct rockchip_pin_ctrl {
 	u32				niomux_routes;
 
 	int	(*pull_calc_reg)(struct rockchip_pin_bank *bank,
-				    int pin_num, struct regmap **regmap,
-				    int *reg, u8 *bit);
+				 int pin_num, struct regmap **regmap,
+				 int *reg, u8 *bit);
 	int	(*drv_calc_reg)(struct rockchip_pin_bank *bank,
-				    int pin_num, struct regmap **regmap,
-				    int *reg, u8 *bit);
+				int pin_num, struct regmap **regmap,
+				int *reg, u8 *bit);
 	int	(*schmitt_calc_reg)(struct rockchip_pin_bank *bank,
 				    int pin_num, struct regmap **regmap,
 				    int *reg, u8 *bit);
+	int	(*slew_rate_calc_reg)(struct rockchip_pin_bank *bank,
+				      int pin_num, struct regmap **regmap,
+				      int *reg, u8 *bit);
 };
 
 struct rockchip_pin_config {
@@ -464,4 +472,19 @@ struct rockchip_pinctrl {
 	unsigned int			nfunctions;
 };
 
+#if IS_ENABLED(CONFIG_PINCTRL_ROCKCHIP)
+int rk_iomux_set(int bank, int pin, int mux);
+int rk_iomux_get(int bank, int pin, int *mux);
+#else
+static inline int rk_iomux_set(int bank, int pin, int mux)
+{
+	return -EINVAL;
+}
+
+static inline int rk_iomux_get(int bank, int pin, int *mux)
+{
+	return -EINVAL;
+}
+#endif
+
 #endif
diff --git a/include/dt-bindings/clock/rk3568-cru.h b/include/dt-bindings/clock/rk3568-cru.h
index d29890865150..38c95aba0b5b 100644
--- a/include/dt-bindings/clock/rk3568-cru.h
+++ b/include/dt-bindings/clock/rk3568-cru.h
@@ -1,6 +1,6 @@
-/* SPDX-License-Identifier: GPL-2.0 */
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
 /*
- * Copyright (c) 2021 Rockchip Electronics Co. Ltd.
+ * Copyright (c) 2020 Rockchip Electronics Co. Ltd.
  * Author: Elaine Zhang <zhangqing@rock-chips.com>
  */
 
@@ -479,6 +479,12 @@
 #define CPLL_25M		416
 #define CPLL_100M		417
 #define SCLK_DDRCLK		418
+#define I2S1_MCLKOUT		419
+#define I2S3_MCLKOUT		420
+#define I2S1_MCLK_RX_IOE	421
+#define I2S1_MCLK_TX_IOE	422
+#define I2S2_MCLK_IOE		423
+#define I2S3_MCLK_IOE		424
 
 #define PCLK_CORE_PVTM		450
 
diff --git a/include/dt-bindings/clock/rockchip-ddr.h b/include/dt-bindings/clock/rockchip-ddr.h
new file mode 100644
index 000000000000..b065432e7793
--- /dev/null
+++ b/include/dt-bindings/clock/rockchip-ddr.h
@@ -0,0 +1,63 @@
+/*
+ *
+ * Copyright (C) 2017 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _DT_BINDINGS_CLOCK_ROCKCHIP_DDR_H
+#define _DT_BINDINGS_CLOCK_ROCKCHIP_DDR_H
+
+#define DDR2_DEFAULT	(0)
+
+#define DDR3_800D	(0)	/* 5-5-5 */
+#define DDR3_800E	(1)	/* 6-6-6 */
+#define DDR3_1066E	(2)	/* 6-6-6 */
+#define DDR3_1066F	(3)	/* 7-7-7 */
+#define DDR3_1066G	(4)	/* 8-8-8 */
+#define DDR3_1333F	(5)	/* 7-7-7 */
+#define DDR3_1333G	(6)	/* 8-8-8 */
+#define DDR3_1333H	(7)	/* 9-9-9 */
+#define DDR3_1333J	(8)	/* 10-10-10 */
+#define DDR3_1600G	(9)	/* 8-8-8 */
+#define DDR3_1600H	(10)	/* 9-9-9 */
+#define DDR3_1600J	(11)	/* 10-10-10 */
+#define DDR3_1600K	(12)	/* 11-11-11 */
+#define DDR3_1866J	(13)	/* 10-10-10 */
+#define DDR3_1866K	(14)	/* 11-11-11 */
+#define DDR3_1866L	(15)	/* 12-12-12 */
+#define DDR3_1866M	(16)	/* 13-13-13 */
+#define DDR3_2133K	(17)	/* 11-11-11 */
+#define DDR3_2133L	(18)	/* 12-12-12 */
+#define DDR3_2133M	(19)	/* 13-13-13 */
+#define DDR3_2133N	(20)	/* 14-14-14 */
+#define DDR3_DEFAULT	(21)
+#define DDR_DDR2	(22)
+#define DDR_LPDDR	(23)
+#define DDR_LPDDR2	(24)
+
+#define DDR4_1600J	(0)	/* 10-10-10 */
+#define DDR4_1600K	(1)	/* 11-11-11 */
+#define DDR4_1600L	(2)	/* 12-12-12 */
+#define DDR4_1866L	(3)	/* 12-12-12 */
+#define DDR4_1866M	(4)	/* 13-13-13 */
+#define DDR4_1866N	(5)	/* 14-14-14 */
+#define DDR4_2133N	(6)	/* 14-14-14 */
+#define DDR4_2133P	(7)	/* 15-15-15 */
+#define DDR4_2133R	(8)	/* 16-16-16 */
+#define DDR4_2400P	(9)	/* 15-15-15 */
+#define DDR4_2400R	(10)	/* 16-16-16 */
+#define DDR4_2400U	(11)	/* 18-18-18 */
+#define DDR4_DEFAULT	(12)
+
+#define PAUSE_CPU_STACK_SIZE	16
+
+#endif
diff --git a/include/dt-bindings/display/drm_mipi_dsi.h b/include/dt-bindings/display/drm_mipi_dsi.h
new file mode 100644
index 000000000000..bc24ce4ddd08
--- /dev/null
+++ b/include/dt-bindings/display/drm_mipi_dsi.h
@@ -0,0 +1,53 @@
+/*
+ * MIPI DSI Bus
+ *
+ * Copyright (c) Fuzhou Rockchip Electronics Co.Ltd
+ * Authors:
+ *       Mark Yao <yzq@rock-chips.com>
+ *
+ * based on include/drm/drm_mipi_dsi.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _DRM_MIPI_DSI_H__
+#define _DRM_MIPI_DSI_H__
+
+/* DSI mode flags */
+
+/* video mode */
+#define MIPI_DSI_MODE_VIDEO		(1 << 0)
+/* video burst mode */
+#define MIPI_DSI_MODE_VIDEO_BURST	(1 << 1)
+/* video pulse mode */
+#define MIPI_DSI_MODE_VIDEO_SYNC_PULSE	(1 << 2)
+/* enable auto vertical count mode */
+#define MIPI_DSI_MODE_VIDEO_AUTO_VERT	(1 << 3)
+/* enable hsync-end packets in vsync-pulse and v-porch area */
+#define MIPI_DSI_MODE_VIDEO_HSE		(1 << 4)
+/* disable hfront-porch area */
+#define MIPI_DSI_MODE_VIDEO_HFP		(1 << 5)
+/* disable hback-porch area */
+#define MIPI_DSI_MODE_VIDEO_HBP		(1 << 6)
+/* disable hsync-active area */
+#define MIPI_DSI_MODE_VIDEO_HSA		(1 << 7)
+/* flush display FIFO on vsync pulse */
+#define MIPI_DSI_MODE_VSYNC_FLUSH	(1 << 8)
+/* disable EoT packets in HS mode */
+#define MIPI_DSI_MODE_EOT_PACKET	(1 << 9)
+/* device supports non-continuous clock behavior (DSI spec 5.6.1) */
+#define MIPI_DSI_CLOCK_NON_CONTINUOUS	(1 << 10)
+/* transmit data in low power */
+#define MIPI_DSI_MODE_LPM		(1 << 11)
+
+#define MIPI_DSI_FMT_RGB888		0
+#define MIPI_DSI_FMT_RGB666		1
+#define MIPI_DSI_FMT_RGB666_PACKED	2
+#define MIPI_DSI_FMT_RGB565		3
+
+#define MIPI_CSI_FMT_RAW8		0x10
+#define MIPI_CSI_FMT_RAW10		0x11
+
+#endif /* __DRM_MIPI_DSI__ */
diff --git a/include/dt-bindings/display/rockchip-tve.h b/include/dt-bindings/display/rockchip-tve.h
new file mode 100644
index 000000000000..d72d69287bce
--- /dev/null
+++ b/include/dt-bindings/display/rockchip-tve.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
+ */
+
+
+#ifndef _DT_BINDINGS_ROCKCHIP_TVE_H
+#define _DT_BINDINGS_ROCKCHIP_TVE_H
+
+/* tve dclk upsample mode */
+#define	DCLK_UPSAMPLEx1		0
+#define	DCLK_UPSAMPLEx2		1
+#define	DCLK_UPSAMPLEx4		2
+
+#endif
diff --git a/include/dt-bindings/display/rockchip_vop.h b/include/dt-bindings/display/rockchip_vop.h
new file mode 100644
index 000000000000..3e14128e7ab1
--- /dev/null
+++ b/include/dt-bindings/display/rockchip_vop.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ */
+
+
+#ifndef _DT_BINDINGS_ROCKCHIP_VOP_H
+#define _DT_BINDINGS_ROCKCHIP_VOP_H
+
+#define	ROCKCHIP_VOP2_CLUSTER0	0
+#define	ROCKCHIP_VOP2_CLUSTER1	1
+#define	ROCKCHIP_VOP2_ESMART0	2
+#define	ROCKCHIP_VOP2_ESMART1	3
+#define	ROCKCHIP_VOP2_SMART0	4
+#define	ROCKCHIP_VOP2_SMART1	5
+#define	ROCKCHIP_VOP2_CLUSTER2	6
+#define	ROCKCHIP_VOP2_CLUSTER3	7
+#define	ROCKCHIP_VOP2_ESMART2	8
+#define	ROCKCHIP_VOP2_ESMART3	9
+
+#endif
diff --git a/include/dt-bindings/input/rk-input.h b/include/dt-bindings/input/rk-input.h
new file mode 100644
index 000000000000..00b412927890
--- /dev/null
+++ b/include/dt-bindings/input/rk-input.h
@@ -0,0 +1,814 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Device properties and quirks
+ */
+
+#define INPUT_PROP_POINTER		0x00	/* needs a pointer */
+#define INPUT_PROP_DIRECT		0x01	/* direct input devices */
+#define INPUT_PROP_BUTTONPAD		0x02	/* has button(s) under pad */
+#define INPUT_PROP_SEMI_MT		0x03	/* touch rectangle only */
+
+#define INPUT_PROP_MAX			0x1f
+#define INPUT_PROP_CNT			(INPUT_PROP_MAX + 1)
+
+/*
+ * Event types
+ */
+
+#define EV_SYN			0x00
+#define EV_KEY			0x01
+#define EV_REL			0x02
+#define EV_ABS			0x03
+#define EV_MSC			0x04
+#define EV_SW			0x05
+#define EV_LED			0x11
+#define EV_SND			0x12
+#define EV_REP			0x14
+#define EV_FF			0x15
+#define EV_PWR			0x16
+#define EV_FF_STATUS		0x17
+#define EV_MAX			0x1f
+#define EV_CNT			(EV_MAX+1)
+
+/*
+ * Synchronization events.
+ */
+
+#define SYN_REPORT		0
+#define SYN_CONFIG		1
+#define SYN_MT_REPORT		2
+#define SYN_DROPPED		3
+
+/*
+ * Keys and buttons
+ *
+ * Most of the keys/buttons are modeled after USB HUT 1.12
+ * (see http://www.usb.org/developers/hidpage).
+ * Abbreviations in the comments:
+ * AC - Application Control
+ * AL - Application Launch Button
+ * SC - System Control
+ */
+
+#define KEY_RESERVED		0
+#define KEY_ESC			1
+#define KEY_1			2
+#define KEY_2			3
+#define KEY_3			4
+#define KEY_4			5
+#define KEY_5			6
+#define KEY_6			7
+#define KEY_7			8
+#define KEY_8			9
+#define KEY_9			10
+#define KEY_0			11
+#define KEY_MINUS		12
+#define KEY_EQUAL		13
+#define KEY_BACKSPACE		14
+#define KEY_TAB			15
+#define KEY_Q			16
+#define KEY_W			17
+#define KEY_E			18
+#define KEY_R			19
+#define KEY_T			20
+#define KEY_Y			21
+#define KEY_U			22
+#define KEY_I			23
+#define KEY_O			24
+#define KEY_P			25
+#define KEY_LEFTBRACE		26
+#define KEY_RIGHTBRACE		27
+#define KEY_ENTER		28
+#define KEY_LEFTCTRL		29
+#define KEY_A			30
+#define KEY_S			31
+#define KEY_D			32
+#define KEY_F			33
+#define KEY_G			34
+#define KEY_H			35
+#define KEY_J			36
+#define KEY_K			37
+#define KEY_L			38
+#define KEY_SEMICOLON		39
+#define KEY_APOSTROPHE		40
+#define KEY_GRAVE		41
+#define KEY_LEFTSHIFT		42
+#define KEY_BACKSLASH		43
+#define KEY_Z			44
+#define KEY_X			45
+#define KEY_C			46
+#define KEY_V			47
+#define KEY_B			48
+#define KEY_N			49
+#define KEY_M			50
+#define KEY_COMMA		51
+#define KEY_DOT			52
+#define KEY_SLASH		53
+#define KEY_RIGHTSHIFT		54
+#define KEY_KPASTERISK		55
+#define KEY_LEFTALT		56
+#define KEY_SPACE		57
+#define KEY_CAPSLOCK		58
+#define KEY_F1			59
+#define KEY_F2			60
+#define KEY_F3			61
+#define KEY_F4			62
+#define KEY_F5			63
+#define KEY_F6			64
+#define KEY_F7			65
+#define KEY_F8			66
+#define KEY_F9			67
+#define KEY_F10			68
+#define KEY_NUMLOCK		69
+#define KEY_SCROLLLOCK		70
+#define KEY_KP7			71
+#define KEY_KP8			72
+#define KEY_KP9			73
+#define KEY_KPMINUS		74
+#define KEY_KP4			75
+#define KEY_KP5			76
+#define KEY_KP6			77
+#define KEY_KPPLUS		78
+#define KEY_KP1			79
+#define KEY_KP2			80
+#define KEY_KP3			81
+#define KEY_KP0			82
+#define KEY_KPDOT		83
+
+#define KEY_ZENKAKUHANKAKU	85
+#define KEY_102ND		86
+#define KEY_F11			87
+#define KEY_F12			88
+#define KEY_RO			89
+#define KEY_KATAKANA		90
+#define KEY_HIRAGANA		91
+#define KEY_HENKAN		92
+#define KEY_KATAKANAHIRAGANA	93
+#define KEY_MUHENKAN		94
+#define KEY_KPJPCOMMA		95
+#define KEY_KPENTER		96
+#define KEY_RIGHTCTRL		97
+#define KEY_KPSLASH		98
+#define KEY_SYSRQ		99
+#define KEY_RIGHTALT		100
+#define KEY_LINEFEED		101
+#define KEY_HOME		102
+#define KEY_UP			103
+#define KEY_PAGEUP		104
+#define KEY_LEFT		105
+#define KEY_RIGHT		106
+#define KEY_END			107
+#define KEY_DOWN		108
+#define KEY_PAGEDOWN		109
+#define KEY_INSERT		110
+#define KEY_DELETE		111
+#define KEY_MACRO		112
+#define KEY_MUTE		113
+#define KEY_VOLUMEDOWN		114
+#define KEY_VOLUMEUP		115
+#define KEY_POWER		116	/* SC System Power Down */
+#define KEY_KPEQUAL		117
+#define KEY_KPPLUSMINUS		118
+#define KEY_PAUSE		119
+#define KEY_SCALE		120	/* AL Compiz Scale (Expose) */
+
+#define KEY_KPCOMMA		121
+#define KEY_HANGEUL		122
+#define KEY_HANGUEL		KEY_HANGEUL
+#define KEY_HANJA		123
+#define KEY_YEN			124
+#define KEY_LEFTMETA		125
+#define KEY_RIGHTMETA		126
+#define KEY_COMPOSE		127
+
+#define KEY_STOP		128	/* AC Stop */
+#define KEY_AGAIN		129
+#define KEY_PROPS		130	/* AC Properties */
+#define KEY_UNDO		131	/* AC Undo */
+#define KEY_FRONT		132
+#define KEY_COPY		133	/* AC Copy */
+#define KEY_OPEN		134	/* AC Open */
+#define KEY_PASTE		135	/* AC Paste */
+#define KEY_FIND		136	/* AC Search */
+#define KEY_CUT			137	/* AC Cut */
+#define KEY_HELP		138	/* AL Integrated Help Center */
+#define KEY_MENU		139	/* Menu (show menu) */
+#define KEY_CALC		140	/* AL Calculator */
+#define KEY_SETUP		141
+#define KEY_SLEEP		142	/* SC System Sleep */
+#define KEY_WAKEUP		143	/* System Wake Up */
+#define KEY_FILE		144	/* AL Local Machine Browser */
+#define KEY_SENDFILE		145
+#define KEY_DELETEFILE		146
+#define KEY_XFER		147
+#define KEY_PROG1		148
+#define KEY_PROG2		149
+#define KEY_WWW			150	/* AL Internet Browser */
+#define KEY_MSDOS		151
+#define KEY_COFFEE		152	/* AL Terminal Lock/Screensaver */
+#define KEY_SCREENLOCK		KEY_COFFEE
+#define KEY_DIRECTION		153
+#define KEY_CYCLEWINDOWS	154
+#define KEY_MAIL		155
+#define KEY_BOOKMARKS		156	/* AC Bookmarks */
+#define KEY_COMPUTER		157
+#define KEY_BACK		158	/* AC Back */
+#define KEY_FORWARD		159	/* AC Forward */
+#define KEY_CLOSECD		160
+#define KEY_EJECTCD		161
+#define KEY_EJECTCLOSECD	162
+#define KEY_NEXTSONG		163
+#define KEY_PLAYPAUSE		164
+#define KEY_PREVIOUSSONG	165
+#define KEY_STOPCD		166
+#define KEY_RECORD		167
+#define KEY_REWIND		168
+#define KEY_PHONE		169	/* Media Select Telephone */
+#define KEY_ISO			170
+#define KEY_CONFIG		171	/* AL Consumer Control Configuration */
+#define KEY_HOMEPAGE		172	/* AC Home */
+#define KEY_REFRESH		173	/* AC Refresh */
+#define KEY_EXIT		174	/* AC Exit */
+#define KEY_MOVE		175
+#define KEY_EDIT		176
+#define KEY_SCROLLUP		177
+#define KEY_SCROLLDOWN		178
+#define KEY_KPLEFTPAREN		179
+#define KEY_KPRIGHTPAREN	180
+#define KEY_NEW			181	/* AC New */
+#define KEY_REDO		182	/* AC Redo/Repeat */
+
+#define KEY_F13			183
+#define KEY_F14			184
+#define KEY_F15			185
+#define KEY_F16			186
+#define KEY_F17			187
+#define KEY_F18			188
+#define KEY_F19			189
+#define KEY_F20			190
+#define KEY_F21			191
+#define KEY_F22			192
+#define KEY_F23			193
+#define KEY_F24			194
+
+#define KEY_PLAYCD		200
+#define KEY_PAUSECD		201
+#define KEY_PROG3		202
+#define KEY_PROG4		203
+#define KEY_DASHBOARD		204	/* AL Dashboard */
+#define KEY_SUSPEND		205
+#define KEY_CLOSE		206	/* AC Close */
+#define KEY_PLAY		207
+#define KEY_FASTFORWARD		208
+#define KEY_BASSBOOST		209
+#define KEY_PRINT		210	/* AC Print */
+#define KEY_HP			211
+#define KEY_CAMERA		212
+#define KEY_SOUND		213
+#define KEY_QUESTION		214
+#define KEY_EMAIL		215
+#define KEY_CHAT		216
+#define KEY_SEARCH		217
+#define KEY_CONNECT		218
+#define KEY_FINANCE		219	/* AL Checkbook/Finance */
+#define KEY_SPORT		220
+#define KEY_SHOP		221
+#define KEY_ALTERASE		222
+#define KEY_CANCEL		223	/* AC Cancel */
+#define KEY_BRIGHTNESSDOWN	224
+#define KEY_BRIGHTNESSUP	225
+#define KEY_MEDIA		226
+
+#define KEY_SWITCHVIDEOMODE	227	/* Cycle between available video
+					   outputs (Monitor/LCD/TV-out/etc) */
+#define KEY_KBDILLUMTOGGLE	228
+#define KEY_KBDILLUMDOWN	229
+#define KEY_KBDILLUMUP		230
+
+#define KEY_SEND		231	/* AC Send */
+#define KEY_REPLY		232	/* AC Reply */
+#define KEY_FORWARDMAIL		233	/* AC Forward Msg */
+#define KEY_SAVE		234	/* AC Save */
+#define KEY_DOCUMENTS		235
+
+#define KEY_BATTERY		236
+
+#define KEY_BLUETOOTH		237
+#define KEY_WLAN		238
+#define KEY_UWB			239
+
+#define KEY_UNKNOWN		240
+
+#define KEY_VIDEO_NEXT		241	/* drive next video source */
+#define KEY_VIDEO_PREV		242	/* drive previous video source */
+#define KEY_BRIGHTNESS_CYCLE	243	/* brightness up, after max is min */
+#define KEY_BRIGHTNESS_AUTO	244	/* Set Auto Brightness: manual
+					  brightness control is off,
+					  rely on ambient */
+#define KEY_BRIGHTNESS_ZERO	KEY_BRIGHTNESS_AUTO
+#define KEY_DISPLAY_OFF		245	/* display device to off state */
+
+#define KEY_WWAN		246	/* Wireless WAN (LTE, UMTS, GSM, etc.) */
+#define KEY_WIMAX		KEY_WWAN
+#define KEY_RFKILL		247	/* Key that controls all radios */
+
+#define KEY_MICMUTE		248	/* Mute / unmute the microphone */
+
+/* Code 255 is reserved for special needs of AT keyboard driver */
+
+#define BTN_MISC		0x100
+#define BTN_0			0x100
+#define BTN_1			0x101
+#define BTN_2			0x102
+#define BTN_3			0x103
+#define BTN_4			0x104
+#define BTN_5			0x105
+#define BTN_6			0x106
+#define BTN_7			0x107
+#define BTN_8			0x108
+#define BTN_9			0x109
+
+#define BTN_MOUSE		0x110
+#define BTN_LEFT		0x110
+#define BTN_RIGHT		0x111
+#define BTN_MIDDLE		0x112
+#define BTN_SIDE		0x113
+#define BTN_EXTRA		0x114
+#define BTN_FORWARD		0x115
+#define BTN_BACK		0x116
+#define BTN_TASK		0x117
+
+#define BTN_JOYSTICK		0x120
+#define BTN_TRIGGER		0x120
+#define BTN_THUMB		0x121
+#define BTN_THUMB2		0x122
+#define BTN_TOP			0x123
+#define BTN_TOP2		0x124
+#define BTN_PINKIE		0x125
+#define BTN_BASE		0x126
+#define BTN_BASE2		0x127
+#define BTN_BASE3		0x128
+#define BTN_BASE4		0x129
+#define BTN_BASE5		0x12a
+#define BTN_BASE6		0x12b
+#define BTN_DEAD		0x12f
+
+#define BTN_GAMEPAD		0x130
+#define BTN_SOUTH		0x130
+#define BTN_A			BTN_SOUTH
+#define BTN_EAST		0x131
+#define BTN_B			BTN_EAST
+#define BTN_C			0x132
+#define BTN_NORTH		0x133
+#define BTN_X			BTN_NORTH
+#define BTN_WEST		0x134
+#define BTN_Y			BTN_WEST
+#define BTN_Z			0x135
+#define BTN_TL			0x136
+#define BTN_TR			0x137
+#define BTN_TL2			0x138
+#define BTN_TR2			0x139
+#define BTN_SELECT		0x13a
+#define BTN_START		0x13b
+#define BTN_MODE		0x13c
+#define BTN_THUMBL		0x13d
+#define BTN_THUMBR		0x13e
+
+#define BTN_DIGI		0x140
+#define BTN_TOOL_PEN		0x140
+#define BTN_TOOL_RUBBER		0x141
+#define BTN_TOOL_BRUSH		0x142
+#define BTN_TOOL_PENCIL		0x143
+#define BTN_TOOL_AIRBRUSH	0x144
+#define BTN_TOOL_FINGER		0x145
+#define BTN_TOOL_MOUSE		0x146
+#define BTN_TOOL_LENS		0x147
+#define BTN_TOOL_QUINTTAP	0x148	/* Five fingers on trackpad */
+#define BTN_TOUCH		0x14a
+#define BTN_STYLUS		0x14b
+#define BTN_STYLUS2		0x14c
+#define BTN_TOOL_DOUBLETAP	0x14d
+#define BTN_TOOL_TRIPLETAP	0x14e
+#define BTN_TOOL_QUADTAP	0x14f	/* Four fingers on trackpad */
+
+#define BTN_WHEEL		0x150
+#define BTN_GEAR_DOWN		0x150
+#define BTN_GEAR_UP		0x151
+
+#define KEY_OK			0x160
+#define KEY_SELECT		0x161
+#define KEY_GOTO		0x162
+#define KEY_CLEAR		0x163
+#define KEY_POWER2		0x164
+#define KEY_OPTION		0x165
+#define KEY_INFO		0x166	/* AL OEM Features/Tips/Tutorial */
+#define KEY_TIME		0x167
+#define KEY_VENDOR		0x168
+#define KEY_ARCHIVE		0x169
+#define KEY_PROGRAM		0x16a	/* Media Select Program Guide */
+#define KEY_CHANNEL		0x16b
+#define KEY_FAVORITES		0x16c
+#define KEY_EPG			0x16d
+#define KEY_PVR			0x16e	/* Media Select Home */
+#define KEY_MHP			0x16f
+#define KEY_LANGUAGE		0x170
+#define KEY_TITLE		0x171
+#define KEY_SUBTITLE		0x172
+#define KEY_ANGLE		0x173
+#define KEY_ZOOM		0x174
+#define KEY_MODE		0x175
+#define KEY_KEYBOARD		0x176
+#define KEY_SCREEN		0x177
+#define KEY_PC			0x178	/* Media Select Computer */
+#define KEY_TV			0x179	/* Media Select TV */
+#define KEY_TV2			0x17a	/* Media Select Cable */
+#define KEY_VCR			0x17b	/* Media Select VCR */
+#define KEY_VCR2		0x17c	/* VCR Plus */
+#define KEY_SAT			0x17d	/* Media Select Satellite */
+#define KEY_SAT2		0x17e
+#define KEY_CD			0x17f	/* Media Select CD */
+#define KEY_TAPE		0x180	/* Media Select Tape */
+#define KEY_RADIO		0x181
+#define KEY_TUNER		0x182	/* Media Select Tuner */
+#define KEY_PLAYER		0x183
+#define KEY_TEXT		0x184
+#define KEY_DVD			0x185	/* Media Select DVD */
+#define KEY_AUX			0x186
+#define KEY_MP3			0x187
+#define KEY_AUDIO		0x188	/* AL Audio Browser */
+#define KEY_VIDEO		0x189	/* AL Movie Browser */
+#define KEY_DIRECTORY		0x18a
+#define KEY_LIST		0x18b
+#define KEY_MEMO		0x18c	/* Media Select Messages */
+#define KEY_CALENDAR		0x18d
+#define KEY_RED			0x18e
+#define KEY_GREEN		0x18f
+#define KEY_YELLOW		0x190
+#define KEY_BLUE		0x191
+#define KEY_CHANNELUP		0x192	/* Channel Increment */
+#define KEY_CHANNELDOWN		0x193	/* Channel Decrement */
+#define KEY_FIRST		0x194
+#define KEY_LAST		0x195	/* Recall Last */
+#define KEY_AB			0x196
+#define KEY_NEXT		0x197
+#define KEY_RESTART		0x198
+#define KEY_SLOW		0x199
+#define KEY_SHUFFLE		0x19a
+#define KEY_BREAK		0x19b
+#define KEY_PREVIOUS		0x19c
+#define KEY_DIGITS		0x19d
+#define KEY_TEEN		0x19e
+#define KEY_TWEN		0x19f
+#define KEY_VIDEOPHONE		0x1a0	/* Media Select Video Phone */
+#define KEY_GAMES		0x1a1	/* Media Select Games */
+#define KEY_ZOOMIN		0x1a2	/* AC Zoom In */
+#define KEY_ZOOMOUT		0x1a3	/* AC Zoom Out */
+#define KEY_ZOOMRESET		0x1a4	/* AC Zoom */
+#define KEY_WORDPROCESSOR	0x1a5	/* AL Word Processor */
+#define KEY_EDITOR		0x1a6	/* AL Text Editor */
+#define KEY_SPREADSHEET		0x1a7	/* AL Spreadsheet */
+#define KEY_GRAPHICSEDITOR	0x1a8	/* AL Graphics Editor */
+#define KEY_PRESENTATION	0x1a9	/* AL Presentation App */
+#define KEY_DATABASE		0x1aa	/* AL Database App */
+#define KEY_NEWS		0x1ab	/* AL Newsreader */
+#define KEY_VOICEMAIL		0x1ac	/* AL Voicemail */
+#define KEY_ADDRESSBOOK		0x1ad	/* AL Contacts/Address Book */
+#define KEY_MESSENGER		0x1ae	/* AL Instant Messaging */
+#define KEY_DISPLAYTOGGLE	0x1af	/* Turn display (LCD) on and off */
+#define KEY_BRIGHTNESS_TOGGLE	KEY_DISPLAYTOGGLE
+#define KEY_SPELLCHECK		0x1b0   /* AL Spell Check */
+#define KEY_LOGOFF		0x1b1   /* AL Logoff */
+
+#define KEY_DOLLAR		0x1b2
+#define KEY_EURO		0x1b3
+
+#define KEY_FRAMEBACK		0x1b4	/* Consumer - transport controls */
+#define KEY_FRAMEFORWARD	0x1b5
+#define KEY_CONTEXT_MENU	0x1b6	/* GenDesc - system context menu */
+#define KEY_MEDIA_REPEAT	0x1b7	/* Consumer - transport control */
+#define KEY_10CHANNELSUP	0x1b8	/* 10 channels up (10+) */
+#define KEY_10CHANNELSDOWN	0x1b9	/* 10 channels down (10-) */
+#define KEY_IMAGES		0x1ba	/* AL Image Browser */
+
+#define KEY_DEL_EOL		0x1c0
+#define KEY_DEL_EOS		0x1c1
+#define KEY_INS_LINE		0x1c2
+#define KEY_DEL_LINE		0x1c3
+
+#define KEY_FN			0x1d0
+#define KEY_FN_ESC		0x1d1
+#define KEY_FN_F1		0x1d2
+#define KEY_FN_F2		0x1d3
+#define KEY_FN_F3		0x1d4
+#define KEY_FN_F4		0x1d5
+#define KEY_FN_F5		0x1d6
+#define KEY_FN_F6		0x1d7
+#define KEY_FN_F7		0x1d8
+#define KEY_FN_F8		0x1d9
+#define KEY_FN_F9		0x1da
+#define KEY_FN_F10		0x1db
+#define KEY_FN_F11		0x1dc
+#define KEY_FN_F12		0x1dd
+#define KEY_FN_1		0x1de
+#define KEY_FN_2		0x1df
+#define KEY_FN_D		0x1e0
+#define KEY_FN_E		0x1e1
+#define KEY_FN_F		0x1e2
+#define KEY_FN_S		0x1e3
+#define KEY_FN_B		0x1e4
+
+#define KEY_BRL_DOT1		0x1f1
+#define KEY_BRL_DOT2		0x1f2
+#define KEY_BRL_DOT3		0x1f3
+#define KEY_BRL_DOT4		0x1f4
+#define KEY_BRL_DOT5		0x1f5
+#define KEY_BRL_DOT6		0x1f6
+#define KEY_BRL_DOT7		0x1f7
+#define KEY_BRL_DOT8		0x1f8
+#define KEY_BRL_DOT9		0x1f9
+#define KEY_BRL_DOT10		0x1fa
+
+#define KEY_NUMERIC_0		0x200	/* used by phones, remote controls, */
+#define KEY_NUMERIC_1		0x201	/* and other keypads */
+#define KEY_NUMERIC_2		0x202
+#define KEY_NUMERIC_3		0x203
+#define KEY_NUMERIC_4		0x204
+#define KEY_NUMERIC_5		0x205
+#define KEY_NUMERIC_6		0x206
+#define KEY_NUMERIC_7		0x207
+#define KEY_NUMERIC_8		0x208
+#define KEY_NUMERIC_9		0x209
+#define KEY_NUMERIC_STAR	0x20a
+#define KEY_NUMERIC_POUND	0x20b
+
+#define KEY_CAMERA_FOCUS	0x210
+#define KEY_WPS_BUTTON		0x211	/* WiFi Protected Setup key */
+
+#define KEY_TOUCHPAD_TOGGLE	0x212	/* Request switch touchpad on or off */
+#define KEY_TOUCHPAD_ON		0x213
+#define KEY_TOUCHPAD_OFF	0x214
+
+#define KEY_CAMERA_ZOOMIN	0x215
+#define KEY_CAMERA_ZOOMOUT	0x216
+#define KEY_CAMERA_UP		0x217
+#define KEY_CAMERA_DOWN		0x218
+#define KEY_CAMERA_LEFT		0x219
+#define KEY_CAMERA_RIGHT	0x21a
+
+#define KEY_ATTENDANT_ON	0x21b
+#define KEY_ATTENDANT_OFF	0x21c
+#define KEY_ATTENDANT_TOGGLE	0x21d	/* Attendant call on or off */
+#define KEY_LIGHTS_TOGGLE	0x21e	/* Reading light on or off */
+
+#define BTN_DPAD_UP		0x220
+#define BTN_DPAD_DOWN		0x221
+#define BTN_DPAD_LEFT		0x222
+#define BTN_DPAD_RIGHT		0x223
+
+#define KEY_ALS_TOGGLE		0x230	/* Ambient light sensor */
+
+#define KEY_BUTTONCONFIG		0x240	/* AL Button Configuration */
+#define KEY_TASKMANAGER		0x241	/* AL Task/Project Manager */
+#define KEY_JOURNAL		0x242	/* AL Log/Journal/Timecard */
+#define KEY_CONTROLPANEL		0x243	/* AL Control Panel */
+#define KEY_APPSELECT		0x244	/* AL Select Task/Application */
+#define KEY_SCREENSAVER		0x245	/* AL Screen Saver */
+#define KEY_VOICECOMMAND		0x246	/* Listening Voice Command */
+
+#define KEY_BRIGHTNESS_MIN		0x250	/* Set Brightness to Minimum */
+#define KEY_BRIGHTNESS_MAX		0x251	/* Set Brightness to Maximum */
+
+#define BTN_TRIGGER_HAPPY		0x2c0
+#define BTN_TRIGGER_HAPPY1		0x2c0
+#define BTN_TRIGGER_HAPPY2		0x2c1
+#define BTN_TRIGGER_HAPPY3		0x2c2
+#define BTN_TRIGGER_HAPPY4		0x2c3
+#define BTN_TRIGGER_HAPPY5		0x2c4
+#define BTN_TRIGGER_HAPPY6		0x2c5
+#define BTN_TRIGGER_HAPPY7		0x2c6
+#define BTN_TRIGGER_HAPPY8		0x2c7
+#define BTN_TRIGGER_HAPPY9		0x2c8
+#define BTN_TRIGGER_HAPPY10		0x2c9
+#define BTN_TRIGGER_HAPPY11		0x2ca
+#define BTN_TRIGGER_HAPPY12		0x2cb
+#define BTN_TRIGGER_HAPPY13		0x2cc
+#define BTN_TRIGGER_HAPPY14		0x2cd
+#define BTN_TRIGGER_HAPPY15		0x2ce
+#define BTN_TRIGGER_HAPPY16		0x2cf
+#define BTN_TRIGGER_HAPPY17		0x2d0
+#define BTN_TRIGGER_HAPPY18		0x2d1
+#define BTN_TRIGGER_HAPPY19		0x2d2
+#define BTN_TRIGGER_HAPPY20		0x2d3
+#define BTN_TRIGGER_HAPPY21		0x2d4
+#define BTN_TRIGGER_HAPPY22		0x2d5
+#define BTN_TRIGGER_HAPPY23		0x2d6
+#define BTN_TRIGGER_HAPPY24		0x2d7
+#define BTN_TRIGGER_HAPPY25		0x2d8
+#define BTN_TRIGGER_HAPPY26		0x2d9
+#define BTN_TRIGGER_HAPPY27		0x2da
+#define BTN_TRIGGER_HAPPY28		0x2db
+#define BTN_TRIGGER_HAPPY29		0x2dc
+#define BTN_TRIGGER_HAPPY30		0x2dd
+#define BTN_TRIGGER_HAPPY31		0x2de
+#define BTN_TRIGGER_HAPPY32		0x2df
+#define BTN_TRIGGER_HAPPY33		0x2e0
+#define BTN_TRIGGER_HAPPY34		0x2e1
+#define BTN_TRIGGER_HAPPY35		0x2e2
+#define BTN_TRIGGER_HAPPY36		0x2e3
+#define BTN_TRIGGER_HAPPY37		0x2e4
+#define BTN_TRIGGER_HAPPY38		0x2e5
+#define BTN_TRIGGER_HAPPY39		0x2e6
+#define BTN_TRIGGER_HAPPY40		0x2e7
+
+/* We avoid low common keys in module aliases so they don't get huge. */
+#define KEY_MIN_INTERESTING	KEY_MUTE
+#define KEY_MAX			0x2ff
+#define KEY_CNT			(KEY_MAX+1)
+
+/*
+ * Relative axes
+ */
+
+#define REL_X			0x00
+#define REL_Y			0x01
+#define REL_Z			0x02
+#define REL_RX			0x03
+#define REL_RY			0x04
+#define REL_RZ			0x05
+#define REL_HWHEEL		0x06
+#define REL_DIAL		0x07
+#define REL_WHEEL		0x08
+#define REL_MISC		0x09
+#define REL_MAX			0x0f
+#define REL_CNT			(REL_MAX+1)
+
+/*
+ * Absolute axes
+ */
+
+#define ABS_X			0x00
+#define ABS_Y			0x01
+#define ABS_Z			0x02
+#define ABS_RX			0x03
+#define ABS_RY			0x04
+#define ABS_RZ			0x05
+#define ABS_THROTTLE		0x06
+#define ABS_RUDDER		0x07
+#define ABS_WHEEL		0x08
+#define ABS_GAS			0x09
+#define ABS_BRAKE		0x0a
+#define ABS_HAT0X		0x10
+#define ABS_HAT0Y		0x11
+#define ABS_HAT1X		0x12
+#define ABS_HAT1Y		0x13
+#define ABS_HAT2X		0x14
+#define ABS_HAT2Y		0x15
+#define ABS_HAT3X		0x16
+#define ABS_HAT3Y		0x17
+#define ABS_PRESSURE		0x18
+#define ABS_DISTANCE		0x19
+#define ABS_TILT_X		0x1a
+#define ABS_TILT_Y		0x1b
+#define ABS_TOOL_WIDTH		0x1c
+
+#define ABS_VOLUME		0x20
+
+#define ABS_MISC		0x28
+
+#define ABS_MT_SLOT		0x2f	/* MT slot being modified */
+#define ABS_MT_TOUCH_MAJOR	0x30	/* Major axis of touching ellipse */
+#define ABS_MT_TOUCH_MINOR	0x31	/* Minor axis (omit if circular) */
+#define ABS_MT_WIDTH_MAJOR	0x32	/* Major axis of approaching ellipse */
+#define ABS_MT_WIDTH_MINOR	0x33	/* Minor axis (omit if circular) */
+#define ABS_MT_ORIENTATION	0x34	/* Ellipse orientation */
+#define ABS_MT_POSITION_X	0x35	/* Center X touch position */
+#define ABS_MT_POSITION_Y	0x36	/* Center Y touch position */
+#define ABS_MT_TOOL_TYPE	0x37	/* Type of touching device */
+#define ABS_MT_BLOB_ID		0x38	/* Group a set of packets as a blob */
+#define ABS_MT_TRACKING_ID	0x39	/* Unique ID of initiated contact */
+#define ABS_MT_PRESSURE		0x3a	/* Pressure on contact area */
+#define ABS_MT_DISTANCE		0x3b	/* Contact hover distance */
+#define ABS_MT_TOOL_X		0x3c	/* Center X tool position */
+#define ABS_MT_TOOL_Y		0x3d	/* Center Y tool position */
+
+
+#define ABS_MAX			0x3f
+#define ABS_CNT			(ABS_MAX+1)
+
+/*
+ * Switch events
+ */
+
+#define SW_LID			0x00  /* set = lid shut */
+#define SW_TABLET_MODE		0x01  /* set = tablet mode */
+#define SW_HEADPHONE_INSERT	0x02  /* set = inserted */
+#define SW_RFKILL_ALL		0x03  /* rfkill master switch, type "any"
+					 set = radio enabled */
+#define SW_RADIO		SW_RFKILL_ALL	/* deprecated */
+#define SW_MICROPHONE_INSERT	0x04  /* set = inserted */
+#define SW_DOCK			0x05  /* set = plugged into dock */
+#define SW_LINEOUT_INSERT	0x06  /* set = inserted */
+#define SW_JACK_PHYSICAL_INSERT 0x07  /* set = mechanical switch set */
+#define SW_VIDEOOUT_INSERT	0x08  /* set = inserted */
+#define SW_CAMERA_LENS_COVER	0x09  /* set = lens covered */
+#define SW_KEYPAD_SLIDE		0x0a  /* set = keypad slide out */
+#define SW_FRONT_PROXIMITY	0x0b  /* set = front proximity sensor active */
+#define SW_ROTATE_LOCK		0x0c  /* set = rotate locked/disabled */
+#define SW_LINEIN_INSERT	0x0d  /* set = inserted */
+#define SW_MUTE_DEVICE		0x0e  /* set = device disabled */
+#define SW_MAX			0x0f
+#define SW_CNT			(SW_MAX+1)
+
+/*
+ * Misc events
+ */
+
+#define MSC_SERIAL		0x00
+#define MSC_PULSELED		0x01
+#define MSC_GESTURE		0x02
+#define MSC_RAW			0x03
+#define MSC_SCAN		0x04
+#define MSC_TIMESTAMP		0x05
+#define MSC_MAX			0x07
+#define MSC_CNT			(MSC_MAX+1)
+
+/*
+ * LEDs
+ */
+
+#define LED_NUML		0x00
+#define LED_CAPSL		0x01
+#define LED_SCROLLL		0x02
+#define LED_COMPOSE		0x03
+#define LED_KANA		0x04
+#define LED_SLEEP		0x05
+#define LED_SUSPEND		0x06
+#define LED_MUTE		0x07
+#define LED_MISC		0x08
+#define LED_MAIL		0x09
+#define LED_CHARGING		0x0a
+#define LED_MAX			0x0f
+#define LED_CNT			(LED_MAX+1)
+
+/*
+ * Autorepeat values
+ */
+
+#define REP_DELAY		0x00
+#define REP_PERIOD		0x01
+#define REP_MAX			0x01
+#define REP_CNT			(REP_MAX+1)
+
+/*
+ * Sounds
+ */
+
+#define SND_CLICK		0x00
+#define SND_BELL		0x01
+#define SND_TONE		0x02
+#define SND_MAX			0x07
+#define SND_CNT			(SND_MAX+1)
+
+/*
+ * IDs.
+ */
+
+#define ID_BUS			0
+#define ID_VENDOR		1
+#define ID_PRODUCT		2
+#define ID_VERSION		3
+
+#define BUS_PCI			0x01
+#define BUS_ISAPNP		0x02
+#define BUS_USB			0x03
+#define BUS_HIL			0x04
+#define BUS_BLUETOOTH		0x05
+#define BUS_VIRTUAL		0x06
+
+#define BUS_ISA			0x10
+#define BUS_I8042		0x11
+#define BUS_XTKBD		0x12
+#define BUS_RS232		0x13
+#define BUS_GAMEPORT		0x14
+#define BUS_PARPORT		0x15
+#define BUS_AMIGA		0x16
+#define BUS_ADB			0x17
+#define BUS_I2C			0x18
+#define BUS_HOST		0x19
+#define BUS_GSC			0x1A
+#define BUS_ATARI		0x1B
+#define BUS_SPI			0x1C
+
+/*
+ * MT_TOOL types
+ */
+#define MT_TOOL_FINGER		0
+#define MT_TOOL_PEN		1
+#define MT_TOOL_MAX		1
+
+/*
+ * Values describing the status of a force-feedback effect
+ */
+#define FF_STATUS_STOPPED	0x00
+#define FF_STATUS_PLAYING	0x01
+#define FF_STATUS_MAX		0x01
diff --git a/include/dt-bindings/input/rk-ir.h b/include/dt-bindings/input/rk-ir.h
new file mode 100644
index 000000000000..139fe04c068e
--- /dev/null
+++ b/include/dt-bindings/input/rk-ir.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
+ */
+#ifndef _DT_BINDINGS_RK_IR_H
+#define _DT_BINDINGS_RK_IR_H
+
+/* STB KEYS */
+#define KEY_CHANNEL_UP          249
+#define KEY_CHANNEL_DN          250
+#define KEY_HOME_PAGE           251
+#define KEY_CH_CUT_BACK         252
+#define KEY_DIRECT_SEEDING      253
+#define KEY_REVIEW              254
+#define KEY_ON_DEMAND           255
+#define KEY_INFO1               256
+#define KEY_SOUND1              257
+#define KEY_X1                  258
+#define KEY_X2                  259
+#define KEY_LOCAL               260
+#define KEY_APPLICATION         261
+#define KEY_POS                 262
+#define KEY_GO_BEGINNING        263
+#define KEY_INTERX              264
+#define KEY_FAVORITE            265
+#define KEY_CHANNEL_POS         266
+#define KEY_EVENT               267
+#define KEY_COMM                268
+#define KEY_LAUNCH              269
+#define KEY_TRACK               270
+#define KEY_PORTAL              271
+
+#endif
diff --git a/include/dt-bindings/memory/rk3568-dram.h b/include/dt-bindings/memory/rk3568-dram.h
new file mode 100644
index 000000000000..c05eae7fe32e
--- /dev/null
+++ b/include/dt-bindings/memory/rk3568-dram.h
@@ -0,0 +1,111 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2020 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef _DT_BINDINGS_DRAM_ROCKCHIP_RK3568_H
+#define _DT_BINDINGS_DRAM_ROCKCHIP_RK3568_H
+
+#include <dt-bindings/memory/rockchip-dram.h>
+
+#define PHY_DDR4_DS_ODT_DISABLE		(0x0)
+#define PHY_DDR4_DS_ODT_556ohm		(0x1)
+#define PHY_DDR4_DS_ODT_279ohm		(0x2)
+#define PHY_DDR4_DS_ODT_185ohm		(0x3)
+#define PHY_DDR4_DS_ODT_139ohm		(0x4)
+#define PHY_DDR4_DS_ODT_111ohm		(0x5)
+#define PHY_DDR4_DS_ODT_93ohm		(0x6)
+#define PHY_DDR4_DS_ODT_79ohm		(0x7)
+#define PHY_DDR4_DS_ODT_69ohm		(0x8)
+#define PHY_DDR4_DS_ODT_62ohm		(0x9)
+#define PHY_DDR4_DS_ODT_55ohm		(0xa)
+#define PHY_DDR4_DS_ODT_50ohm		(0xb)
+#define PHY_DDR4_DS_ODT_46ohm		(0xc)
+#define PHY_DDR4_DS_ODT_42ohm		(0xd)
+#define PHY_DDR4_DS_ODT_39ohm		(0xe)
+#define PHY_DDR4_DS_ODT_37ohm		(0xf)
+#define PHY_DDR4_DS_ODT_34ohm		(0x18)
+#define PHY_DDR4_DS_ODT_32ohm		(0x19)
+#define PHY_DDR4_DS_ODT_31ohm		(0x1a)
+#define PHY_DDR4_DS_ODT_29ohm		(0x1b)
+#define PHY_DDR4_DS_ODT_27ohm		(0x1c)
+#define PHY_DDR4_DS_ODT_26ohm		(0x1d)
+#define PHY_DDR4_DS_ODT_25ohm		(0x1e)
+#define PHY_DDR4_DS_ODT_24ohm		(0x1f)
+
+#define PHY_LPDDR4_DS_ODT_DISABLE	(0x0)
+#define PHY_LPDDR4_DS_ODT_576ohm	(0x1)
+#define PHY_LPDDR4_DS_ODT_289ohm	(0x2)
+#define PHY_LPDDR4_DS_ODT_192ohm	(0x3)
+#define PHY_LPDDR4_DS_ODT_144ohm	(0x4)
+#define PHY_LPDDR4_DS_ODT_115ohm	(0x5)
+#define PHY_LPDDR4_DS_ODT_96ohm		(0x6)
+#define PHY_LPDDR4_DS_ODT_82ohm		(0x7)
+#define PHY_LPDDR4_DS_ODT_72ohm		(0x8)
+#define PHY_LPDDR4_DS_ODT_64ohm		(0x9)
+#define PHY_LPDDR4_DS_ODT_57ohm		(0xa)
+#define PHY_LPDDR4_DS_ODT_52ohm		(0xb)
+#define PHY_LPDDR4_DS_ODT_48ohm		(0xc)
+#define PHY_LPDDR4_DS_ODT_44ohm		(0xd)
+#define PHY_LPDDR4_DS_ODT_41ohm		(0xe)
+#define PHY_LPDDR4_DS_ODT_38ohm		(0xf)
+#define PHY_LPDDR4_DS_ODT_36ohm		(0x18)
+#define PHY_LPDDR4_DS_ODT_34ohm		(0x19)
+#define PHY_LPDDR4_DS_ODT_32ohm		(0x1a)
+#define PHY_LPDDR4_DS_ODT_30ohm		(0x1b)
+#define PHY_LPDDR4_DS_ODT_28ohm		(0x1c)
+#define PHY_LPDDR4_DS_ODT_27ohm		(0x1d)
+#define PHY_LPDDR4_DS_ODT_26ohm		(0x1e)
+#define PHY_LPDDR4_DS_ODT_25ohm		(0x1f)
+
+#define PHY_LPDDR4X_DS_ODT_UP_DISABLE	(0x0)
+#define PHY_LPDDR4X_DS_ODT_UP_646ohm	(0x1)
+#define PHY_LPDDR4X_DS_ODT_UP_323ohm	(0x2)
+#define PHY_LPDDR4X_DS_ODT_UP_215ohm	(0x3)
+#define PHY_LPDDR4X_DS_ODT_UP_162ohm	(0x4)
+#define PHY_LPDDR4X_DS_ODT_UP_129ohm	(0x5)
+#define PHY_LPDDR4X_DS_ODT_UP_108ohm	(0x6)
+#define PHY_LPDDR4X_DS_ODT_UP_92ohm	(0x7)
+#define PHY_LPDDR4X_DS_ODT_UP_81ohm	(0x8)
+#define PHY_LPDDR4X_DS_ODT_UP_72ohm	(0x9)
+#define PHY_LPDDR4X_DS_ODT_UP_65ohm	(0xa)
+#define PHY_LPDDR4X_DS_ODT_UP_59ohm	(0xb)
+#define PHY_LPDDR4X_DS_ODT_UP_54ohm	(0xc)
+#define PHY_LPDDR4X_DS_ODT_UP_50ohm	(0xd)
+#define PHY_LPDDR4X_DS_ODT_UP_46ohm	(0xe)
+#define PHY_LPDDR4X_DS_ODT_UP_43ohm	(0xf)
+#define PHY_LPDDR4X_DS_ODT_UP_40ohm	(0x18)
+#define PHY_LPDDR4X_DS_ODT_UP_38ohm	(0x19)
+#define PHY_LPDDR4X_DS_ODT_UP_36ohm	(0x1a)
+#define PHY_LPDDR4X_DS_ODT_UP_34ohm	(0x1b)
+#define PHY_LPDDR4X_DS_ODT_UP_32ohm	(0x1c)
+#define PHY_LPDDR4X_DS_ODT_UP_31ohm	(0x1d)
+#define PHY_LPDDR4X_DS_ODT_UP_29ohm	(0x1e)
+#define PHY_LPDDR4X_DS_ODT_UP_28ohm	(0x1f)
+
+#define PHY_LPDDR4X_DS_ODT_DOWN_DISABLE	(0x0)
+#define PHY_LPDDR4X_DS_ODT_DOWN_513ohm	(0x1)
+#define PHY_LPDDR4X_DS_ODT_DOWN_259ohm	(0x2)
+#define PHY_LPDDR4X_DS_ODT_DOWN_172ohm	(0x3)
+#define PHY_LPDDR4X_DS_ODT_DOWN_130ohm	(0x4)
+#define PHY_LPDDR4X_DS_ODT_DOWN_104hm	(0x5)
+#define PHY_LPDDR4X_DS_ODT_DOWN_86hm	(0x6)
+#define PHY_LPDDR4X_DS_ODT_DOWN_74ohm	(0x7)
+#define PHY_LPDDR4X_DS_ODT_DOWN_65ohm	(0x8)
+#define PHY_LPDDR4X_DS_ODT_DOWN_58ohm	(0x9)
+#define PHY_LPDDR4X_DS_ODT_DOWN_52ohm	(0xa)
+#define PHY_LPDDR4X_DS_ODT_DOWN_47ohm	(0xb)
+#define PHY_LPDDR4X_DS_ODT_DOWN_43ohm	(0xc)
+#define PHY_LPDDR4X_DS_ODT_DOWN_40ohm	(0xd)
+#define PHY_LPDDR4X_DS_ODT_DOWN_37ohm	(0xe)
+#define PHY_LPDDR4X_DS_ODT_DOWN_35ohm	(0xf)
+#define PHY_LPDDR4X_DS_ODT_DOWN_32ohm	(0x18)
+#define PHY_LPDDR4X_DS_ODT_DOWN_30ohm	(0x19)
+#define PHY_LPDDR4X_DS_ODT_DOWN_29ohm	(0x1a)
+#define PHY_LPDDR4X_DS_ODT_DOWN_27ohm	(0x1b)
+#define PHY_LPDDR4X_DS_ODT_DOWN_26ohm	(0x1c)
+#define PHY_LPDDR4X_DS_ODT_DOWN_25ohm	(0x1d)
+#define PHY_LPDDR4X_DS_ODT_DOWN_24ohm	(0x1e)
+#define PHY_LPDDR4X_DS_ODT_DOWN_23ohm	(0x1f)
+
+#endif /* _DT_BINDINGS_DRAM_ROCKCHIP_RK3568_H */
diff --git a/include/dt-bindings/memory/rockchip-dram.h b/include/dt-bindings/memory/rockchip-dram.h
new file mode 100644
index 000000000000..21ed3975211f
--- /dev/null
+++ b/include/dt-bindings/memory/rockchip-dram.h
@@ -0,0 +1,102 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2020 Fuzhou Rockchip Electronics Co., Ltd
+ */
+
+#ifndef _DT_BINDINGS_DRAM_ROCKCHIP_H
+#define _DT_BINDINGS_DRAM_ROCKCHIP_H
+
+#define DDR2_DS_FULL			(0x0)
+#define DDR2_DS_REDUCE			(0x1 << 1)
+#define DDR2_DS_MASK			(0x1 << 1)
+
+#define DDR2_ODT_DIS			(0x0)
+#define DDR2_ODT_75ohm			(0x1 << 2)
+#define DDR2_ODT_150ohm			(0x1 << 6)
+#define DDR2_ODT_50ohm			((0x1 << 6) | (0x1 << 2)) /* optional */
+#define DDR2_ODT_MASK			((0x1 << 2) | (0x1 << 6))
+
+#define DDR3_DS_40ohm			(0x0)
+#define DDR3_DS_34ohm			(0x1 << 1)
+#define DDR3_DS_MASK			((1 << 1) | (1 << 5))
+
+#define DDR3_ODT_DIS			(0x0)
+#define DDR3_ODT_60ohm			(0x1 << 2)
+#define DDR3_ODT_120ohm			(0x1 << 6)
+#define DDR3_ODT_40ohm			((0x1 << 6) | (0x1 << 2))
+#define DDR3_ODT_MASK			((0x1 << 2) | (0x1 << 6) | (0x1 << 9))
+
+#define DDR4_DS_34ohm			(0x0)
+#define DDR4_DS_48ohm			(0x1 << 1)
+#define DDR4_DS_MASK			(0x3 << 1)
+
+#define DDR4_ODT_DIS			(0x0)
+#define DDR4_ODT_60ohm			(0x1 << 8)
+#define DDR4_ODT_120ohm			(0x2 << 8)
+#define DDR4_ODT_40ohm			(0x3 << 8)
+#define DDR4_ODT_240ohm			(0x4 << 8)
+#define DDR4_ODT_48ohm			(0x5 << 8)
+#define DDR4_ODT_80ohm			(0x6 << 8)
+#define DDR4_ODT_34ohm			(0x7 << 8)
+#define DDR4_ODT_MASK			(0x7 << 8)
+
+#define LP2_DS_34ohm			(0x1)
+#define LP2_DS_40ohm			(0x2)
+#define LP2_DS_48ohm			(0x3)
+#define LP2_DS_60ohm			(0x4)
+#define LP2_DS_68_6ohm			(0x5)	/* optional */
+#define LP2_DS_80ohm			(0x6)
+#define LP2_DS_120ohm			(0x7)	/* optional */
+#define LP2_DS_MASK			(0xf)
+
+#define LP3_DS_34ohm			(0x1)
+#define LP3_DS_40ohm			(0x2)
+#define LP3_DS_48ohm			(0x3)
+#define LP3_DS_60ohm			(0x4)
+#define LP3_DS_80ohm			(0x6)
+#define LP3_DS_34D_40U			(0x9)
+#define LP3_DS_40D_48U			(0xa)
+#define LP3_DS_34D_48U			(0xb)
+#define LP3_DS_MASK			(0xf)
+
+#define LP3_ODT_DIS			(0)
+#define LP3_ODT_60ohm			(0x1)
+#define LP3_ODT_120ohm			(0x2)
+#define LP3_ODT_240ohm			(0x3)
+#define LP3_ODT_MASK			(0x3)
+
+#define LP4_PDDS_240ohm			(0x1 << 3)
+#define LP4_PDDS_120ohm			(0x2 << 3)
+#define LP4_PDDS_80ohm			(0x3 << 3)
+#define LP4_PDDS_60ohm			(0x4 << 3)
+#define LP4_PDDS_48ohm			(0x5 << 3)
+#define LP4_PDDS_40ohm			(0x6 << 3)
+#define LP4_PDDS_MASK			(0x7 << 3)
+
+#define LP4_DQ_ODT_DIS			(0x0)
+#define LP4_DQ_ODT_240ohm		(0x1)
+#define LP4_DQ_ODT_120ohm		(0x2)
+#define LP4_DQ_ODT_80ohm		(0x3)
+#define LP4_DQ_ODT_60ohm		(0x4)
+#define LP4_DQ_ODT_48ohm		(0x5)
+#define LP4_DQ_ODT_40ohm		(0x6)
+#define LP4_DQ_ODT_MASK			(0x7)
+
+#define LP4_CA_ODT_DIS			(0x0)
+#define LP4_CA_ODT_240ohm		(0x1 << 4)
+#define LP4_CA_ODT_120ohm		(0x2 << 4)
+#define LP4_CA_ODT_80ohm		(0x3 << 4)
+#define LP4_CA_ODT_60ohm		(0x4 << 4)
+#define LP4_CA_ODT_48ohm		(0x5 << 4)
+#define LP4_CA_ODT_40ohm		(0x6 << 4)
+#define LP4_CA_ODT_MASK			(0x7 << 4)
+
+#define LP4_VDDQ_2_5			(0)
+#define LP4_VDDQ_3			(1)
+
+#define LP4X_VDDQ_0_6			(0)
+#define LP4X_VDDQ_0_5			(1)
+
+#define IGNORE_THIS			(0)
+
+#endif /* _DT_BINDINGS_DRAM_ROCKCHIP_H */
diff --git a/include/dt-bindings/sensor-dev.h b/include/dt-bindings/sensor-dev.h
new file mode 100644
index 000000000000..e03f0027d325
--- /dev/null
+++ b/include/dt-bindings/sensor-dev.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __DT_BINDINGS_ROCKCHIP_SENSORDEV_H__
+#define __DT_BINDINGS_ROCKCHIP_SENSORDEV_H__
+
+#define	SENSOR_TYPE_NULL  0	
+#define	SENSOR_TYPE_ANGLE 1
+#define	SENSOR_TYPE_ACCEL 2
+#define	SENSOR_TYPE_COMPASS 3	
+#define	SENSOR_TYPE_GYROSCOPE 4	
+#define	SENSOR_TYPE_LIGHT 5	
+#define	SENSOR_TYPE_PROXIMITY 6
+#define	SENSOR_TYPE_TEMPERATURE 7	
+#define	SENSOR_TYPE_PRESSURE 8
+#define	SENSOR_TYPE_HALL 9
+#define	SENSOR_NUM_TYPES 10
+
+#endif
diff --git a/include/dt-bindings/soc/rockchip,boot-mode.h b/include/dt-bindings/soc/rockchip,boot-mode.h
index 4b0914c0989d..ec4e5dd83cc1 100644
--- a/include/dt-bindings/soc/rockchip,boot-mode.h
+++ b/include/dt-bindings/soc/rockchip,boot-mode.h
@@ -10,7 +10,17 @@
 #define BOOT_BL_DOWNLOAD	(REBOOT_FLAG + 1)
 /* enter recovery */
 #define BOOT_RECOVERY		(REBOOT_FLAG + 3)
- /* enter fastboot mode */
+/* reboot by panic */
+#define BOOT_PANIC		(REBOOT_FLAG + 7)
+/* reboot by watchdog */
+#define BOOT_WATCHDOG		(REBOOT_FLAG + 8)
+/* enter fastboot mode */
 #define BOOT_FASTBOOT		(REBOOT_FLAG + 9)
+/* enter charging mode */
+#define BOOT_CHARGING		(REBOOT_FLAG + 11)
+/* enter usb mass storage mode */
+#define BOOT_UMS		(REBOOT_FLAG + 12)
+/* reboot system quiescent */
+#define BOOT_QUIESCENT		(REBOOT_FLAG + 14)
 
 #endif
diff --git a/include/dt-bindings/soc/rockchip-system-status.h b/include/dt-bindings/soc/rockchip-system-status.h
new file mode 100644
index 000000000000..51364815dcf8
--- /dev/null
+++ b/include/dt-bindings/soc/rockchip-system-status.h
@@ -0,0 +1,58 @@
+/*
+ *
+ * Copyright (C) 2017 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _DT_BINDINGS_SOC_ROCKCHIP_SYSTEM_STATUS_H
+#define _DT_BINDINGS_SOC_ROCKCHIP_SYSTEM_STATUS_H
+
+#define SYS_STATUS_NORMAL	(1 << 0)
+#define SYS_STATUS_SUSPEND	(1 << 1)
+#define SYS_STATUS_IDLE		(1 << 2)
+#define SYS_STATUS_REBOOT	(1 << 3)
+#define SYS_STATUS_VIDEO_4K	(1 << 4)
+#define SYS_STATUS_VIDEO_1080P	(1 << 5)
+#define SYS_STATUS_GPU		(1 << 6)
+#define SYS_STATUS_RGA		(1 << 7)
+#define SYS_STATUS_CIF0		(1 << 8)
+#define SYS_STATUS_CIF1		(1 << 9)
+#define SYS_STATUS_LCDC0	(1 << 10)
+#define SYS_STATUS_LCDC1	(1 << 11)
+#define SYS_STATUS_BOOST	(1 << 12)
+#define SYS_STATUS_PERFORMANCE	(1 << 13)
+#define SYS_STATUS_ISP		(1 << 14)
+#define SYS_STATUS_HDMI		(1 << 15)
+#define SYS_STATUS_VIDEO_4K_10B	(1 << 16)
+#define SYS_STATUS_LOW_POWER	(1 << 17)
+#define SYS_STATUS_HDMIRX	(1 << 18)
+#define SYS_STATUS_VIDEO_SVEP	(1 << 19)
+#define SYS_STATUS_VIDEO_4K_60P	(1 << 20)
+
+#define SYS_STATUS_VIDEO	(SYS_STATUS_VIDEO_4K | \
+				 SYS_STATUS_VIDEO_1080P | \
+				 SYS_STATUS_VIDEO_4K_10B | \
+				 SYS_STATUS_VIDEO_4K_60P)
+#define SYS_STATUS_DUALVIEW	(SYS_STATUS_LCDC0 | SYS_STATUS_LCDC1)
+
+#define DMC_FREQ_LEVEL_LOW	(0x1 << 0)
+#define DMC_FREQ_LEVEL_MID_LOW	(0x1 << 1)
+#define DMC_FREQ_LEVEL_MID_HIGH	(0x1 << 2)
+#define DMC_FREQ_LEVEL_HIGH	(0x1 << 3)
+
+#define DMC_WAIT_MODE_NORMAL	(0x1 << 0)
+#define DMC_WAIT_MODE_VOP_VBANK	(0x1 << 1)
+#define DMC_WAIT_MODE_VOP_LINE	(0x1 << 2)
+#define DMC_WAIT_MODE_VOP_AUTO	(0x1 << 3)
+#define DMC_WAIT_MODE_ISP_VBANK	(0x1 << 4)
+
+#endif
diff --git a/include/dt-bindings/suspend/rockchip-rk3568.h b/include/dt-bindings/suspend/rockchip-rk3568.h
new file mode 100644
index 000000000000..91e89f64a067
--- /dev/null
+++ b/include/dt-bindings/suspend/rockchip-rk3568.h
@@ -0,0 +1,57 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Header providing constants for Rockchip suspend bindings.
+ *
+ * Copyright (C) 2021, Rockchip Electronics Co., Ltd.
+ * Author: XiaoDong.Huang
+ */
+
+#ifndef __DT_BINDINGS_SUSPEND_ROCKCHIP_RK3568_H__
+#define __DT_BINDINGS_SUSPEND_ROCKCHIP_RK3568_H__
+/******************************bits ops************************************/
+
+#ifndef BIT
+#define BIT(nr)				(1 << (nr))
+#endif
+
+#define RKPM_SLP_WFI			BIT(0)
+#define RKPM_SLP_ARMOFF			BIT(1)
+#define RKPM_SLP_CENTER_OFF		BIT(2)
+#define RKPM_SLP_ARMOFF_LOGOFF		BIT(3)
+#define RKPM_SLP_FROM_UBOOT		BIT(4)
+#define RKPM_SLP_PMIC_LP		BIT(5)
+#define RKPM_SLP_HW_PLLS_OFF		BIT(6)
+#define RKPM_SLP_PMUALIVE_32K		BIT(7)
+#define RKPM_SLP_OSC_DIS		BIT(8)
+#define RKPM_SLP_32K_EXT		BIT(9)
+#define RKPM_SLP_32K_PVTM		BIT(10)
+/* the wake up source */
+#define RKPM_CPU0_WKUP_EN		BIT(0)
+#define RKPM_CPU1_WKUP_EN		BIT(1)
+#define RKPM_CPU2_WKUP_EN		BIT(2)
+#define RKPM_CPU3_WKUP_EN		BIT(3)
+#define RKPM_GPIO_WKUP_EN		BIT(4)
+#define RKPM_UART0_WKUP_EN		BIT(5)
+#define RKPM_SDMMC0_WKUP_EN		BIT(6)
+#define RKPM_SDMMC1_WKUP_EN		BIT(7)
+#define RKPM_SDMMC2_WKUP_EN		BIT(8)
+#define RKPM_USB_WKUP_EN		BIT(9)
+#define RKPM_PCIE_WKUP_EN		BIT(10)
+#define RKPM_VAD_WKUP_EN		BIT(11)
+#define RKPM_TIMER_WKUP_EN		BIT(12)
+#define RKPM_PWM0_WKUP_EN		BIT(13)
+#define RKPM_TIMEOUT_WKUP_EN		BIT(14)
+#define RKPM_SFT_WKUP_EN		BIT(15)
+#define RKPM_USB_LINESTATE_WKUP_EN	BIT(16)
+
+#define RKPM_SLP_LDO1_ON		BIT(0)
+#define RKPM_SLP_LDO2_ON		BIT(1)
+#define RKPM_SLP_LDO3_ON		BIT(2)
+#define RKPM_SLP_LDO4_ON		BIT(3)
+#define RKPM_SLP_LDO5_ON		BIT(4)
+#define RKPM_SLP_LDO6_ON		BIT(5)
+#define RKPM_SLP_LDO7_ON		BIT(6)
+#define RKPM_SLP_LDO8_ON		BIT(7)
+#define RKPM_SLP_LDO9_ON		BIT(8)
+
+#endif
diff --git a/include/linux/rockchip/cpu.h b/include/linux/rockchip/cpu.h
new file mode 100644
index 000000000000..dc3b9381e1ad
--- /dev/null
+++ b/include/linux/rockchip/cpu.h
@@ -0,0 +1,261 @@
+/*
+ * Copyright (C) 2017 Rockchip Electronics Co. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __LINUX_ROCKCHIP_CPU_H
+#define __LINUX_ROCKCHIP_CPU_H
+
+#include <linux/of.h>
+
+#define ROCKCHIP_CPU_MASK		0xffff0000
+#define ROCKCHIP_CPU_SHIFT		16
+#define ROCKCHIP_CPU_PX30		0x33260000
+#define ROCKCHIP_CPU_RV1103		0x11030000
+#define ROCKCHIP_CPU_RV1106		0x11060000
+#define ROCKCHIP_CPU_RV1109		0x11090000
+#define ROCKCHIP_CPU_RV1126		0x11260000
+#define ROCKCHIP_CPU_RK312X		0x31260000
+#define ROCKCHIP_CPU_RK3288		0x32880000
+#define ROCKCHIP_CPU_RK3308		0x33080000
+#define ROCKCHIP_CPU_RK3528		0x35280000
+#define ROCKCHIP_CPU_RK3566		0x35660000
+#define ROCKCHIP_CPU_RK3568		0x35680000
+
+#if IS_REACHABLE(CONFIG_ROCKCHIP_CPUINFO)
+
+extern unsigned long rockchip_soc_id;
+
+#define ROCKCHIP_CPU_VERION_MASK	0x0000f000
+#define ROCKCHIP_CPU_VERION_SHIFT	12
+
+static inline unsigned long rockchip_get_cpu_version(void)
+{
+	return (rockchip_soc_id & ROCKCHIP_CPU_VERION_MASK)
+		>> ROCKCHIP_CPU_VERION_SHIFT;
+}
+
+static inline void rockchip_set_cpu_version(unsigned long ver)
+{
+	rockchip_soc_id &= ~ROCKCHIP_CPU_VERION_MASK;
+	rockchip_soc_id |=
+		(ver << ROCKCHIP_CPU_VERION_SHIFT) & ROCKCHIP_CPU_VERION_MASK;
+}
+
+static inline void rockchip_set_cpu(unsigned long code)
+{
+	if (!code)
+		return;
+
+	rockchip_soc_id &= ~ROCKCHIP_CPU_MASK;
+	rockchip_soc_id |= (code << ROCKCHIP_CPU_SHIFT) & ROCKCHIP_CPU_MASK;
+}
+
+int rockchip_soc_id_init(void);
+
+#else
+
+#define rockchip_soc_id 0
+
+static inline unsigned long rockchip_get_cpu_version(void)
+{
+	return 0;
+}
+
+static inline void rockchip_set_cpu_version(unsigned long ver)
+{
+}
+
+static inline void rockchip_set_cpu(unsigned long code)
+{
+}
+
+static inline int rockchip_soc_id_init(void)
+{
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_CPU_PX30
+static inline bool cpu_is_px30(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_PX30;
+	return of_machine_is_compatible("rockchip,px30") ||
+	       of_machine_is_compatible("rockchip,px30s") ||
+	       of_machine_is_compatible("rockchip,rk3326") ||
+	       of_machine_is_compatible("rockchip,rk3326s");
+}
+#else
+static inline bool cpu_is_px30(void) { return false; }
+#endif
+
+#if defined(CONFIG_CPU_RV1106)
+static inline bool cpu_is_rv1103(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RV1103;
+	return of_machine_is_compatible("rockchip,rv1103");
+}
+
+static inline bool cpu_is_rv1106(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RV1106;
+	return of_machine_is_compatible("rockchip,rv1106");
+}
+#else
+static inline bool cpu_is_rv1103(void) { return false; }
+static inline bool cpu_is_rv1106(void) { return false; }
+#endif
+
+#if defined(CONFIG_CPU_RV1126) || defined(CONFIG_CPU_RV1109)
+static inline bool cpu_is_rv1109(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RV1109;
+	return of_machine_is_compatible("rockchip,rv1109");
+}
+
+static inline bool cpu_is_rv1126(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RV1126;
+	return of_machine_is_compatible("rockchip,rv1126");
+}
+#else
+static inline bool cpu_is_rv1109(void) { return false; }
+static inline bool cpu_is_rv1126(void) { return false; }
+#endif
+
+#ifdef CONFIG_CPU_RK312X
+static inline bool cpu_is_rk312x(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK312X;
+	return of_machine_is_compatible("rockchip,rk3126") ||
+	       of_machine_is_compatible("rockchip,rk3126b") ||
+	       of_machine_is_compatible("rockchip,rk3126c") ||
+	       of_machine_is_compatible("rockchip,rk3128");
+}
+#else
+static inline bool cpu_is_rk312x(void) { return false; }
+#endif
+
+#ifdef CONFIG_CPU_RK3288
+static inline bool cpu_is_rk3288(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK3288;
+	return of_machine_is_compatible("rockchip,rk3288") ||
+	       of_machine_is_compatible("rockchip,rk3288w");
+}
+#else
+static inline bool cpu_is_rk3288(void) { return false; }
+#endif
+
+#ifdef CONFIG_CPU_RK3308
+static inline bool cpu_is_rk3308(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK3308;
+
+	return of_machine_is_compatible("rockchip,rk3308") ||
+	       of_machine_is_compatible("rockchip,rk3308bs");
+}
+#else
+static inline bool cpu_is_rk3308(void) { return false; }
+#endif
+
+#if defined(CONFIG_CPU_RK3528)
+static inline bool cpu_is_rk3528(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK3528;
+	return of_machine_is_compatible("rockchip,rk3528") ||
+	       of_machine_is_compatible("rockchip,rk3528a");
+}
+#else
+static inline bool cpu_is_rk3528(void) { return false; }
+#endif
+
+#if defined(CONFIG_CPU_RK3568)
+static inline bool cpu_is_rk3566(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK3566;
+	return of_machine_is_compatible("rockchip,rk3566");
+}
+
+static inline bool cpu_is_rk3568(void)
+{
+	if (rockchip_soc_id)
+		return (rockchip_soc_id & ROCKCHIP_CPU_MASK) == ROCKCHIP_CPU_RK3568;
+	return of_machine_is_compatible("rockchip,rk3568");
+}
+#else
+static inline bool cpu_is_rk3566(void) { return false; }
+static inline bool cpu_is_rk3568(void) { return false; }
+#endif
+
+#define ROCKCHIP_SOC_MASK	(ROCKCHIP_CPU_MASK | 0xff)
+#define ROCKCHIP_SOC_PX30	(ROCKCHIP_CPU_PX30 | 0x00)
+#define ROCKCHIP_SOC_PX30S	(ROCKCHIP_CPU_PX30 | 0x01)
+#define ROCKCHIP_SOC_RV1103     (ROCKCHIP_CPU_RV1103 | 0x00)
+#define ROCKCHIP_SOC_RV1106     (ROCKCHIP_CPU_RV1106 | 0x00)
+#define ROCKCHIP_SOC_RV1109     (ROCKCHIP_CPU_RV1109 | 0x00)
+#define ROCKCHIP_SOC_RV1126     (ROCKCHIP_CPU_RV1126 | 0x00)
+#define ROCKCHIP_SOC_RK3126     (ROCKCHIP_CPU_RK312X | 0x00)
+#define ROCKCHIP_SOC_RK3126B    (ROCKCHIP_CPU_RK312X | 0x10)
+#define ROCKCHIP_SOC_RK3126C    (ROCKCHIP_CPU_RK312X | 0x20)
+#define ROCKCHIP_SOC_RK3128     (ROCKCHIP_CPU_RK312X | 0x01)
+#define ROCKCHIP_SOC_RK3288     (ROCKCHIP_CPU_RK3288 | 0x00)
+#define ROCKCHIP_SOC_RK3288W    (ROCKCHIP_CPU_RK3288 | 0x01)
+#define ROCKCHIP_SOC_RK3308	(ROCKCHIP_CPU_RK3308 | 0x00)
+#define ROCKCHIP_SOC_RK3308B	(ROCKCHIP_CPU_RK3308 | 0x01)
+#define ROCKCHIP_SOC_RK3308BS	(ROCKCHIP_CPU_RK3308 | 0x02)
+#define ROCKCHIP_SOC_RK3528	(ROCKCHIP_CPU_RK3528 | 0x00)
+#define ROCKCHIP_SOC_RK3528A	(ROCKCHIP_CPU_RK3528 | 0x01)
+#define ROCKCHIP_SOC_RK3566	(ROCKCHIP_CPU_RK3566 | 0x00)
+#define ROCKCHIP_SOC_RK3568	(ROCKCHIP_CPU_RK3568 | 0x00)
+
+#define ROCKCHIP_SOC(CPU, id, ID) \
+static inline bool soc_is_##id(void) \
+{ \
+	if (!IS_ENABLED(CONFIG_CPU_##CPU)) \
+		return false; \
+	if (rockchip_soc_id) \
+		return ((rockchip_soc_id & ROCKCHIP_SOC_MASK) == ROCKCHIP_SOC_ ##ID); \
+	return of_machine_is_compatible("rockchip,"#id); \
+}
+
+ROCKCHIP_SOC(PX30, px30, PX30)
+ROCKCHIP_SOC(PX30, px30s, PX30S)
+ROCKCHIP_SOC(RV1106, rv1103, RV1103)
+ROCKCHIP_SOC(RV1106, rv1106, RV1106)
+ROCKCHIP_SOC(RV1126, rv1109, RV1109)
+ROCKCHIP_SOC(RV1126, rv1126, RV1126)
+ROCKCHIP_SOC(RK312X, rk3126, RK3126)
+ROCKCHIP_SOC(RK312X, rk3126b, RK3126B)
+ROCKCHIP_SOC(RK312X, rk3126c, RK3126C)
+ROCKCHIP_SOC(RK312X, rk3128, RK3128)
+ROCKCHIP_SOC(RK3288, rk3288, RK3288)
+ROCKCHIP_SOC(RK3288, rk3288w, RK3288W)
+ROCKCHIP_SOC(RK3308, rk3308, RK3308)
+ROCKCHIP_SOC(RK3308, rk3308b, RK3308B)
+ROCKCHIP_SOC(RK3308, rk3308bs, RK3308BS)
+ROCKCHIP_SOC(RK3528, rk3528, RK3528)
+ROCKCHIP_SOC(RK3528, rk3528a, RK3528A)
+ROCKCHIP_SOC(RK3568, rk3566, RK3566)
+ROCKCHIP_SOC(RK3568, rk3568, RK3568)
+
+#endif
diff --git a/include/linux/rockchip/grf.h b/include/linux/rockchip/grf.h
new file mode 100644
index 000000000000..fae51232297c
--- /dev/null
+++ b/include/linux/rockchip/grf.h
@@ -0,0 +1,700 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __MACH_ROCKCHIP_GRF_H
+#define __MACH_ROCKCHIP_GRF_H
+
+#define RK3188_GRF_GPIO0L_DIR           0x0000
+#define RK3188_GRF_GPIO0H_DIR           0x0004
+#define RK3188_GRF_GPIO1L_DIR           0x0008
+#define RK3188_GRF_GPIO1H_DIR           0x000c
+#define RK3188_GRF_GPIO2L_DIR           0x0010
+#define RK3188_GRF_GPIO2H_DIR           0x0014
+#define RK3188_GRF_GPIO3L_DIR           0x0018
+#define RK3188_GRF_GPIO3H_DIR           0x001c
+#define RK3188_GRF_GPIO0L_DO            0x0020
+#define RK3188_GRF_GPIO0H_DO            0x0024
+#define RK3188_GRF_GPIO1L_DO            0x0028
+#define RK3188_GRF_GPIO1H_DO            0x002c
+#define RK3188_GRF_GPIO2L_DO            0x0030
+#define RK3188_GRF_GPIO2H_DO            0x0034
+#define RK3188_GRF_GPIO3L_DO            0x0038
+#define RK3188_GRF_GPIO3H_DO            0x003c
+#define RK3188_GRF_GPIO0L_EN            0x0040
+#define RK3188_GRF_GPIO0H_EN            0x0044
+#define RK3188_GRF_GPIO1L_EN            0x0048
+#define RK3188_GRF_GPIO1H_EN            0x004c
+#define RK3188_GRF_GPIO2L_EN            0x0050
+#define RK3188_GRF_GPIO2H_EN            0x0054
+#define RK3188_GRF_GPIO3L_EN            0x0058
+#define RK3188_GRF_GPIO3H_EN            0x005c
+
+#define RK3188_GRF_GPIO0C_IOMUX         0x0068
+#define RK3188_GRF_GPIO0D_IOMUX         0x006c
+#define RK3188_GRF_GPIO1A_IOMUX         0x0070
+#define RK3188_GRF_GPIO1B_IOMUX         0x0074
+#define RK3188_GRF_GPIO1C_IOMUX         0x0078
+#define RK3188_GRF_GPIO1D_IOMUX         0x007c
+#define RK3188_GRF_GPIO2A_IOMUX         0x0080
+#define RK3188_GRF_GPIO2B_IOMUX         0x0084
+#define RK3188_GRF_GPIO2C_IOMUX         0x0088
+#define RK3188_GRF_GPIO2D_IOMUX         0x008c
+#define RK3188_GRF_GPIO3A_IOMUX         0x0090
+#define RK3188_GRF_GPIO3B_IOMUX         0x0094
+#define RK3188_GRF_GPIO3C_IOMUX         0x0098
+#define RK3188_GRF_GPIO3D_IOMUX         0x009c
+#define RK3188_GRF_SOC_CON0             0x00a0
+#define RK3188_GRF_SOC_CON1             0x00a4
+#define RK3188_GRF_SOC_CON2             0x00a8
+#define RK3188_GRF_SOC_STATUS0          0x00ac
+#define RK3188_GRF_DMAC1_CON0           0x00b0
+#define RK3188_GRF_DMAC1_CON1           0x00b4
+#define RK3188_GRF_DMAC1_CON2           0x00b8
+#define RK3188_GRF_DMAC2_CON0           0x00bc
+#define RK3188_GRF_DMAC2_CON1           0x00c0
+#define RK3188_GRF_DMAC2_CON2           0x00c4
+#define RK3188_GRF_DMAC2_CON3           0x00c8
+#define RK3188_GRF_CPU_CON0             0x00cc
+#define RK3188_GRF_CPU_CON1             0x00d0
+#define RK3188_GRF_CPU_CON2             0x00d4
+#define RK3188_GRF_CPU_CON3             0x00d8
+#define RK3188_GRF_CPU_CON4             0x00dc
+#define RK3188_GRF_CPU_CON5             0x00e0
+
+#define RK3188_GRF_DDRC_CON0            0x00ec
+#define RK3188_GRF_DDRC_STAT            0x00f0
+#define RK3188_GRF_IO_CON0              0x00f4
+#define RK3188_GRF_IO_CON1              0x00f8
+#define RK3188_GRF_IO_CON2              0x00fc
+#define RK3188_GRF_IO_CON3              0x0100
+#define RK3188_GRF_IO_CON4              0x0104
+#define RK3188_GRF_SOC_STATUS1          0x0108
+#define RK3188_GRF_UOC0_CON0            0x010c
+#define RK3188_GRF_UOC0_CON1            0x0110
+#define RK3188_GRF_UOC0_CON2            0x0114
+#define RK3188_GRF_UOC0_CON3            0x0118
+#define RK3188_GRF_UOC1_CON0            0x011c
+#define RK3188_GRF_UOC1_CON1            0x0120
+#define RK3188_GRF_UOC1_CON2            0x0124
+#define RK3188_GRF_UOC1_CON3            0x0128
+#define RK3188_GRF_UOC2_CON0            0x012c
+#define RK3188_GRF_UOC2_CON1            0x0130
+
+#define RK3188_GRF_UOC3_CON0            0x0138
+#define RK3188_GRF_UOC3_CON1            0x013c
+#define RK3188_GRF_EHCI_STAT            0x0140
+#define RK3188_GRF_OS_REG0              0x0144
+#define RK3188_GRF_OS_REG1              0x0148
+#define RK3188_GRF_OS_REG2              0x014c
+#define RK3188_GRF_OS_REG3              0x0150
+#define RK3188_GRF_OS_REG4              0x0154
+#define RK3188_GRF_OS_REG5              0x0158
+#define RK3188_GRF_OS_REG6              0x015c
+#define RK3188_GRF_OS_REG7              0x0160
+#define RK3188_GRF_GPIO0B_PULL          0x0164
+#define RK3188_GRF_GPIO0C_PULL          0x0168
+#define RK3188_GRF_GPIO0D_PULL          0x016c
+#define RK3188_GRF_GPIO1A_PULL          0x0170
+#define RK3188_GRF_GPIO1B_PULL          0x0174
+#define RK3188_GRF_GPIO1C_PULL          0x0178
+#define RK3188_GRF_GPIO1D_PULL          0x017c
+#define RK3188_GRF_GPIO2A_PULL          0x0180
+#define RK3188_GRF_GPIO2B_PULL          0x0184
+#define RK3188_GRF_GPIO2C_PULL          0x0188
+#define RK3188_GRF_GPIO2D_PULL          0x018c
+#define RK3188_GRF_GPIO3A_PULL          0x0190
+#define RK3188_GRF_GPIO3B_PULL          0x0194
+#define RK3188_GRF_GPIO3C_PULL          0x0198
+#define RK3188_GRF_GPIO3D_PULL          0x019c
+#define RK3188_GRF_FLASH_DATA_PULL      0x01a0
+#define RK3188_GRF_FLASH_CMD_PULL       0x01a4
+
+
+#define RK3288_GRF_GPIO0_A_IOMUX	0x0084
+#define RK3288_GRF_GPIO0_B_IOMUX	0x0088
+#define RK3288_GRF_GPIO0_C_IOMUX	0x008c
+
+#define RK3288_GRF_GPIO1D_IOMUX         0x000c
+#define RK3288_GRF_GPIO2A_IOMUX         0x0010
+#define RK3288_GRF_GPIO2B_IOMUX         0x0014
+#define RK3288_GRF_GPIO2C_IOMUX         0x0018
+
+#define RK3288_GRF_GPIO3A_IOMUX         0x0020
+#define RK3288_GRF_GPIO3B_IOMUX         0x0024
+#define RK3288_GRF_GPIO3C_IOMUX         0x0028
+#define RK3288_GRF_GPIO3DL_IOMUX        0x002c
+#define RK3288_GRF_GPIO3DH_IOMUX        0x0030
+#define RK3288_GRF_GPIO4AL_IOMUX        0x0034
+#define RK3288_GRF_GPIO4AH_IOMUX        0x0038
+#define RK3288_GRF_GPIO4BL_IOMUX        0x003c
+
+#define RK3288_GRF_GPIO4C_IOMUX         0x0044
+#define RK3288_GRF_GPIO4D_IOMUX         0x0048
+
+#define RK3288_GRF_GPIO5B_IOMUX         0x0050
+#define RK3288_GRF_GPIO5C_IOMUX         0x0054
+
+#define RK3288_GRF_GPIO6A_IOMUX         0x005c
+#define RK3288_GRF_GPIO6B_IOMUX         0x0060
+#define RK3288_GRF_GPIO6C_IOMUX         0x0064
+
+#define RK3288_GRF_GPIO7A_IOMUX         0x006c
+#define RK3288_GRF_GPIO7B_IOMUX         0x0070
+#define RK3288_GRF_GPIO7CL_IOMUX        0x0074
+#define RK3288_GRF_GPIO7CH_IOMUX        0x0078
+
+#define RK3288_GRF_GPIO8A_IOMUX         0x0080
+#define RK3288_GRF_GPIO8B_IOMUX         0x0084
+
+#define RK3288_GRF_GPIO1H_SR            0x0104
+#define RK3288_GRF_GPIO2L_SR            0x0108
+#define RK3288_GRF_GPIO2H_SR            0x010c
+#define RK3288_GRF_GPIO3L_SR            0x0110
+#define RK3288_GRF_GPIO3H_SR            0x0114
+#define RK3288_GRF_GPIO4L_SR            0x0118
+#define RK3288_GRF_GPIO4H_SR            0x011c
+#define RK3288_GRF_GPIO5L_SR            0x0120
+#define RK3288_GRF_GPIO5H_SR            0x0124
+#define RK3288_GRF_GPIO6L_SR            0x0128
+#define RK3288_GRF_GPIO6H_SR            0x012c
+#define RK3288_GRF_GPIO7L_SR            0x0130
+#define RK3288_GRF_GPIO7H_SR            0x0134
+#define RK3288_GRF_GPIO8L_SR            0x0138
+
+#define RK3288_GRF_GPIO1D_P             0x014c
+#define RK3288_GRF_GPIO2A_P             0x0150
+#define RK3288_GRF_GPIO2B_P             0x0154
+#define RK3288_GRF_GPIO2C_P             0x0158
+
+#define RK3288_GRF_GPIO3A_P             0x0160
+#define RK3288_GRF_GPIO3B_P             0x0164
+#define RK3288_GRF_GPIO3C_P             0x0168
+#define RK3288_GRF_GPIO3D_P             0x016c
+#define RK3288_GRF_GPIO4A_P             0x0170
+#define RK3288_GRF_GPIO4B_P             0x0174
+#define RK3288_GRF_GPIO4C_P             0x0178
+#define RK3288_GRF_GPIO4D_P             0x017c
+
+#define RK3288_GRF_GPIO5B_P             0x0184
+#define RK3288_GRF_GPIO5C_P             0x0188
+
+#define RK3288_GRF_GPIO6A_P             0x0190
+#define RK3288_GRF_GPIO6B_P             0x0194
+#define RK3288_GRF_GPIO6C_P             0x0198
+
+#define RK3288_GRF_GPIO7A_P             0x01a0
+#define RK3288_GRF_GPIO7B_P             0x01a4
+#define RK3288_GRF_GPIO7C_P             0x01a8
+
+#define RK3288_GRF_GPIO8A_P             0x01b0
+#define RK3288_GRF_GPIO8B_P             0x01b4
+
+#define RK3288_GRF_GPIO1D_E             0x01cc
+#define RK3288_GRF_GPIO2A_E             0x01d0
+#define RK3288_GRF_GPIO2B_E             0x01d4
+#define RK3288_GRF_GPIO2C_E             0x01d8
+
+#define RK3288_GRF_GPIO3A_E             0x01e0
+#define RK3288_GRF_GPIO3B_E             0x01e4
+#define RK3288_GRF_GPIO3C_E             0x01e8
+#define RK3288_GRF_GPIO3D_E             0x01ec
+#define RK3288_GRF_GPIO4A_E             0x01f0
+#define RK3288_GRF_GPIO4B_E             0x01f4
+#define RK3288_GRF_GPIO4C_E             0x01f8
+#define RK3288_GRF_GPIO4D_E             0x01fc
+
+#define RK3288_GRF_GPIO5B_E             0x0204
+#define RK3288_GRF_GPIO5C_E             0x0208
+
+#define RK3288_GRF_GPIO6A_E             0x0210
+#define RK3288_GRF_GPIO6B_E             0x0214
+#define RK3288_GRF_GPIO6C_E             0x0218
+
+#define RK3288_GRF_GPIO7A_E             0x0220
+#define RK3288_GRF_GPIO7B_E             0x0224
+#define RK3288_GRF_GPIO7C_E             0x0228
+
+#define RK3288_GRF_GPIO8A_E             0x0230
+#define RK3288_GRF_GPIO8B_E             0x0234
+
+#define RK3288_GRF_GPIO_SMT             0x0240
+#define RK3288_GRF_SOC_CON0             0x0244
+#define RK3288_GRF_SOC_CON1             0x0248
+#define RK3288_GRF_SOC_CON2             0x024c
+#define RK3288_GRF_SOC_CON3             0x0250
+#define RK3288_GRF_SOC_CON4             0x0254
+#define RK3288_GRF_SOC_CON5             0x0258
+#define RK3288_GRF_SOC_CON6             0x025c
+#define RK3288_GRF_SOC_CON7             0x0260
+#define RK3288_GRF_SOC_CON8             0x0264
+#define RK3288_GRF_SOC_CON9             0x0268
+#define RK3288_GRF_SOC_CON10            0x026c
+#define RK3288_GRF_SOC_CON11            0x0270
+#define RK3288_GRF_SOC_CON12            0x0274
+#define RK3288_GRF_SOC_CON13            0x0278
+#define RK3288_GRF_SOC_CON14            0x027c
+#define RK3288_GRF_SOC_STATUS0          0x0280
+#define RK3288_GRF_SOC_STATUS1          0x0284
+#define RK3288_GRF_SOC_STATUS2          0x0288
+#define RK3288_GRF_SOC_STATUS3          0x028c
+#define RK3288_GRF_SOC_STATUS4          0x0290
+#define RK3288_GRF_SOC_STATUS5          0x0294
+#define RK3288_GRF_SOC_STATUS6          0x0298
+#define RK3288_GRF_SOC_STATUS7          0x029c
+#define RK3288_GRF_SOC_STATUS8          0x02a0
+#define RK3288_GRF_SOC_STATUS9          0x02a4
+#define RK3288_GRF_SOC_STATUS10         0x02a8
+#define RK3288_GRF_SOC_STATUS11         0x02ac
+#define RK3288_GRF_SOC_STATUS12         0x02b0
+#define RK3288_GRF_SOC_STATUS13         0x02b4
+#define RK3288_GRF_SOC_STATUS14         0x02b8
+#define RK3288_GRF_SOC_STATUS15         0x02bc
+#define RK3288_GRF_SOC_STATUS16         0x02c0
+#define RK3288_GRF_SOC_STATUS17         0x02c4
+#define RK3288_GRF_SOC_STATUS18         0x02c8
+#define RK3288_GRF_SOC_STATUS19         0x02cc
+#define RK3288_GRF_SOC_STATUS20         0x02d0
+#define RK3288_GRF_SOC_STATUS21         0x02d4
+
+#define RK3288_GRF_PERIDMAC_CON0        0x02e0
+#define RK3288_GRF_PERIDMAC_CON1        0x02e4
+#define RK3288_GRF_PERIDMAC_CON2        0x02e8
+#define RK3288_GRF_PERIDMAC_CON3        0x02ec
+#define RK3288_GRF_DDRC0_CON0           0x02f0
+#define RK3288_GRF_DDRC1_CON0           0x02f4
+#define RK3288_GRF_CPU_CON0             0x02f8
+#define RK3288_GRF_CPU_CON1             0x02fc
+#define RK3288_GRF_CPU_CON2             0x0300
+#define RK3288_GRF_CPU_CON3             0x0304
+#define RK3288_GRF_CPU_CON4             0x0308
+
+#define RK3288_GRF_CPU_STATUS0          0x0318
+
+#define RK3288_GRF_UOC0_CON0            0x0320
+#define RK3288_GRF_UOC0_CON1            0x0324
+#define RK3288_GRF_UOC0_CON2            0x0328
+#define RK3288_GRF_UOC0_CON3            0x032c
+#define RK3288_GRF_UOC0_CON4            0x0330
+#define RK3288_GRF_UOC1_CON0            0x0334
+#define RK3288_GRF_UOC1_CON1            0x0338
+#define RK3288_GRF_UOC1_CON2            0x033c
+#define RK3288_GRF_UOC1_CON3            0x0340
+#define RK3288_GRF_UOC1_CON4            0x0344
+#define RK3288_GRF_UOC2_CON0            0x0348
+#define RK3288_GRF_UOC2_CON1            0x034c
+#define RK3288_GRF_UOC2_CON2            0x0350
+#define RK3288_GRF_UOC2_CON3            0x0354
+#define RK3288_GRF_UOC3_CON0            0x0358
+#define RK3288_GRF_UOC3_CON1            0x035c
+#define RK3288_GRF_UOC4_CON0            0x0360
+#define RK3288_GRF_UOC4_CON1            0x0364
+#define RK3288_GRF_PVTM_CON0            0x0368
+#define RK3288_GRF_PVTM_CON1            0x036c
+#define RK3288_GRF_PVTM_CON2            0x0370
+#define RK3288_GRF_PVTM_STATUS0         0x0374
+#define RK3288_GRF_PVTM_STATUS1         0x0378
+#define RK3288_GRF_PVTM_STATUS2         0x037c
+#define RK3288_GRF_IO_VSEL              0x0380
+#define RK3288_GRF_SARADC_TESTBIT       0x0384
+#define RK3288_GRF_TSADC_TESTBIT_L      0x0388
+#define RK3288_GRF_TSADC_TESTBIT_H      0x038c
+#define RK3288_GRF_OS_REG0              0x0390
+#define RK3288_GRF_OS_REG1              0x0394
+#define RK3288_GRF_OS_REG2              0x0398
+#define RK3288_GRF_OS_REG3              0x039c
+
+#define RK3288_GRF_SOC_CON15            0x03a4
+#define RK3288_GRF_SOC_CON16            0x03a8
+
+#define RK3288_SGRF_SOC_CON0            0x0000
+#define RK3288_SGRF_SOC_CON1            0x0004
+#define RK3288_SGRF_SOC_CON2            0x0008
+#define RK3288_SGRF_SOC_CON3            0x000c
+#define RK3288_SGRF_SOC_CON4            0x0010
+#define RK3288_SGRF_SOC_CON5            0x0014
+
+#define RK3288_SGRF_BUSDMAC_CON0        0x0020
+#define RK3288_SGRF_BUSDMAC_CON1        0x0024
+
+#define RK3288_SGRF_CPU_CON0            0x0040
+#define RK3288_SGRF_CPU_CON1            0x0044
+#define RK3288_SGRF_CPU_CON2            0x0048
+
+#define RK3288_SGRF_SOC_CON6            0x0050
+#define RK3288_SGRF_SOC_CON7            0x0054
+#define RK3288_SGRF_SOC_CON8            0x0058
+#define RK3288_SGRF_SOC_CON9            0x005c
+#define RK3288_SGRF_SOC_CON10           0x0060
+#define RK3288_SGRF_SOC_CON11           0x0064
+#define RK3288_SGRF_SOC_CON12           0x0068
+#define RK3288_SGRF_SOC_CON13           0x006c
+#define RK3288_SGRF_SOC_CON14           0x0070
+#define RK3288_SGRF_SOC_CON15           0x0074
+#define RK3288_SGRF_SOC_CON16           0x0078
+#define RK3288_SGRF_SOC_CON17           0x007c
+#define RK3288_SGRF_SOC_CON18           0x0080
+#define RK3288_SGRF_SOC_CON19           0x0084
+#define RK3288_SGRF_SOC_CON20           0x0088
+#define RK3288_SGRF_SOC_CON21           0x008c
+
+#define RK3288_SGRF_SOC_STATUS0         0x0100
+#define RK3288_SGRF_SOC_STATUS1         0x0104
+
+#define RK3288_SGRF_FAST_BOOT_ADDR      0x0120
+
+
+#define RK3036_GRF_GPIO0A_IOMUX         0x000a8
+#define RK3036_GRF_GPIO0B_IOMUX         0x000ac
+#define RK3036_GRF_GPIO0C_IOMUX         0x000b0
+#define RK3036_GRF_GPIO0D_IOMUX         0x000b4
+#define RK3036_GRF_GPIO1A_IOMUX         0x000b8
+#define RK3036_GRF_GPIO1B_IOMUX         0x000bc
+#define RK3036_GRF_GPIO1C_IOMUX         0x000c0
+#define RK3036_GRF_GPIO1D_IOMUX         0x000c4
+#define RK3036_GRF_GPIO2A_IOMUX         0x000c8
+#define RK3036_GRF_GPIO2B_IOMUX         0x000cc
+#define RK3036_GRF_GPIO2C_IOMUX         0x000d0
+#define RK3036_GRF_GPIO2D_IOMUX         0x000d4
+#define RK3036_GRF_GPIO_DS              0x00100
+#define RK3036_GRF_GPIO0L_PULL          0x00118
+#define RK3036_GRF_GPIO0H_PULL          0x0011c
+#define RK3036_GRF_GPIO1L_PULL          0x00120
+#define RK3036_GRF_GPIO1H_PULL          0x00124
+
+#define RK3036_GRF_GPIO2L_PULL 0x00128
+#define RK3036_GRF_GPIO2H_PULL 0x0012c
+#define RK3036_GRF_SOC_CON0 0x00140
+#define RK3036_GRF_SOC_CON1 0x00144
+#define RK3036_GRF_SOC_CON2 0x00148
+#define RK3036_GRF_SOC_STATUS0 0x0014c
+#define RK3036_GRF_SOC_CON3 0x00154
+#define RK3036_GRF_DMAC_CON0 0x0015c
+#define RK3036_GRF_DMAC_CON1 0x00160
+#define RK3036_GRF_DMAC_CON2 0x00164
+#define RK3036_GRF_UOC0_CON5 0x0017c
+#define RK3036_GRF_UOC1_CON4 0x00190
+#define RK3036_GRF_UOC1_CON5 0x00194
+#define RK3036_GRF_DDRC_STAT 0x0019c
+#define RK3036_GRF_UOC_CON6 0x001a0
+#define RK3036_GRF_SOC_STATUS1 0x001a4
+#define RK3036_GRF_CPU_CON0 0x001a8
+#define RK3036_GRF_CPU_CON1 0x001ac
+#define RK3036_GRF_CPU_CON2 0x001b0
+#define RK3036_GRF_CPU_CON3 0x001b4
+#define RK3036_GRF_CPU_STATUS0 0x001c0
+#define RK3036_GRF_CPU_STATUS1 0x001c4
+#define RK3036_GRF_OS_REG0 0x001c8
+#define RK3036_GRF_OS_REG1 0x001cc
+#define RK3036_GRF_OS_REG2 0x001d0
+#define RK3036_GRF_OS_REG3 0x001d4
+#define RK3036_GRF_OS_REG4 0x001d8
+#define RK3036_GRF_OS_REG5 0x001dc
+#define RK3036_GRF_OS_REG6 0x001e0
+#define RK3036_GRF_OS_REG7 0x001e4
+#define RK3036_GRF_DLL_CON0 0x00200
+#define RK3036_GRF_DLL_CON1 0x00204
+#define RK3036_GRF_DLL_CON2 0x00208
+#define RK3036_GRF_DLL_CON3 0x0020c
+#define RK3036_GRF_DLL_STATUS0 0x00210
+#define RK3036_GRF_DLL_STATUS1 0x00214
+
+#define RK3036_GRF_DLL_STATUS2 0x00218
+#define RK3036_GRF_DLL_STATUS3 0x0021c
+#define RK3036_GRF_DFI_WRNUM 0x00220
+#define RK3036_GRF_DFI_RDNUM 0x00224
+#define RK3036_GRF_DFI_ACTNUM 0x00228
+#define RK3036_GRF_DFI_TIMERVAL 0x0022c
+#define RK3036_GRF_NIF_FIFO0 0x00230
+#define RK3036_GRF_NIF_FIFO1 0x00234
+#define RK3036_GRF_NIF_FIFO2 0x00238
+#define RK3036_GRF_NIF_FIFO3 0x0023c
+#define RK3036_GRF_USBPHY0_CON0 0x00280
+#define RK3036_GRF_USBPHY0_CON1 0x00284
+#define RK3036_GRF_USBPHY0_CON2 0x00288
+#define RK3036_GRF_USBPHY0_CON3 0x0028c
+#define RK3036_GRF_USBPHY0_CON4 0x00290
+#define RK3036_GRF_USBPHY0_CON5 0x00294
+#define RK3036_GRF_USBPHY0_CON6 0x00298
+#define RK3036_GRF_USBPHY0_CON7 0x0029c
+#define RK3036_GRF_USBPHY1_CON0 0x002a0
+#define RK3036_GRF_USBPHY1_CON1 0x002a4
+#define RK3036_GRF_USBPHY1_CON2 0x002a8
+#define RK3036_GRF_USBPHY1_CON3 0x002ac
+#define RK3036_GRF_USBPHY1_CON4 0x002b0
+#define RK3036_GRF_USBPHY1_CON5 0x002b4
+#define RK3036_GRF_USBPHY1_CON6 0x002b8
+
+#define RK3036_GRF_USBPHY1_CON7 0x002bc
+#define RK3036_GRF_CHIP_TAG 0x00300
+#define RK3036_GRF_SDMMC_DET_CNT 0x00304
+
+#define RK312X_GRF_GPIO0A_IOMUX         0x000a8
+#define RK312X_GRF_GPIO0B_IOMUX         0x000ac
+#define RK312X_GRF_GPIO0C_IOMUX         0x000b0
+#define RK312X_GRF_GPIO0D_IOMUX         0x000b4
+#define RK312X_GRF_GPIO1A_IOMUX         0x000b8
+#define RK312X_GRF_GPIO1B_IOMUX         0x000bc
+#define RK312X_GRF_GPIO1C_IOMUX         0x000c0
+#define RK312X_GRF_GPIO1D_IOMUX         0x000c4
+#define RK312X_GRF_GPIO2A_IOMUX         0x000c8
+#define RK312X_GRF_GPIO2B_IOMUX         0x000cc
+#define RK312X_GRF_GPIO2C_IOMUX         0x000d0
+#define RK312X_GRF_GPIO2D_IOMUX         0x000d4
+#define RK312X_GRF_GPIO3A_IOMUX         0x000d8
+#define RK312X_GRF_GPIO3B_IOMUX         0x000dc
+#define RK312X_GRF_GPIO3C_IOMUX         0x000e0
+#define RK312X_GRF_GPIO3D_IOMUX         0x000e4
+#define RK312X_GRF_CIF_IOMUX		0x000ec
+#define RK312X_GRF_CIF_IOMUX1 		0x000f0
+#define RK312X_GRF_GPIO_DS              0x00100
+#define RK312X_GRF_GPIO0L_PULL          0x00118
+#define RK312X_GRF_GPIO0H_PULL          0x0011c
+#define RK312X_GRF_GPIO1L_PULL          0x00120
+#define RK312X_GRF_GPIO1H_PULL          0x00124
+#define RK312X_GRF_GPIO2L_PULL          0x00128
+#define RK312X_GRF_GPIO2H_PULL          0x0012c
+#define RK312X_GRF_GPIO3L_PULL          0x00130
+#define RK312X_GRF_GPIO3H_PULL          0x00134
+#define RK312X_GRF_ACODEC_CON		0x0013c
+
+#define RK312X_GRF_SOC_CON0 0x00140
+#define RK312X_GRF_SOC_CON1 0x00144
+#define RK312X_GRF_SOC_CON2 0x00148
+#define RK312X_GRF_SOC_STATUS0 0x0014c
+#define RK312X_GRF_LVDS_CON0 0x00150
+#define RK312X_GRF_SOC_CON3 0x00154
+#define RK312X_GRF_DMAC_CON0 0x0015c
+#define RK312X_GRF_DMAC_CON1 0x00160
+#define RK312X_GRF_DMAC_CON2 0x00164
+#define RK312X_GRF_MAC_CON0 0x00168
+#define RK312X_GRF_MAC_CON1 0x0016c
+#define RK312X_GRF_TVE_CON 0x00170
+#define RK312X_GRF_UOC0_CON0 0x0017c
+#define RK312X_GRF_UOC1_CON1 0x00184
+#define RK312X_GRF_UOC1_CON2 0x00188
+#define RK312X_GRF_UOC1_CON3 0x0018c
+#define RK312X_GRF_UOC1_CON4 0x00190
+#define RK312X_GRF_UOC1_CON5 0x00194
+#define RK312X_GRF_DDRC_STAT 0x0019c
+#define RK312X_GRF_SOC_STATUS1 0x001a4
+#define RK312X_GRF_CPU_CON0 0x001a8
+#define RK312X_GRF_CPU_CON1 0x001ac
+#define RK312X_GRF_CPU_CON2 0x001b0
+#define RK312X_GRF_CPU_CON3 0x001b4
+#define RK312X_GRF_CPU_STATUS0 0x001c0
+#define RK312X_GRF_CPU_STATUS1 0x001c4
+#define RK312X_GRF_OS_REG0 0x001c8
+#define RK312X_GRF_OS_REG1 0x001cc
+#define RK312X_GRF_OS_REG2 0x001d0
+#define RK312X_GRF_OS_REG3 0x001d4
+#define RK312X_GRF_OS_REG4 0x001d8
+#define RK312X_GRF_OS_REG5 0x001dc
+#define RK312X_GRF_OS_REG6 0x001e0
+#define RK312X_GRF_OS_REG7 0x001e4
+#define RK312X_GRF_PVTM_CON0 0x00200
+#define RK312X_GRF_PVTM_CON1 0x00204
+#define RK312X_GRF_PVTM_CON2 0x00208
+#define RK312X_GRF_PVTM_CON3 0x0020c
+#define RK312X_GRF_PVTM_STATUS0 0x00210
+#define RK312X_GRF_PVTM_STATUS1 0x00214
+#define RK312X_GRF_PVTM_STATUS2 0x00218
+#define RK312X_GRF_PVTM_STATUS3 0x0021c
+#define RK312X_GRF_DFI_WRNUM 0x00220
+#define RK312X_GRF_DFI_RDNUM 0x00224
+#define RK312X_GRF_DFI_ACTNUM 0x00228
+#define RK312X_GRF_DFI_TIMERVAL 0x0022c
+#define RK312X_GRF_NIF_FIFO0 0x00230
+#define RK312X_GRF_NIF_FIFO1 0x00234
+#define RK312X_GRF_NIF_FIFO2 0x00238
+#define RK312X_GRF_NIF_FIFO3 0x0023c
+#define RK312X_GRF_USBPHY0_CON0 0x00280
+#define RK312X_GRF_USBPHY0_CON1 0x00284
+#define RK312X_GRF_USBPHY0_CON2 0x00288
+#define RK312X_GRF_USBPHY0_CON3 0x0028c
+#define RK312X_GRF_USBPHY0_CON4 0x00290
+#define RK312X_GRF_USBPHY0_CON5 0x00294
+#define RK312X_GRF_USBPHY0_CON6 0x00298
+#define RK312X_GRF_USBPHY0_CON7 0x0029c
+#define RK312X_GRF_USBPHY1_CON0 0x002a0
+#define RK312X_GRF_USBPHY1_CON1 0x002a4
+#define RK312X_GRF_USBPHY1_CON2 0x002a8
+#define RK312X_GRF_USBPHY1_CON3 0x002ac
+#define RK312X_GRF_USBPHY1_CON4 0x002b0
+#define RK312X_GRF_USBPHY1_CON5 0x002b4
+#define RK312X_GRF_USBPHY1_CON6 0x002b8
+#define RK312X_GRF_USBPHY1_CON7 0x002bc
+#define RK312X_GRF_UOC_STATUS0 0x002c0
+#define RK312X_GRF_CHIP_TAG 0x00300
+#define RK312X_GRF_SDMMC_DET_CNT 0x00304
+#define RK312X_GRF_EFUSE_PRG_EN 0x0037c
+
+#define RK3228_GRF_GPIO0A_IOMUX		0x0000
+#define RK3228_GRF_GPIO0B_IOMUX		0x0004
+#define RK3228_GRF_GPIO0C_IOMUX		0x0008
+#define RK3228_GRF_GPIO0D_IOMUX		0x000c
+#define RK3228_GRF_GPIO1A_IOMUX		0x0010
+#define RK3228_GRF_GPIO1B_IOMUX		0x0014
+#define RK3228_GRF_GPIO1C_IOMUX		0x0018
+#define RK3228_GRF_GPIO1D_IOMUX		0x001c
+#define RK3228_GRF_GPIO2A_IOMUX		0x0020
+#define RK3228_GRF_GPIO2B_IOMUX		0x0024
+#define RK3228_GRF_GPIO2C_IOMUX		0x0028
+#define RK3228_GRF_GPIO2D_IOMUX		0x002c
+#define RK3228_GRF_GPIO3A_IOMUX		0x0030
+#define RK3228_GRF_GPIO3B_IOMUX		0x0034
+#define RK3228_GRF_GPIO3C_IOMUX		0x0038
+#define RK3228_GRF_GPIO3D_IOMUX		0x003c
+#define RK3228_GRF_COM_IOMUX		0x0050
+#define RK3228_GRF_GPIO0A_P		0x0100
+#define RK3228_GRF_GPIO0B_P		0x0104
+#define RK3228_GRF_GPIO0C_P		0x0108
+#define RK3228_GRF_GPIO0D_P		0x010c
+#define RK3228_GRF_GPIO1A_P		0x0110
+#define RK3228_GRF_GPIO1B_P		0x0114
+#define RK3228_GRF_GPIO1C_P		0x0118
+#define RK3228_GRF_GPIO1D_P		0x011c
+#define RK3228_GRF_GPIO2A_P		0x0120
+#define RK3228_GRF_GPIO2B_P		0x0124
+#define RK3228_GRF_GPIO2C_P		0x0128
+#define RK3228_GRF_GPIO2D_P		0x012c
+#define RK3228_GRF_GPIO3A_P		0x0130
+#define RK3228_GRF_GPIO3B_P		0x0134
+#define RK3228_GRF_GPIO3C_P		0x0138
+#define RK3228_GRF_GPIO3D_P		0x013c
+#define RK3228_GRF_GPIO0A_E		0x0200
+#define RK3228_GRF_GPIO0B_E		0x0204
+#define RK3228_GRF_GPIO0C_E		0x0208
+#define RK3228_GRF_GPIO0D_E		0x020c
+#define RK3228_GRF_GPIO1A_E		0x0210
+#define RK3228_GRF_GPIO1B_E		0x0214
+#define RK3228_GRF_GPIO1C_E		0x0218
+#define RK3228_GRF_GPIO1D_E		0x021c
+#define RK3228_GRF_GPIO2A_E		0x0220
+#define RK3228_GRF_GPIO2B_E		0x0224
+#define RK3228_GRF_GPIO2C_E		0x0228
+#define RK3228_GRF_GPIO2D_E		0x022c
+#define RK3228_GRF_GPIO3A_E		0x0230
+#define RK3228_GRF_GPIO3B_E		0x0234
+#define RK3228_GRF_GPIO3C_E		0x0238
+#define RK3228_GRF_GPIO3D_E		0x023c
+#define RK3228_GRF_GPIO0L_SR		0x0300
+#define RK3228_GRF_GPIO0H_SR		0x0304
+#define RK3228_GRF_GPIO1L_SR		0x0308
+#define RK3228_GRF_GPIO1H_SR		0x030c
+#define RK3228_GRF_GPIO2L_SR		0x0310
+#define RK3228_GRF_GPIO2H_SR		0x0314
+#define RK3228_GRF_GPIO3L_SR		0x0318
+#define RK3228_GRF_GPIO3H_SR		0x031c
+#define RK3228_GRF_GPIO0L_SMT		0x0380
+#define RK3228_GRF_GPIO0H_SMT		0x0384
+#define RK3228_GRF_GPIO1L_SMT		0x0388
+#define RK3228_GRF_GPIO1H_SMT		0x038c
+#define RK3228_GRF_GPIO2L_SMT		0x0390
+#define RK3228_GRF_GPIO2H_SMT		0x0394
+#define RK3228_GRF_GPIO3L_SMT		0x0398
+#define RK3228_GRF_GPIO3H_SMT		0x039c
+#define RK3228_GRF_SOC_CON0		0x0400
+#define RK3228_GRF_SOC_CON1		0x0404
+#define RK3228_GRF_SOC_CON2		0x0408
+#define RK3228_GRF_SOC_CON3		0x040c
+#define RK3228_GRF_SOC_CON4		0x0410
+#define RK3228_GRF_SOC_CON5		0x0414
+#define RK3228_GRF_SOC_CON6		0x0418
+#define RK3228_GRF_SOC_STATUS0		0x0480
+#define RK3228_GRF_SOC_STATUS1		0x0484
+#define RK3228_GRF_SOC_STATUS2		0x0488
+#define RK3228_GRF_CHIP_ID		0x048c
+#define RK3228_GRF_CPU_CON0		0x0500
+#define RK3228_GRF_CPU_CON1		0x0504
+#define RK3228_GRF_CPU_CON2		0x0508
+#define RK3228_GRF_CPU_CON3		0x050c
+#define RK3228_GRF_CPU_STATUS0		0x0520
+#define RK3228_GRF_CPU_STATUS1		0x0524
+#define RK3228_GRF_OS_REG0		0x05c8
+#define RK3228_GRF_OS_REG1		0x05cc
+#define RK3228_GRF_OS_REG2		0x05d0
+#define RK3228_GRF_OS_REG3		0x05d4
+#define RK3228_GRF_OS_REG4		0x05d8
+#define RK3228_GRF_OS_REG5		0x05dc
+#define RK3228_GRF_OS_REG6		0x05e0
+#define RK3228_GRF_OS_REG7		0x05e4
+#define RK3228_GRF_DDRC_STAT		0x0604
+#define RK3228_GRF_SIG_DETECT_CON	0x0680
+#define RK3228_GRF_SIG_DETECT_CON1	0x0684
+#define RK3228_GRF_SIG_DETECT_STATUS	0x0690
+#define RK3228_GRF_SIG_DETECT_STATUS1	0x0694
+#define RK3228_GRF_SIG_DETECT_CLR	0x06a0
+#define RK3228_GRF_SIG_DETECT_CLR1	0x06a4
+#define RK3228_GRF_EMMC_DET		0x06b0
+#define RK3228_GRF_HOST0_CON0		0x0700
+#define RK3228_GRF_HOST0_CON1		0x0704
+#define RK3228_GRF_HOST0_CON2		0x0708
+#define RK3228_GRF_HOST1_CON0		0x0710
+#define RK3228_GRF_HOST1_CON1		0x0714
+#define RK3228_GRF_HOST1_CON2		0x0718
+#define RK3228_GRF_HOST2_CON0		0x0720
+#define RK3228_GRF_HOST2_CON1		0x0724
+#define RK3228_GRF_HOST2_CON2		0x0728
+#define RK3228_GRF_USBPHY0_CON0		0x0760
+#define RK3228_GRF_USBPHY0_CON1		0x0764
+#define RK3228_GRF_USBPHY0_CON2		0x0768
+#define RK3228_GRF_USBPHY0_CON3		0x076c
+#define RK3228_GRF_USBPHY0_CON4		0x0770
+#define RK3228_GRF_USBPHY0_CON5		0x0774
+#define RK3228_GRF_USBPHY0_CON6		0x0778
+#define RK3228_GRF_USBPHY0_CON7		0x077c
+#define RK3228_GRF_USBPHY0_CON8		0x0780
+#define RK3228_GRF_USBPHY0_CON9		0x0784
+#define RK3228_GRF_USBPHY0_CON10	0x0788
+#define RK3228_GRF_USBPHY0_CON11	0x078c
+#define RK3228_GRF_USBPHY0_CON12	0x0790
+#define RK3228_GRF_USBPHY0_CON13	0x0794
+#define RK3228_GRF_USBPHY0_CON14	0x0798
+#define RK3228_GRF_USBPHY0_CON15	0x079c
+#define RK3228_GRF_USBPHY0_CON16	0x07a0
+#define RK3228_GRF_USBPHY0_CON17	0x07a4
+#define RK3228_GRF_USBPHY0_CON18	0x07a8
+#define RK3228_GRF_USBPHY0_CON19	0x07ac
+#define RK3228_GRF_USBPHY0_CON20	0x07b0
+#define RK3228_GRF_USBPHY0_CON21	0x07b4
+#define RK3228_GRF_USBPHY0_CON22	0x07b8
+#define RK3228_GRF_USBPHY0_CON23	0x07bc
+#define RK3228_GRF_USBPHY0_CON24	0x07c0
+#define RK3228_GRF_USBPHY0_CON25	0x07c4
+#define RK3228_GRF_USBPHY0_CON26	0x07c8
+#define RK3228_GRF_USBPHY1_CON0		0x0800
+#define RK3228_GRF_USBPHY1_CON1		0x0804
+#define RK3228_GRF_USBPHY1_CON2		0x0808
+#define RK3228_GRF_USBPHY1_CON3		0x080c
+#define RK3228_GRF_USBPHY1_CON4		0x0810
+#define RK3228_GRF_USBPHY1_CON5		0x0814
+#define RK3228_GRF_USBPHY1_CON6		0x0818
+#define RK3228_GRF_USBPHY1_CON7		0x081c
+#define RK3228_GRF_USBPHY1_CON8		0x0820
+#define RK3228_GRF_USBPHY1_CON9		0x0824
+#define RK3228_GRF_USBPHY1_CON10	0x0828
+#define RK3228_GRF_USBPHY1_CON11	0x082c
+#define RK3228_GRF_USBPHY1_CON12	0x0830
+#define RK3228_GRF_USBPHY1_CON13	0x0834
+#define RK3228_GRF_USBPHY1_CON14	0x0838
+#define RK3228_GRF_USBPHY1_CON15	0x083c
+#define RK3228_GRF_USBPHY1_CON16	0x0840
+#define RK3228_GRF_USBPHY1_CON17	0x0844
+#define RK3228_GRF_USBPHY1_CON18	0x0848
+#define RK3228_GRF_USBPHY1_CON19	0x084c
+#define RK3228_GRF_USBPHY1_CON20	0x0850
+#define RK3228_GRF_USBPHY1_CON21	0x0854
+#define RK3228_GRF_USBPHY1_CON22	0x0858
+#define RK3228_GRF_USBPHY1_CON23	0x085c
+#define RK3228_GRF_USBPHY1_CON24	0x0860
+#define RK3228_GRF_USBPHY1_CON25	0x0864
+#define RK3228_GRF_USBPHY1_CON26	0x0868
+#define RK3228_GRF_OTG_CON0		0x0880
+#define RK3228_GRF_UOC_CON0		0x0884
+#define RK3228_GRF_MAC_CON0		0x0900
+#define RK3228_GRF_MAC_CON1		0x0904
+#define RK3228_GRF_MACPHY_CON0		0x0b00
+#define RK3228_GRF_MACPHY_CON1		0x0b04
+#define RK3228_GRF_MACPHY_CON2		0x0b08
+#define RK3228_GRF_MACPHY_CON3		0x0b0c
+#define RK3228_GRF_MACPHY_STATUS	0x0b10
+
+#endif
diff --git a/include/linux/rockchip/nvmem.h b/include/linux/rockchip/nvmem.h
new file mode 100644
index 000000000000..741887856e33
--- /dev/null
+++ b/include/linux/rockchip/nvmem.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2023 Rockchip Electronics Co. Ltd.
+ * Author: Hisping <hisping.lin@rock-chips.com>
+ */
+#ifndef __ROCKCHIP_NVMEM_H
+#define __ROCKCHIP_NVMEM_H
+
+#if IS_REACHABLE(CONFIG_NVMEM_ROCKCHIP_SEC_OTP)
+int rockchip_read_oem_non_protected_otp(unsigned int byte_off,
+				void *byte_buf, size_t byte_len);
+int rockchip_write_oem_non_protected_otp(unsigned int byte_off,
+				void *byte_buf, size_t byte_len);
+#else
+static inline int rockchip_read_oem_non_protected_otp(unsigned int byte_off,
+				void *byte_buf, size_t byte_len)
+{
+	return -EINVAL;
+}
+static inline int rockchip_write_oem_non_protected_otp(unsigned int byte_off,
+				void *byte_buf, size_t byte_len)
+{
+	return -EINVAL;
+}
+#endif
+#endif
diff --git a/include/linux/rockchip/psci.h b/include/linux/rockchip/psci.h
new file mode 100644
index 000000000000..870da27edf65
--- /dev/null
+++ b/include/linux/rockchip/psci.h
@@ -0,0 +1,76 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ROCKCHIP_PSCI_H
+#define __ROCKCHIP_PSCI_H
+
+#define SEC_REG_RD (0x0)
+#define SEC_REG_WR (0x1)
+
+/*
+ * trust firmware verison
+ */
+#define RKTF_VER_MAJOR(ver)		(((ver) >> 16) & 0xffff)
+#define RKTF_VER_MINOR(ver)		((ver) & 0xffff)
+
+/*
+ * pcsi smc funciton id
+ */
+#define PSCI_SIP_RKTF_VER		(0x82000001)
+#define PSCI_SIP_ACCESS_REG		(0x82000002)
+#define PSCI_SIP_ACCESS_REG64		(0xc2000002)
+#define PSCI_SIP_SUSPEND_WR_CTRBITS	(0x82000003)
+#define PSCI_SIP_PENDING_CPUS		(0x82000004)
+#define PSCI_SIP_UARTDBG_CFG		(0x82000005)
+#define PSCI_SIP_UARTDBG_CFG64		(0xc2000005)
+#define PSCI_SIP_EL3FIQ_CFG		(0x82000006)
+#define PSCI_SIP_SMEM_CONFIG		(0x82000007)
+
+/*
+ * pcsi smc funciton err code
+ */
+#define PSCI_SMC_FUNC_UNK		0xffffffff
+
+/*
+ * define PSCI_SIP_UARTDBG_CFG call type
+ */
+#define UARTDBG_CFG_INIT		0xf0
+#define UARTDBG_CFG_OSHDL_TO_OS		0xf1
+#define UARTDBG_CFG_OSHDL_CPUSW		0xf3
+#define UARTDBG_CFG_OSHDL_DEBUG_ENABLE	0xf4
+#define UARTDBG_CFG_OSHDL_DEBUG_DISABLE	0xf5
+
+/*
+ * rockchip psci function call interface
+ */
+
+u32 rockchip_psci_smc_read(u32 function_id, u32 arg0, u32 arg1, u32 arg2,
+			   u32 *val);
+u32 rockchip_psci_smc_write(u32 function_id, u32 arg0, u32 arg1, u32 arg2);
+
+u32 rockchip_psci_smc_get_tf_ver(void);
+u32 rockchip_secure_reg_read(u32 addr_phy);
+u32 rockchip_secure_reg_write(u32 addr_phy, u32 val);
+
+#ifdef CONFIG_ARM64
+u32 rockchip_psci_smc_write64(u64 function_id, u64 arg0, u64 arg1, u64 arg2);
+u32 rockchip_psci_smc_read64(u64 function_id, u64 arg0, u64 arg1, u64 arg2,
+			     u64 *val);
+u64 rockchip_secure_reg_read64(u64 addr_phy);
+u32 rockchip_secure_reg_write64(u64 addr_phy, u64 val);
+
+void psci_fiq_debugger_uart_irq_tf_cb(u64 sp_el1, u64 offset);
+#endif
+
+u32 psci_fiq_debugger_switch_cpu(u32 cpu);
+void psci_fiq_debugger_uart_irq_tf_init(u32 irq_id, void *callback);
+void psci_fiq_debugger_enable_debug(bool val);
+
+#if defined(CONFIG_ARM_PSCI) || defined(CONFIG_ARM64)
+u32 psci_set_memory_secure(bool val);
+#else
+static inline u32 psci_set_memory_secure(bool val)
+{
+	return 0;
+}
+#endif
+
+#endif /* __ROCKCHIP_PSCI_H */
diff --git a/include/linux/rockchip/rockchip_sip.h b/include/linux/rockchip/rockchip_sip.h
new file mode 100644
index 000000000000..3504da1755b3
--- /dev/null
+++ b/include/linux/rockchip/rockchip_sip.h
@@ -0,0 +1,487 @@
+/* Copyright (c) 2016, Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __ROCKCHIP_SIP_H
+#define __ROCKCHIP_SIP_H
+
+#include <linux/arm-smccc.h>
+#include <linux/io.h>
+
+/* SMC function IDs for SiP Service queries, compatible with kernel-3.10 */
+#define SIP_ATF_VERSION			0x82000001
+#define SIP_ACCESS_REG			0x82000002
+#define SIP_SUSPEND_MODE		0x82000003
+#define SIP_PENDING_CPUS		0x82000004
+#define SIP_UARTDBG_CFG			0x82000005
+#define SIP_UARTDBG_CFG64		0xc2000005
+#define SIP_MCU_EL3FIQ_CFG		0x82000006
+#define SIP_ACCESS_CHIP_STATE64		0xc2000006
+#define SIP_SECURE_MEM_CONFIG		0x82000007
+#define SIP_ACCESS_CHIP_EXTRA_STATE64	0xc2000007
+#define SIP_DRAM_CONFIG			0x82000008
+#define SIP_SHARE_MEM			0x82000009
+#define SIP_SIP_VERSION			0x8200000a
+#define SIP_REMOTECTL_CFG		0x8200000b
+#define PSCI_SIP_VPU_RESET		0x8200000c
+#define SIP_BUS_CFG			0x8200000d
+#define SIP_LAST_LOG			0x8200000e
+#define SIP_SCMI_AGENT0			0x82000010
+#define SIP_SCMI_AGENT1			0x82000011
+#define SIP_SCMI_AGENT2			0x82000012
+#define SIP_SCMI_AGENT3			0x82000013
+#define SIP_SCMI_AGENT4			0x82000014
+#define SIP_SCMI_AGENT5			0x82000015
+#define SIP_SCMI_AGENT6			0x82000016
+#define SIP_SCMI_AGENT7			0x82000017
+#define SIP_SCMI_AGENT8			0x82000018
+#define SIP_SCMI_AGENT9			0x82000019
+#define SIP_SCMI_AGENT10		0x8200001a
+#define SIP_SCMI_AGENT11		0x8200001b
+#define SIP_SCMI_AGENT12		0x8200001c
+#define SIP_SCMI_AGENT13		0x8200001d
+#define SIP_SCMI_AGENT14		0x8200001e
+#define SIP_SCMI_AGENT15		0x8200001f
+#define SIP_SDEI_FIQ_DBG_SWITCH_CPU	0x82000020
+#define SIP_SDEI_FIQ_DBG_GET_EVENT_ID	0x82000021
+#define RK_SIP_AMP_CFG			0x82000022
+#define RK_SIP_FIQ_CTRL			0x82000024
+#define SIP_HDCP_CONFIG			0x82000025
+#define SIP_WDT_CFG			0x82000026
+#define SIP_HDMIRX_CFG			0x82000027
+
+#define TRUSTED_OS_HDCPKEY_INIT		0xB7000003
+
+/* Rockchip Sip version */
+#define SIP_IMPLEMENT_V1                (1)
+#define SIP_IMPLEMENT_V2                (2)
+
+/* Trust firmware version */
+#define ATF_VER_MAJOR(ver)		(((ver) >> 16) & 0xffff)
+#define ATF_VER_MINOR(ver)		(((ver) >> 0) & 0xffff)
+
+/* SIP_ACCESS_REG: read or write */
+#define SECURE_REG_RD			0x0
+#define SECURE_REG_WR			0x1
+
+/* Fiq debugger share memory: 8KB enough */
+#define FIQ_UARTDBG_PAGE_NUMS		2
+#define FIQ_UARTDBG_SHARE_MEM_SIZE	((FIQ_UARTDBG_PAGE_NUMS) * 4096)
+
+/* Error return code */
+#define IS_SIP_ERROR(x)			(!!(x))
+
+#define SIP_RET_SUCCESS			0
+#define SIP_RET_SMC_UNKNOWN		-1
+#define SIP_RET_NOT_SUPPORTED		-2
+#define SIP_RET_INVALID_PARAMS		-3
+#define SIP_RET_INVALID_ADDRESS		-4
+#define SIP_RET_DENIED			-5
+#define SIP_RET_SET_RATE_TIMEOUT	-6
+
+/* SIP_UARTDBG_CFG64 call types */
+#define UARTDBG_CFG_INIT		0xf0
+#define UARTDBG_CFG_OSHDL_TO_OS		0xf1
+#define UARTDBG_CFG_OSHDL_CPUSW		0xf3
+#define UARTDBG_CFG_OSHDL_DEBUG_ENABLE	0xf4
+#define UARTDBG_CFG_OSHDL_DEBUG_DISABLE	0xf5
+#define UARTDBG_CFG_PRINT_PORT		0xf7
+#define UARTDBG_CFG_FIQ_ENABEL		0xf8
+#define UARTDBG_CFG_FIQ_DISABEL		0xf9
+
+/* SIP_SUSPEND_MODE32 call types */
+#define SUSPEND_MODE_CONFIG		0x01
+#define WKUP_SOURCE_CONFIG		0x02
+#define PWM_REGULATOR_CONFIG		0x03
+#define GPIO_POWER_CONFIG		0x04
+#define SUSPEND_DEBUG_ENABLE		0x05
+#define APIOS_SUSPEND_CONFIG		0x06
+#define VIRTUAL_POWEROFF		0x07
+#define SUSPEND_WFI_TIME_MS		0x08
+#define LINUX_PM_STATE			0x09
+#define SUSPEND_IO_RET_CONFIG		0x0a
+
+/* SIP_REMOTECTL_CFG call types */
+#define	REMOTECTL_SET_IRQ		0xf0
+#define REMOTECTL_SET_PWM_CH		0xf1
+#define REMOTECTL_SET_PWRKEY		0xf2
+#define REMOTECTL_GET_WAKEUP_STATE	0xf3
+#define REMOTECTL_ENABLE		0xf4
+/* wakeup state */
+#define REMOTECTL_PWRKEY_WAKEUP		0xdeadbeaf
+
+struct dram_addrmap_info {
+	u64 ch_mask[2];
+	u64 bk_mask[4];
+	u64 bg_mask[2];
+	u64 cs_mask[2];
+	u32 reserved[20];
+	u32 bank_bit_first;
+	u32 bank_bit_mask;
+};
+
+/* AMP Ctrl */
+enum {
+	RK_AMP_SUB_FUNC_CFG_MODE = 0,
+	RK_AMP_SUB_FUNC_BOOT_ARG01,
+	RK_AMP_SUB_FUNC_BOOT_ARG23,
+	RK_AMP_SUB_FUNC_REQ_CPU_OFF,
+	RK_AMP_SUB_FUNC_GET_CPU_STATUS,
+	RK_AMP_SUB_FUNC_RSV, /* for RTOS */
+	RK_AMP_SUB_FUNC_CPU_ON,
+	RK_AMP_SUB_FUNC_END,
+};
+
+enum {
+	FIRMWARE_NONE,
+	FIRMWARE_TEE_32BIT,
+	FIRMWARE_ATF_32BIT,
+	FIRMWARE_ATF_64BIT,
+	FIRMWARE_END,
+};
+
+/* Share mem page types */
+typedef enum {
+	SHARE_PAGE_TYPE_INVALID = 0,
+	SHARE_PAGE_TYPE_UARTDBG,
+	SHARE_PAGE_TYPE_DDR,
+	SHARE_PAGE_TYPE_DDRDBG,
+	SHARE_PAGE_TYPE_DDRECC,
+	SHARE_PAGE_TYPE_DDRFSP,
+	SHARE_PAGE_TYPE_DDR_ADDRMAP,
+	SHARE_PAGE_TYPE_LAST_LOG,
+	SHARE_PAGE_TYPE_HDCP,
+	SHARE_PAGE_TYPE_MAX,
+} share_page_type_t;
+
+/* fiq control sub func */
+enum {
+	RK_SIP_FIQ_CTRL_FIQ_EN = 1,
+	RK_SIP_FIQ_CTRL_FIQ_DIS,
+	RK_SIP_FIQ_CTRL_SET_AFF
+};
+
+/* hdcp function types */
+enum {
+	HDCP_FUNC_STORAGE_INCRYPT = 1,
+	HDCP_FUNC_KEY_LOAD,
+	HDCP_FUNC_ENCRYPT_MODE
+};
+
+/* support hdcp device list */
+enum {
+	DP_TX0,
+	DP_TX1,
+	EDP_TX0,
+	EDP_TX1,
+	HDMI_TX0,
+	HDMI_TX1,
+	HDMI_RX,
+	MAX_DEVICE,
+};
+
+/* SIP_WDT_CONFIG call types  */
+enum {
+	WDT_START = 0,
+	WDT_STOP = 1,
+	WDT_PING = 2,
+};
+
+/* SIP_HDMIRX_CONFIG child configs */
+enum {
+	HDMIRX_AUTO_TOUCH_EN = 0,
+	HDMIRX_REG_PRE_FETCH = 1,
+	HDMIRX_INFO_NOTIFY = 2,
+};
+
+struct pt_regs;
+typedef void (*sip_fiq_debugger_uart_irq_tf_cb_t)(struct pt_regs *_pt_regs, unsigned long cpu);
+
+/*
+ * Rules: struct arm_smccc_res contains result and data, details:
+ *
+ * a0: error code(0: success, !0: error);
+ * a1~a3: data
+ */
+#if IS_REACHABLE(CONFIG_ROCKCHIP_SIP)
+struct arm_smccc_res sip_smc_get_atf_version(void);
+struct arm_smccc_res sip_smc_get_sip_version(void);
+struct arm_smccc_res sip_smc_dram(u32 arg0, u32 arg1, u32 arg2);
+struct arm_smccc_res sip_smc_request_share_mem(u32 page_num,
+					       share_page_type_t page_type);
+struct arm_smccc_res sip_smc_mcu_el3fiq(u32 arg0, u32 arg1, u32 arg2);
+struct arm_smccc_res sip_smc_vpu_reset(u32 arg0, u32 arg1, u32 arg2);
+struct arm_smccc_res sip_smc_get_suspend_info(u32 info);
+struct arm_smccc_res sip_smc_lastlog_request(void);
+
+int sip_smc_set_suspend_mode(u32 ctrl, u32 config1, u32 config2);
+int sip_smc_virtual_poweroff(void);
+int sip_smc_remotectl_config(u32 func, u32 data);
+
+int sip_smc_secure_reg_write(u32 addr_phy, u32 val);
+u32 sip_smc_secure_reg_read(u32 addr_phy);
+struct arm_smccc_res sip_smc_bus_config(u32 arg0, u32 arg1, u32 arg2);
+struct dram_addrmap_info *sip_smc_get_dram_map(void);
+int sip_smc_amp_config(u32 sub_func_id, u32 arg1, u32 arg2, u32 arg3);
+struct arm_smccc_res sip_smc_get_amp_info(u32 sub_func_id, u32 arg1);
+
+void __iomem *sip_hdcp_request_share_memory(int id);
+struct arm_smccc_res sip_hdcp_config(u32 arg0, u32 arg1, u32 arg2);
+ulong sip_cpu_logical_map_mpidr(u32 cpu);
+/***************************fiq debugger **************************************/
+void sip_fiq_debugger_enable_fiq(bool enable, uint32_t tgt_cpu);
+void sip_fiq_debugger_enable_debug(bool enable);
+int sip_fiq_debugger_uart_irq_tf_init(u32 irq_id, sip_fiq_debugger_uart_irq_tf_cb_t callback_fn);
+int sip_fiq_debugger_set_print_port(u32 port_phyaddr, u32 baudrate);
+int sip_fiq_debugger_request_share_memory(void);
+int sip_fiq_debugger_get_target_cpu(void);
+int sip_fiq_debugger_switch_cpu(u32 cpu);
+int sip_fiq_debugger_sdei_switch_cpu(u32 cur_cpu, u32 target_cpu, u32 flag);
+int sip_fiq_debugger_is_enabled(void);
+int sip_fiq_debugger_sdei_get_event_id(u32 *fiq, u32 *sw_cpu, u32 *flag);
+int sip_fiq_control(u32 sub_func, u32 irq, unsigned long data);
+int sip_wdt_config(u32 sub_func, u32 arg1, u32 arg2, u32 arg3);
+int sip_hdmirx_config(u32 sub_func, u32 arg1, u32 arg2, u32 arg3);
+int sip_hdcpkey_init(u32 hdcp_id);
+#else
+static inline struct arm_smccc_res sip_smc_get_atf_version(void)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline struct arm_smccc_res sip_smc_get_sip_version(void)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline struct arm_smccc_res sip_smc_dram(u32 arg0, u32 arg1, u32 arg2)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline struct arm_smccc_res sip_smc_request_share_mem
+			(u32 page_num, share_page_type_t page_type)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline struct arm_smccc_res sip_smc_mcu_el3fiq
+			(u32 arg0, u32 arg1, u32 arg2)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline struct arm_smccc_res
+sip_smc_vpu_reset(u32 arg0, u32 arg1, u32 arg2)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline struct arm_smccc_res sip_smc_get_suspend_info(u32 info)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline struct arm_smccc_res sip_smc_lastlog_request(void)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline int sip_smc_set_suspend_mode(u32 ctrl, u32 config1, u32 config2)
+{
+	return 0;
+}
+
+static inline int sip_smc_virtual_poweroff(void) { return 0; }
+static inline int sip_smc_remotectl_config(u32 func, u32 data) { return 0; }
+static inline int sip_smc_secure_reg_write(u32 addr_phy, u32 val) { return 0; }
+static inline u32 sip_smc_secure_reg_read(u32 addr_phy) { return 0; }
+
+static inline struct arm_smccc_res sip_smc_bus_config(u32 arg0, u32 arg1, u32 arg2)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+	return tmp;
+}
+
+static inline struct dram_addrmap_info *sip_smc_get_dram_map(void)
+{
+	return NULL;
+}
+
+static inline int sip_smc_amp_config(u32 sub_func_id,
+				     u32 arg1,
+				     u32 arg2,
+				     u32 arg3)
+{
+	return 0;
+}
+
+static inline struct arm_smccc_res sip_smc_get_amp_info(u32 sub_func_id,
+							u32 arg1)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED, };
+
+	return tmp;
+}
+
+static inline void __iomem *sip_hdcp_request_share_memory(int id)
+{
+	return NULL;
+}
+
+static inline struct arm_smccc_res sip_hdcp_config(u32 arg0, u32 arg1, u32 arg2)
+{
+	struct arm_smccc_res tmp = { .a0 = SIP_RET_NOT_SUPPORTED };
+
+	return tmp;
+}
+
+static inline ulong sip_cpu_logical_map_mpidr(u32 cpu) { return 0; }
+
+/***************************fiq debugger **************************************/
+static inline void sip_fiq_debugger_enable_fiq
+			(bool enable, uint32_t tgt_cpu) { return; }
+
+static inline void sip_fiq_debugger_enable_debug(bool enable) { return; }
+static inline int sip_fiq_debugger_uart_irq_tf_init(u32 irq_id,
+						    sip_fiq_debugger_uart_irq_tf_cb_t callback_fn)
+{
+	return 0;
+}
+
+static inline int sip_fiq_debugger_set_print_port(u32 port_phyaddr,
+						  u32 baudrate)
+{
+	return 0;
+}
+
+static inline int sip_fiq_debugger_request_share_memory(void) { return 0; }
+static inline int sip_fiq_debugger_get_target_cpu(void) { return 0; }
+static inline int sip_fiq_debugger_switch_cpu(u32 cpu) { return 0; }
+static inline int sip_fiq_debugger_sdei_switch_cpu(u32 cur_cpu, u32 target_cpu,
+						   u32 flag) { return 0; }
+static inline int sip_fiq_debugger_is_enabled(void) { return 0; }
+static inline int sip_fiq_debugger_sdei_get_event_id(u32 *fiq, u32 *sw_cpu, u32 *flag)
+{
+	return SIP_RET_NOT_SUPPORTED;
+}
+
+static inline int sip_fiq_control(u32 sub_func, u32 irq, unsigned long data)
+{
+	return 0;
+}
+
+static inline int sip_wdt_config(u32 sub_func,
+				 u32 arg1,
+				 u32 arg2,
+				 u32 arg3)
+{
+	return 0;
+}
+
+static inline int sip_hdmirx_config(u32 sub_func,
+				    u32 arg1,
+				    u32 arg2,
+				    u32 arg3)
+{
+	return SIP_RET_NOT_SUPPORTED;
+}
+
+static inline int sip_hdcpkey_init(u32 hdcp_id)
+{
+	return 0;
+}
+#endif
+
+/* 32-bit OP-TEE context, never change order of members! */
+struct sm_nsec_ctx {
+	u32 usr_sp;
+	u32 usr_lr;
+	u32 irq_spsr;
+	u32 irq_sp;
+	u32 irq_lr;
+	u32 fiq_spsr;
+	u32 fiq_sp;
+	u32 fiq_lr;
+	u32 svc_spsr;
+	u32 svc_sp;
+	u32 svc_lr;
+	u32 abt_spsr;
+	u32 abt_sp;
+	u32 abt_lr;
+	u32 und_spsr;
+	u32 und_sp;
+	u32 und_lr;
+	u32 mon_lr;
+	u32 mon_spsr;
+	u32 r4;
+	u32 r5;
+	u32 r6;
+	u32 r7;
+	u32 r8;
+	u32 r9;
+	u32 r10;
+	u32 r11;
+	u32 r12;
+	u32 r0;
+	u32 r1;
+	u32 r2;
+	u32 r3;
+};
+
+/* 64-bit ATF context, never change order of members! */
+struct gp_regs_ctx {
+	u64 x0;
+	u64 x1;
+	u64 x2;
+	u64 x3;
+	u64 x4;
+	u64 x5;
+	u64 x6;
+	u64 x7;
+	u64 x8;
+	u64 x9;
+	u64 x10;
+	u64 x11;
+	u64 x12;
+	u64 x13;
+	u64 x14;
+	u64 x15;
+	u64 x16;
+	u64 x17;
+	u64 x18;
+	u64 x19;
+	u64 x20;
+	u64 x21;
+	u64 x22;
+	u64 x23;
+	u64 x24;
+	u64 x25;
+	u64 x26;
+	u64 x27;
+	u64 x28;
+	u64 x29;
+	u64 lr;
+	u64 sp_el0;
+	u64 scr_el3;
+	u64 runtime_sp;
+	u64 spsr_el3;
+	u64 elr_el3;
+};
+
+#endif
-- 
2.47.1

